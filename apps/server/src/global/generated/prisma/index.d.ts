
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model InterviewSummary
 * 
 */
export type InterviewSummary = {
  id: string
  text: string
  generatedText: string
  touched: boolean
  createdAt: Date
  updatedAt: Date
  interviewId: string
}

/**
 * Model InterviewSource
 * 
 */
export type InterviewSource = {
  id: number
  sourceId: string
  platform: InterviewSourcePlatforms
  interviewId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Interview
 * 
 */
export type Interview = {
  id: string
  name: string
  recordingId: string | null
  workspaceId: string
  creatorId: string
  archived: boolean
  date: Date
  createdAt: Date
  updatedAt: Date
  recordingError: string | null
  projectId: string | null
}

/**
 * Model Video
 * 
 */
export type Video = {
  id: string
  startTime: Date
  recorderId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model EditableAsset
 * 
 */
export type EditableAsset = {
  id: string
  videoId: string
  status: EditableAssetStatus
  playbackId: string | null
  isSigned: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PlayableAsset
 * 
 */
export type PlayableAsset = {
  id: string
  videoId: string
  platform: StoragePlatforms
  isSigned: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Transcript
 * 
 */
export type Transcript = {
  id: string
  version: number
  interviewId: string | null
  isPending: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TranscriptGroup
 * 
 */
export type TranscriptGroup = {
  text: string
  transcriptId: string
  groupNumber: number
  speakerId: string
}

/**
 * Model TranscriptWord
 * 
 */
export type TranscriptWord = {
  transcriptId: string
  groupNumber: number
  wordNumber: number
  start: number
  end: number
  text: string
}

/**
 * Model WordRange
 * 
 */
export type WordRange = {
  id: string
  transcriptId: string
  startWordNumber: number
  startGroupNumber: number
  endWordNumber: number
  endGroupNumber: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Highlight
 * 
 */
export type Highlight = {
  id: string
  highlightedRangeId: string | null
  timestamp: Date | null
  interviewId: string
  videoId: string | null
  transcriptId: string | null
  createdAt: Date
  updatedAt: Date
  originSuggestionId: string | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  session: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  /**
   * @encrypted
   */
  email: string
  /**
   * @encryption:hash(email)
   */
  emailHash: string | null
  /**
   * @encrypted
   */
  fullName: string
  confirmed: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Identity
 * 
 */
export type Identity = {
  token: string
  userId: string
  type: IdentityType
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ExternalAuth
 * 
 */
export type ExternalAuth = {
  userId: string
  type: ExternalAuthTypes
  /**
   * @encrypted
   */
  authToken: string
  /**
   * @encrypted
   */
  refreshToken: string
  expiresAt: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Workspace
 * 
 */
export type Workspace = {
  id: string
  name: string
  publicInterviewLinks: boolean
  ownedDomain: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WorkspaceInvite
 * 
 */
export type WorkspaceInvite = {
  token: string
  workspaceId: string
  inviterId: string
  isExpired: boolean
  inviteeEmail: string | null
  isAccepted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WorkspaceRole
 * 
 */
export type WorkspaceRole = {
  userId: string
  workspaceId: string
  type: RoleType
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Participant
 * 
 */
export type Participant = {
  id: string
  name: string
}

/**
 * Model Tag
 * 
 */
export type Tag = {
  id: string
  name: string
  color: TagColor
  workspaceId: string
  autoExtract: boolean
  description: string | null
  isDefault: boolean
  createdAt: Date
  updatedAt: Date
  emoji: string
}

/**
 * Model NotificationPreferences
 * 
 */
export type NotificationPreferences = {
  id: string
  userId: string
  notificationEmails: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserTagOrder
 * 
 */
export type UserTagOrder = {
  id: string
  userId: string
  tagId: string
  position: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SuggestedHighlight
 * 
 */
export type SuggestedHighlight = {
  id: string
  highlightedRangeId: string
  interviewId: string
  transcriptId: string
  status: SuggestedHighlightStatus
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Project
 * 
 */
export type Project = {
  id: string
  name: string
  description: string
  workspaceId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProjectTags
 * 
 */
export type ProjectTags = {
  id: string
  projectId: string
  tagId: string
  position: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Recorder
 * 
 */
export type Recorder = {
  id: string
  externalId: string | null
  error: string | null
  type: RecorderType
  targetId: string
  createdAt: Date
  updatedAt: Date
  status: RecorderStatus
}

/**
 * Model RecordingTarget
 * 
 */
export type RecordingTarget = {
  id: string
  type: RecordingTargetType
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const EditableAssetStatus: {
  processing: 'processing',
  completed: 'completed'
};

export type EditableAssetStatus = (typeof EditableAssetStatus)[keyof typeof EditableAssetStatus]


export const ExternalAuthTypes: {
  zoom: 'zoom',
  zoomV2: 'zoomV2'
};

export type ExternalAuthTypes = (typeof ExternalAuthTypes)[keyof typeof ExternalAuthTypes]


export const IdentityType: {
  password: 'password',
  zoom: 'zoom'
};

export type IdentityType = (typeof IdentityType)[keyof typeof IdentityType]


export const InterviewSourcePlatforms: {
  zoom: 'zoom',
  zoomV2: 'zoomV2',
  upload: 'upload',
  recall: 'recall'
};

export type InterviewSourcePlatforms = (typeof InterviewSourcePlatforms)[keyof typeof InterviewSourcePlatforms]


export const RecorderStatus: {
  pending: 'pending',
  recording: 'recording',
  done: 'done'
};

export type RecorderStatus = (typeof RecorderStatus)[keyof typeof RecorderStatus]


export const RecorderType: {
  recall: 'recall'
};

export type RecorderType = (typeof RecorderType)[keyof typeof RecorderType]


export const RecordingTargetType: {
  zoom: 'zoom',
  zoomV2: 'zoomV2'
};

export type RecordingTargetType = (typeof RecordingTargetType)[keyof typeof RecordingTargetType]


export const RoleType: {
  admin: 'admin',
  member: 'member'
};

export type RoleType = (typeof RoleType)[keyof typeof RoleType]


export const StoragePlatforms: {
  s3: 's3',
  local: 'local',
  mux: 'mux'
};

export type StoragePlatforms = (typeof StoragePlatforms)[keyof typeof StoragePlatforms]


export const SuggestedHighlightStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type SuggestedHighlightStatus = (typeof SuggestedHighlightStatus)[keyof typeof SuggestedHighlightStatus]


export const TagColor: {
  red: 'red',
  orange: 'orange',
  yellow: 'yellow',
  green: 'green',
  indigo: 'indigo',
  sky: 'sky',
  purple: 'purple'
};

export type TagColor = (typeof TagColor)[keyof typeof TagColor]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more InterviewSummaries
 * const interviewSummaries = await prisma.interviewSummary.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more InterviewSummaries
   * const interviewSummaries = await prisma.interviewSummary.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.interviewSummary`: Exposes CRUD operations for the **InterviewSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSummaries
    * const interviewSummaries = await prisma.interviewSummary.findMany()
    * ```
    */
  get interviewSummary(): Prisma.InterviewSummaryDelegate<GlobalReject>;

  /**
   * `prisma.interviewSource`: Exposes CRUD operations for the **InterviewSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSources
    * const interviewSources = await prisma.interviewSource.findMany()
    * ```
    */
  get interviewSource(): Prisma.InterviewSourceDelegate<GlobalReject>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.InterviewDelegate<GlobalReject>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<GlobalReject>;

  /**
   * `prisma.editableAsset`: Exposes CRUD operations for the **EditableAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EditableAssets
    * const editableAssets = await prisma.editableAsset.findMany()
    * ```
    */
  get editableAsset(): Prisma.EditableAssetDelegate<GlobalReject>;

  /**
   * `prisma.playableAsset`: Exposes CRUD operations for the **PlayableAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayableAssets
    * const playableAssets = await prisma.playableAsset.findMany()
    * ```
    */
  get playableAsset(): Prisma.PlayableAssetDelegate<GlobalReject>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<GlobalReject>;

  /**
   * `prisma.transcriptGroup`: Exposes CRUD operations for the **TranscriptGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptGroups
    * const transcriptGroups = await prisma.transcriptGroup.findMany()
    * ```
    */
  get transcriptGroup(): Prisma.TranscriptGroupDelegate<GlobalReject>;

  /**
   * `prisma.transcriptWord`: Exposes CRUD operations for the **TranscriptWord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptWords
    * const transcriptWords = await prisma.transcriptWord.findMany()
    * ```
    */
  get transcriptWord(): Prisma.TranscriptWordDelegate<GlobalReject>;

  /**
   * `prisma.wordRange`: Exposes CRUD operations for the **WordRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WordRanges
    * const wordRanges = await prisma.wordRange.findMany()
    * ```
    */
  get wordRange(): Prisma.WordRangeDelegate<GlobalReject>;

  /**
   * `prisma.highlight`: Exposes CRUD operations for the **Highlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Highlights
    * const highlights = await prisma.highlight.findMany()
    * ```
    */
  get highlight(): Prisma.HighlightDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.identity`: Exposes CRUD operations for the **Identity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identities
    * const identities = await prisma.identity.findMany()
    * ```
    */
  get identity(): Prisma.IdentityDelegate<GlobalReject>;

  /**
   * `prisma.externalAuth`: Exposes CRUD operations for the **ExternalAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAuths
    * const externalAuths = await prisma.externalAuth.findMany()
    * ```
    */
  get externalAuth(): Prisma.ExternalAuthDelegate<GlobalReject>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<GlobalReject>;

  /**
   * `prisma.workspaceInvite`: Exposes CRUD operations for the **WorkspaceInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvites
    * const workspaceInvites = await prisma.workspaceInvite.findMany()
    * ```
    */
  get workspaceInvite(): Prisma.WorkspaceInviteDelegate<GlobalReject>;

  /**
   * `prisma.workspaceRole`: Exposes CRUD operations for the **WorkspaceRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceRoles
    * const workspaceRoles = await prisma.workspaceRole.findMany()
    * ```
    */
  get workspaceRole(): Prisma.WorkspaceRoleDelegate<GlobalReject>;

  /**
   * `prisma.participant`: Exposes CRUD operations for the **Participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participant.findMany()
    * ```
    */
  get participant(): Prisma.ParticipantDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.notificationPreferences`: Exposes CRUD operations for the **NotificationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreferences.findMany()
    * ```
    */
  get notificationPreferences(): Prisma.NotificationPreferencesDelegate<GlobalReject>;

  /**
   * `prisma.userTagOrder`: Exposes CRUD operations for the **UserTagOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTagOrders
    * const userTagOrders = await prisma.userTagOrder.findMany()
    * ```
    */
  get userTagOrder(): Prisma.UserTagOrderDelegate<GlobalReject>;

  /**
   * `prisma.suggestedHighlight`: Exposes CRUD operations for the **SuggestedHighlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuggestedHighlights
    * const suggestedHighlights = await prisma.suggestedHighlight.findMany()
    * ```
    */
  get suggestedHighlight(): Prisma.SuggestedHighlightDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.projectTags`: Exposes CRUD operations for the **ProjectTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTags
    * const projectTags = await prisma.projectTags.findMany()
    * ```
    */
  get projectTags(): Prisma.ProjectTagsDelegate<GlobalReject>;

  /**
   * `prisma.recorder`: Exposes CRUD operations for the **Recorder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recorders
    * const recorders = await prisma.recorder.findMany()
    * ```
    */
  get recorder(): Prisma.RecorderDelegate<GlobalReject>;

  /**
   * `prisma.recordingTarget`: Exposes CRUD operations for the **RecordingTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecordingTargets
    * const recordingTargets = await prisma.recordingTarget.findMany()
    * ```
    */
  get recordingTarget(): Prisma.RecordingTargetDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    InterviewSummary: 'InterviewSummary',
    InterviewSource: 'InterviewSource',
    Interview: 'Interview',
    Video: 'Video',
    EditableAsset: 'EditableAsset',
    PlayableAsset: 'PlayableAsset',
    Transcript: 'Transcript',
    TranscriptGroup: 'TranscriptGroup',
    TranscriptWord: 'TranscriptWord',
    WordRange: 'WordRange',
    Highlight: 'Highlight',
    Session: 'Session',
    User: 'User',
    Identity: 'Identity',
    ExternalAuth: 'ExternalAuth',
    Workspace: 'Workspace',
    WorkspaceInvite: 'WorkspaceInvite',
    WorkspaceRole: 'WorkspaceRole',
    Participant: 'Participant',
    Tag: 'Tag',
    NotificationPreferences: 'NotificationPreferences',
    UserTagOrder: 'UserTagOrder',
    SuggestedHighlight: 'SuggestedHighlight',
    Project: 'Project',
    ProjectTags: 'ProjectTags',
    Recorder: 'Recorder',
    RecordingTarget: 'RecordingTarget'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InterviewCountOutputType
   */


  export type InterviewCountOutputType = {
    highlights: number
    suggestedHighlights: number
  }

  export type InterviewCountOutputTypeSelect = {
    highlights?: boolean
    suggestedHighlights?: boolean
  }

  export type InterviewCountOutputTypeGetPayload<S extends boolean | null | undefined | InterviewCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InterviewCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InterviewCountOutputTypeArgs)
    ? InterviewCountOutputType 
    : S extends { select: any } & (InterviewCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InterviewCountOutputType ? InterviewCountOutputType[P] : never
  } 
      : InterviewCountOutputType




  // Custom InputTypes

  /**
   * InterviewCountOutputType without action
   */
  export type InterviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InterviewCountOutputType
     */
    select?: InterviewCountOutputTypeSelect | null
  }



  /**
   * Count Type TranscriptCountOutputType
   */


  export type TranscriptCountOutputType = {
    words: number
    groups: number
  }

  export type TranscriptCountOutputTypeSelect = {
    words?: boolean
    groups?: boolean
  }

  export type TranscriptCountOutputTypeGetPayload<S extends boolean | null | undefined | TranscriptCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TranscriptCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptCountOutputTypeArgs)
    ? TranscriptCountOutputType 
    : S extends { select: any } & (TranscriptCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TranscriptCountOutputType ? TranscriptCountOutputType[P] : never
  } 
      : TranscriptCountOutputType




  // Custom InputTypes

  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TranscriptCountOutputType
     */
    select?: TranscriptCountOutputTypeSelect | null
  }



  /**
   * Count Type TranscriptGroupCountOutputType
   */


  export type TranscriptGroupCountOutputType = {
    words: number
  }

  export type TranscriptGroupCountOutputTypeSelect = {
    words?: boolean
  }

  export type TranscriptGroupCountOutputTypeGetPayload<S extends boolean | null | undefined | TranscriptGroupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TranscriptGroupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptGroupCountOutputTypeArgs)
    ? TranscriptGroupCountOutputType 
    : S extends { select: any } & (TranscriptGroupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TranscriptGroupCountOutputType ? TranscriptGroupCountOutputType[P] : never
  } 
      : TranscriptGroupCountOutputType




  // Custom InputTypes

  /**
   * TranscriptGroupCountOutputType without action
   */
  export type TranscriptGroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroupCountOutputType
     */
    select?: TranscriptGroupCountOutputTypeSelect | null
  }



  /**
   * Count Type TranscriptWordCountOutputType
   */


  export type TranscriptWordCountOutputType = {
    startWordRanges: number
    endWordRanges: number
  }

  export type TranscriptWordCountOutputTypeSelect = {
    startWordRanges?: boolean
    endWordRanges?: boolean
  }

  export type TranscriptWordCountOutputTypeGetPayload<S extends boolean | null | undefined | TranscriptWordCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TranscriptWordCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptWordCountOutputTypeArgs)
    ? TranscriptWordCountOutputType 
    : S extends { select: any } & (TranscriptWordCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TranscriptWordCountOutputType ? TranscriptWordCountOutputType[P] : never
  } 
      : TranscriptWordCountOutputType




  // Custom InputTypes

  /**
   * TranscriptWordCountOutputType without action
   */
  export type TranscriptWordCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWordCountOutputType
     */
    select?: TranscriptWordCountOutputTypeSelect | null
  }



  /**
   * Count Type HighlightCountOutputType
   */


  export type HighlightCountOutputType = {
    tags: number
  }

  export type HighlightCountOutputTypeSelect = {
    tags?: boolean
  }

  export type HighlightCountOutputTypeGetPayload<S extends boolean | null | undefined | HighlightCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HighlightCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HighlightCountOutputTypeArgs)
    ? HighlightCountOutputType 
    : S extends { select: any } & (HighlightCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HighlightCountOutputType ? HighlightCountOutputType[P] : never
  } 
      : HighlightCountOutputType




  // Custom InputTypes

  /**
   * HighlightCountOutputType without action
   */
  export type HighlightCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HighlightCountOutputType
     */
    select?: HighlightCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    interviews: number
    roles: number
    sourceAuths: number
    identities: number
    inviteTokens: number
    tagOrder: number
  }

  export type UserCountOutputTypeSelect = {
    interviews?: boolean
    roles?: boolean
    sourceAuths?: boolean
    identities?: boolean
    inviteTokens?: boolean
    tagOrder?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkspaceCountOutputType
   */


  export type WorkspaceCountOutputType = {
    roles: number
    interviews: number
    inviteTokens: number
    tags: number
    projects: number
  }

  export type WorkspaceCountOutputTypeSelect = {
    roles?: boolean
    interviews?: boolean
    inviteTokens?: boolean
    tags?: boolean
    projects?: boolean
  }

  export type WorkspaceCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkspaceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkspaceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkspaceCountOutputTypeArgs)
    ? WorkspaceCountOutputType 
    : S extends { select: any } & (WorkspaceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkspaceCountOutputType ? WorkspaceCountOutputType[P] : never
  } 
      : WorkspaceCountOutputType




  // Custom InputTypes

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect | null
  }



  /**
   * Count Type ParticipantCountOutputType
   */


  export type ParticipantCountOutputType = {
    groups: number
  }

  export type ParticipantCountOutputTypeSelect = {
    groups?: boolean
  }

  export type ParticipantCountOutputTypeGetPayload<S extends boolean | null | undefined | ParticipantCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ParticipantCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ParticipantCountOutputTypeArgs)
    ? ParticipantCountOutputType 
    : S extends { select: any } & (ParticipantCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ParticipantCountOutputType ? ParticipantCountOutputType[P] : never
  } 
      : ParticipantCountOutputType




  // Custom InputTypes

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ParticipantCountOutputType
     */
    select?: ParticipantCountOutputTypeSelect | null
  }



  /**
   * Count Type TagCountOutputType
   */


  export type TagCountOutputType = {
    highlights: number
    suggestedHighlights: number
    userOrders: number
    projectTags: number
  }

  export type TagCountOutputTypeSelect = {
    highlights?: boolean
    suggestedHighlights?: boolean
    userOrders?: boolean
    projectTags?: boolean
  }

  export type TagCountOutputTypeGetPayload<S extends boolean | null | undefined | TagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TagCountOutputTypeArgs)
    ? TagCountOutputType 
    : S extends { select: any } & (TagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TagCountOutputType ? TagCountOutputType[P] : never
  } 
      : TagCountOutputType




  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect | null
  }



  /**
   * Count Type SuggestedHighlightCountOutputType
   */


  export type SuggestedHighlightCountOutputType = {
    tags: number
  }

  export type SuggestedHighlightCountOutputTypeSelect = {
    tags?: boolean
  }

  export type SuggestedHighlightCountOutputTypeGetPayload<S extends boolean | null | undefined | SuggestedHighlightCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SuggestedHighlightCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SuggestedHighlightCountOutputTypeArgs)
    ? SuggestedHighlightCountOutputType 
    : S extends { select: any } & (SuggestedHighlightCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SuggestedHighlightCountOutputType ? SuggestedHighlightCountOutputType[P] : never
  } 
      : SuggestedHighlightCountOutputType




  // Custom InputTypes

  /**
   * SuggestedHighlightCountOutputType without action
   */
  export type SuggestedHighlightCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlightCountOutputType
     */
    select?: SuggestedHighlightCountOutputTypeSelect | null
  }



  /**
   * Count Type ProjectCountOutputType
   */


  export type ProjectCountOutputType = {
    interviews: number
    projectTags: number
  }

  export type ProjectCountOutputTypeSelect = {
    interviews?: boolean
    projectTags?: boolean
  }

  export type ProjectCountOutputTypeGetPayload<S extends boolean | null | undefined | ProjectCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProjectCountOutputTypeArgs)
    ? ProjectCountOutputType 
    : S extends { select: any } & (ProjectCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProjectCountOutputType ? ProjectCountOutputType[P] : never
  } 
      : ProjectCountOutputType




  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect | null
  }



  /**
   * Count Type RecorderCountOutputType
   */


  export type RecorderCountOutputType = {
    Video: number
  }

  export type RecorderCountOutputTypeSelect = {
    Video?: boolean
  }

  export type RecorderCountOutputTypeGetPayload<S extends boolean | null | undefined | RecorderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RecorderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RecorderCountOutputTypeArgs)
    ? RecorderCountOutputType 
    : S extends { select: any } & (RecorderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RecorderCountOutputType ? RecorderCountOutputType[P] : never
  } 
      : RecorderCountOutputType




  // Custom InputTypes

  /**
   * RecorderCountOutputType without action
   */
  export type RecorderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecorderCountOutputType
     */
    select?: RecorderCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model InterviewSummary
   */


  export type AggregateInterviewSummary = {
    _count: InterviewSummaryCountAggregateOutputType | null
    _min: InterviewSummaryMinAggregateOutputType | null
    _max: InterviewSummaryMaxAggregateOutputType | null
  }

  export type InterviewSummaryMinAggregateOutputType = {
    id: string | null
    text: string | null
    generatedText: string | null
    touched: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    interviewId: string | null
  }

  export type InterviewSummaryMaxAggregateOutputType = {
    id: string | null
    text: string | null
    generatedText: string | null
    touched: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    interviewId: string | null
  }

  export type InterviewSummaryCountAggregateOutputType = {
    id: number
    text: number
    generatedText: number
    touched: number
    createdAt: number
    updatedAt: number
    interviewId: number
    _all: number
  }


  export type InterviewSummaryMinAggregateInputType = {
    id?: true
    text?: true
    generatedText?: true
    touched?: true
    createdAt?: true
    updatedAt?: true
    interviewId?: true
  }

  export type InterviewSummaryMaxAggregateInputType = {
    id?: true
    text?: true
    generatedText?: true
    touched?: true
    createdAt?: true
    updatedAt?: true
    interviewId?: true
  }

  export type InterviewSummaryCountAggregateInputType = {
    id?: true
    text?: true
    generatedText?: true
    touched?: true
    createdAt?: true
    updatedAt?: true
    interviewId?: true
    _all?: true
  }

  export type InterviewSummaryAggregateArgs = {
    /**
     * Filter which InterviewSummary to aggregate.
     */
    where?: InterviewSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSummaries to fetch.
     */
    orderBy?: Enumerable<InterviewSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSummaries
    **/
    _count?: true | InterviewSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSummaryMaxAggregateInputType
  }

  export type GetInterviewSummaryAggregateType<T extends InterviewSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSummary[P]>
      : GetScalarType<T[P], AggregateInterviewSummary[P]>
  }




  export type InterviewSummaryGroupByArgs = {
    where?: InterviewSummaryWhereInput
    orderBy?: Enumerable<InterviewSummaryOrderByWithAggregationInput>
    by: InterviewSummaryScalarFieldEnum[]
    having?: InterviewSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSummaryCountAggregateInputType | true
    _min?: InterviewSummaryMinAggregateInputType
    _max?: InterviewSummaryMaxAggregateInputType
  }


  export type InterviewSummaryGroupByOutputType = {
    id: string
    text: string
    generatedText: string
    touched: boolean
    createdAt: Date
    updatedAt: Date
    interviewId: string
    _count: InterviewSummaryCountAggregateOutputType | null
    _min: InterviewSummaryMinAggregateOutputType | null
    _max: InterviewSummaryMaxAggregateOutputType | null
  }

  type GetInterviewSummaryGroupByPayload<T extends InterviewSummaryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InterviewSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSummaryGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSummarySelect = {
    id?: boolean
    text?: boolean
    generatedText?: boolean
    touched?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interview?: boolean | InterviewArgs
    interviewId?: boolean
  }


  export type InterviewSummaryInclude = {
    interview?: boolean | InterviewArgs
  }

  export type InterviewSummaryGetPayload<S extends boolean | null | undefined | InterviewSummaryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InterviewSummary :
    S extends undefined ? never :
    S extends { include: any } & (InterviewSummaryArgs | InterviewSummaryFindManyArgs)
    ? InterviewSummary  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InterviewSummaryArgs | InterviewSummaryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> :  P extends keyof InterviewSummary ? InterviewSummary[P] : never
  } 
      : InterviewSummary


  type InterviewSummaryCountArgs = 
    Omit<InterviewSummaryFindManyArgs, 'select' | 'include'> & {
      select?: InterviewSummaryCountAggregateInputType | true
    }

  export interface InterviewSummaryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one InterviewSummary that matches the filter.
     * @param {InterviewSummaryFindUniqueArgs} args - Arguments to find a InterviewSummary
     * @example
     * // Get one InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InterviewSummaryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InterviewSummaryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InterviewSummary'> extends True ? Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>> : Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T> | null, null>

    /**
     * Find one InterviewSummary that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InterviewSummaryFindUniqueOrThrowArgs} args - Arguments to find a InterviewSummary
     * @example
     * // Get one InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InterviewSummaryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InterviewSummaryFindUniqueOrThrowArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Find the first InterviewSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryFindFirstArgs} args - Arguments to find a InterviewSummary
     * @example
     * // Get one InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InterviewSummaryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InterviewSummaryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InterviewSummary'> extends True ? Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>> : Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T> | null, null>

    /**
     * Find the first InterviewSummary that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryFindFirstOrThrowArgs} args - Arguments to find a InterviewSummary
     * @example
     * // Get one InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InterviewSummaryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InterviewSummaryFindFirstOrThrowArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Find zero or more InterviewSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSummaries
     * const interviewSummaries = await prisma.interviewSummary.findMany()
     * 
     * // Get first 10 InterviewSummaries
     * const interviewSummaries = await prisma.interviewSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSummaryWithIdOnly = await prisma.interviewSummary.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InterviewSummaryFindManyArgs>(
      args?: SelectSubset<T, InterviewSummaryFindManyArgs>
    ): PrismaPromise<Array<InterviewSummaryGetPayload<T>>>

    /**
     * Create a InterviewSummary.
     * @param {InterviewSummaryCreateArgs} args - Arguments to create a InterviewSummary.
     * @example
     * // Create one InterviewSummary
     * const InterviewSummary = await prisma.interviewSummary.create({
     *   data: {
     *     // ... data to create a InterviewSummary
     *   }
     * })
     * 
    **/
    create<T extends InterviewSummaryCreateArgs>(
      args: SelectSubset<T, InterviewSummaryCreateArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Create many InterviewSummaries.
     *     @param {InterviewSummaryCreateManyArgs} args - Arguments to create many InterviewSummaries.
     *     @example
     *     // Create many InterviewSummaries
     *     const interviewSummary = await prisma.interviewSummary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InterviewSummaryCreateManyArgs>(
      args?: SelectSubset<T, InterviewSummaryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewSummary.
     * @param {InterviewSummaryDeleteArgs} args - Arguments to delete one InterviewSummary.
     * @example
     * // Delete one InterviewSummary
     * const InterviewSummary = await prisma.interviewSummary.delete({
     *   where: {
     *     // ... filter to delete one InterviewSummary
     *   }
     * })
     * 
    **/
    delete<T extends InterviewSummaryDeleteArgs>(
      args: SelectSubset<T, InterviewSummaryDeleteArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Update one InterviewSummary.
     * @param {InterviewSummaryUpdateArgs} args - Arguments to update one InterviewSummary.
     * @example
     * // Update one InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InterviewSummaryUpdateArgs>(
      args: SelectSubset<T, InterviewSummaryUpdateArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Delete zero or more InterviewSummaries.
     * @param {InterviewSummaryDeleteManyArgs} args - Arguments to filter InterviewSummaries to delete.
     * @example
     * // Delete a few InterviewSummaries
     * const { count } = await prisma.interviewSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InterviewSummaryDeleteManyArgs>(
      args?: SelectSubset<T, InterviewSummaryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSummaries
     * const interviewSummary = await prisma.interviewSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InterviewSummaryUpdateManyArgs>(
      args: SelectSubset<T, InterviewSummaryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewSummary.
     * @param {InterviewSummaryUpsertArgs} args - Arguments to update or create a InterviewSummary.
     * @example
     * // Update or create a InterviewSummary
     * const interviewSummary = await prisma.interviewSummary.upsert({
     *   create: {
     *     // ... data to create a InterviewSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSummary we want to update
     *   }
     * })
    **/
    upsert<T extends InterviewSummaryUpsertArgs>(
      args: SelectSubset<T, InterviewSummaryUpsertArgs>
    ): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T>>

    /**
     * Count the number of InterviewSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryCountArgs} args - Arguments to filter InterviewSummaries to count.
     * @example
     * // Count the number of InterviewSummaries
     * const count = await prisma.interviewSummary.count({
     *   where: {
     *     // ... the filter for the InterviewSummaries we want to count
     *   }
     * })
    **/
    count<T extends InterviewSummaryCountArgs>(
      args?: Subset<T, InterviewSummaryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSummaryAggregateArgs>(args: Subset<T, InterviewSummaryAggregateArgs>): PrismaPromise<GetInterviewSummaryAggregateType<T>>

    /**
     * Group by InterviewSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSummaryGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSummaryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InterviewSummaryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InterviewSummary base type for findUnique actions
   */
  export type InterviewSummaryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter, which InterviewSummary to fetch.
     */
    where: InterviewSummaryWhereUniqueInput
  }

  /**
   * InterviewSummary findUnique
   */
  export interface InterviewSummaryFindUniqueArgs extends InterviewSummaryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InterviewSummary findUniqueOrThrow
   */
  export type InterviewSummaryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter, which InterviewSummary to fetch.
     */
    where: InterviewSummaryWhereUniqueInput
  }


  /**
   * InterviewSummary base type for findFirst actions
   */
  export type InterviewSummaryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter, which InterviewSummary to fetch.
     */
    where?: InterviewSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSummaries to fetch.
     */
    orderBy?: Enumerable<InterviewSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSummaries.
     */
    cursor?: InterviewSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSummaries.
     */
    distinct?: Enumerable<InterviewSummaryScalarFieldEnum>
  }

  /**
   * InterviewSummary findFirst
   */
  export interface InterviewSummaryFindFirstArgs extends InterviewSummaryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InterviewSummary findFirstOrThrow
   */
  export type InterviewSummaryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter, which InterviewSummary to fetch.
     */
    where?: InterviewSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSummaries to fetch.
     */
    orderBy?: Enumerable<InterviewSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSummaries.
     */
    cursor?: InterviewSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSummaries.
     */
    distinct?: Enumerable<InterviewSummaryScalarFieldEnum>
  }


  /**
   * InterviewSummary findMany
   */
  export type InterviewSummaryFindManyArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter, which InterviewSummaries to fetch.
     */
    where?: InterviewSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSummaries to fetch.
     */
    orderBy?: Enumerable<InterviewSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSummaries.
     */
    cursor?: InterviewSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSummaries.
     */
    skip?: number
    distinct?: Enumerable<InterviewSummaryScalarFieldEnum>
  }


  /**
   * InterviewSummary create
   */
  export type InterviewSummaryCreateArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * The data needed to create a InterviewSummary.
     */
    data: XOR<InterviewSummaryCreateInput, InterviewSummaryUncheckedCreateInput>
  }


  /**
   * InterviewSummary createMany
   */
  export type InterviewSummaryCreateManyArgs = {
    /**
     * The data used to create many InterviewSummaries.
     */
    data: Enumerable<InterviewSummaryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InterviewSummary update
   */
  export type InterviewSummaryUpdateArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * The data needed to update a InterviewSummary.
     */
    data: XOR<InterviewSummaryUpdateInput, InterviewSummaryUncheckedUpdateInput>
    /**
     * Choose, which InterviewSummary to update.
     */
    where: InterviewSummaryWhereUniqueInput
  }


  /**
   * InterviewSummary updateMany
   */
  export type InterviewSummaryUpdateManyArgs = {
    /**
     * The data used to update InterviewSummaries.
     */
    data: XOR<InterviewSummaryUpdateManyMutationInput, InterviewSummaryUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSummaries to update
     */
    where?: InterviewSummaryWhereInput
  }


  /**
   * InterviewSummary upsert
   */
  export type InterviewSummaryUpsertArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * The filter to search for the InterviewSummary to update in case it exists.
     */
    where: InterviewSummaryWhereUniqueInput
    /**
     * In case the InterviewSummary found by the `where` argument doesn't exist, create a new InterviewSummary with this data.
     */
    create: XOR<InterviewSummaryCreateInput, InterviewSummaryUncheckedCreateInput>
    /**
     * In case the InterviewSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSummaryUpdateInput, InterviewSummaryUncheckedUpdateInput>
  }


  /**
   * InterviewSummary delete
   */
  export type InterviewSummaryDeleteArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
    /**
     * Filter which InterviewSummary to delete.
     */
    where: InterviewSummaryWhereUniqueInput
  }


  /**
   * InterviewSummary deleteMany
   */
  export type InterviewSummaryDeleteManyArgs = {
    /**
     * Filter which InterviewSummaries to delete
     */
    where?: InterviewSummaryWhereInput
  }


  /**
   * InterviewSummary without action
   */
  export type InterviewSummaryArgs = {
    /**
     * Select specific fields to fetch from the InterviewSummary
     */
    select?: InterviewSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSummaryInclude | null
  }



  /**
   * Model InterviewSource
   */


  export type AggregateInterviewSource = {
    _count: InterviewSourceCountAggregateOutputType | null
    _avg: InterviewSourceAvgAggregateOutputType | null
    _sum: InterviewSourceSumAggregateOutputType | null
    _min: InterviewSourceMinAggregateOutputType | null
    _max: InterviewSourceMaxAggregateOutputType | null
  }

  export type InterviewSourceAvgAggregateOutputType = {
    id: number | null
  }

  export type InterviewSourceSumAggregateOutputType = {
    id: number | null
  }

  export type InterviewSourceMinAggregateOutputType = {
    id: number | null
    sourceId: string | null
    platform: InterviewSourcePlatforms | null
    interviewId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewSourceMaxAggregateOutputType = {
    id: number | null
    sourceId: string | null
    platform: InterviewSourcePlatforms | null
    interviewId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewSourceCountAggregateOutputType = {
    id: number
    sourceId: number
    platform: number
    interviewId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewSourceAvgAggregateInputType = {
    id?: true
  }

  export type InterviewSourceSumAggregateInputType = {
    id?: true
  }

  export type InterviewSourceMinAggregateInputType = {
    id?: true
    sourceId?: true
    platform?: true
    interviewId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewSourceMaxAggregateInputType = {
    id?: true
    sourceId?: true
    platform?: true
    interviewId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewSourceCountAggregateInputType = {
    id?: true
    sourceId?: true
    platform?: true
    interviewId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewSourceAggregateArgs = {
    /**
     * Filter which InterviewSource to aggregate.
     */
    where?: InterviewSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSources to fetch.
     */
    orderBy?: Enumerable<InterviewSourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSources
    **/
    _count?: true | InterviewSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSourceMaxAggregateInputType
  }

  export type GetInterviewSourceAggregateType<T extends InterviewSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSource[P]>
      : GetScalarType<T[P], AggregateInterviewSource[P]>
  }




  export type InterviewSourceGroupByArgs = {
    where?: InterviewSourceWhereInput
    orderBy?: Enumerable<InterviewSourceOrderByWithAggregationInput>
    by: InterviewSourceScalarFieldEnum[]
    having?: InterviewSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSourceCountAggregateInputType | true
    _avg?: InterviewSourceAvgAggregateInputType
    _sum?: InterviewSourceSumAggregateInputType
    _min?: InterviewSourceMinAggregateInputType
    _max?: InterviewSourceMaxAggregateInputType
  }


  export type InterviewSourceGroupByOutputType = {
    id: number
    sourceId: string
    platform: InterviewSourcePlatforms
    interviewId: string
    createdAt: Date
    updatedAt: Date
    _count: InterviewSourceCountAggregateOutputType | null
    _avg: InterviewSourceAvgAggregateOutputType | null
    _sum: InterviewSourceSumAggregateOutputType | null
    _min: InterviewSourceMinAggregateOutputType | null
    _max: InterviewSourceMaxAggregateOutputType | null
  }

  type GetInterviewSourceGroupByPayload<T extends InterviewSourceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InterviewSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSourceGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSourceGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSourceSelect = {
    id?: boolean
    sourceId?: boolean
    platform?: boolean
    interview?: boolean | InterviewArgs
    interviewId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type InterviewSourceInclude = {
    interview?: boolean | InterviewArgs
  }

  export type InterviewSourceGetPayload<S extends boolean | null | undefined | InterviewSourceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InterviewSource :
    S extends undefined ? never :
    S extends { include: any } & (InterviewSourceArgs | InterviewSourceFindManyArgs)
    ? InterviewSource  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InterviewSourceArgs | InterviewSourceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> :  P extends keyof InterviewSource ? InterviewSource[P] : never
  } 
      : InterviewSource


  type InterviewSourceCountArgs = 
    Omit<InterviewSourceFindManyArgs, 'select' | 'include'> & {
      select?: InterviewSourceCountAggregateInputType | true
    }

  export interface InterviewSourceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one InterviewSource that matches the filter.
     * @param {InterviewSourceFindUniqueArgs} args - Arguments to find a InterviewSource
     * @example
     * // Get one InterviewSource
     * const interviewSource = await prisma.interviewSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InterviewSourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InterviewSourceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InterviewSource'> extends True ? Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>> : Prisma__InterviewSourceClient<InterviewSourceGetPayload<T> | null, null>

    /**
     * Find one InterviewSource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InterviewSourceFindUniqueOrThrowArgs} args - Arguments to find a InterviewSource
     * @example
     * // Get one InterviewSource
     * const interviewSource = await prisma.interviewSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InterviewSourceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InterviewSourceFindUniqueOrThrowArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Find the first InterviewSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceFindFirstArgs} args - Arguments to find a InterviewSource
     * @example
     * // Get one InterviewSource
     * const interviewSource = await prisma.interviewSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InterviewSourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InterviewSourceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InterviewSource'> extends True ? Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>> : Prisma__InterviewSourceClient<InterviewSourceGetPayload<T> | null, null>

    /**
     * Find the first InterviewSource that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceFindFirstOrThrowArgs} args - Arguments to find a InterviewSource
     * @example
     * // Get one InterviewSource
     * const interviewSource = await prisma.interviewSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InterviewSourceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InterviewSourceFindFirstOrThrowArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Find zero or more InterviewSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSources
     * const interviewSources = await prisma.interviewSource.findMany()
     * 
     * // Get first 10 InterviewSources
     * const interviewSources = await prisma.interviewSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSourceWithIdOnly = await prisma.interviewSource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InterviewSourceFindManyArgs>(
      args?: SelectSubset<T, InterviewSourceFindManyArgs>
    ): PrismaPromise<Array<InterviewSourceGetPayload<T>>>

    /**
     * Create a InterviewSource.
     * @param {InterviewSourceCreateArgs} args - Arguments to create a InterviewSource.
     * @example
     * // Create one InterviewSource
     * const InterviewSource = await prisma.interviewSource.create({
     *   data: {
     *     // ... data to create a InterviewSource
     *   }
     * })
     * 
    **/
    create<T extends InterviewSourceCreateArgs>(
      args: SelectSubset<T, InterviewSourceCreateArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Create many InterviewSources.
     *     @param {InterviewSourceCreateManyArgs} args - Arguments to create many InterviewSources.
     *     @example
     *     // Create many InterviewSources
     *     const interviewSource = await prisma.interviewSource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InterviewSourceCreateManyArgs>(
      args?: SelectSubset<T, InterviewSourceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InterviewSource.
     * @param {InterviewSourceDeleteArgs} args - Arguments to delete one InterviewSource.
     * @example
     * // Delete one InterviewSource
     * const InterviewSource = await prisma.interviewSource.delete({
     *   where: {
     *     // ... filter to delete one InterviewSource
     *   }
     * })
     * 
    **/
    delete<T extends InterviewSourceDeleteArgs>(
      args: SelectSubset<T, InterviewSourceDeleteArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Update one InterviewSource.
     * @param {InterviewSourceUpdateArgs} args - Arguments to update one InterviewSource.
     * @example
     * // Update one InterviewSource
     * const interviewSource = await prisma.interviewSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InterviewSourceUpdateArgs>(
      args: SelectSubset<T, InterviewSourceUpdateArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Delete zero or more InterviewSources.
     * @param {InterviewSourceDeleteManyArgs} args - Arguments to filter InterviewSources to delete.
     * @example
     * // Delete a few InterviewSources
     * const { count } = await prisma.interviewSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InterviewSourceDeleteManyArgs>(
      args?: SelectSubset<T, InterviewSourceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSources
     * const interviewSource = await prisma.interviewSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InterviewSourceUpdateManyArgs>(
      args: SelectSubset<T, InterviewSourceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewSource.
     * @param {InterviewSourceUpsertArgs} args - Arguments to update or create a InterviewSource.
     * @example
     * // Update or create a InterviewSource
     * const interviewSource = await prisma.interviewSource.upsert({
     *   create: {
     *     // ... data to create a InterviewSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSource we want to update
     *   }
     * })
    **/
    upsert<T extends InterviewSourceUpsertArgs>(
      args: SelectSubset<T, InterviewSourceUpsertArgs>
    ): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T>>

    /**
     * Count the number of InterviewSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceCountArgs} args - Arguments to filter InterviewSources to count.
     * @example
     * // Count the number of InterviewSources
     * const count = await prisma.interviewSource.count({
     *   where: {
     *     // ... the filter for the InterviewSources we want to count
     *   }
     * })
    **/
    count<T extends InterviewSourceCountArgs>(
      args?: Subset<T, InterviewSourceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSourceAggregateArgs>(args: Subset<T, InterviewSourceAggregateArgs>): PrismaPromise<GetInterviewSourceAggregateType<T>>

    /**
     * Group by InterviewSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSourceGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSourceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InterviewSourceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InterviewSource base type for findUnique actions
   */
  export type InterviewSourceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter, which InterviewSource to fetch.
     */
    where: InterviewSourceWhereUniqueInput
  }

  /**
   * InterviewSource findUnique
   */
  export interface InterviewSourceFindUniqueArgs extends InterviewSourceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InterviewSource findUniqueOrThrow
   */
  export type InterviewSourceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter, which InterviewSource to fetch.
     */
    where: InterviewSourceWhereUniqueInput
  }


  /**
   * InterviewSource base type for findFirst actions
   */
  export type InterviewSourceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter, which InterviewSource to fetch.
     */
    where?: InterviewSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSources to fetch.
     */
    orderBy?: Enumerable<InterviewSourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSources.
     */
    cursor?: InterviewSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSources.
     */
    distinct?: Enumerable<InterviewSourceScalarFieldEnum>
  }

  /**
   * InterviewSource findFirst
   */
  export interface InterviewSourceFindFirstArgs extends InterviewSourceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InterviewSource findFirstOrThrow
   */
  export type InterviewSourceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter, which InterviewSource to fetch.
     */
    where?: InterviewSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSources to fetch.
     */
    orderBy?: Enumerable<InterviewSourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSources.
     */
    cursor?: InterviewSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSources.
     */
    distinct?: Enumerable<InterviewSourceScalarFieldEnum>
  }


  /**
   * InterviewSource findMany
   */
  export type InterviewSourceFindManyArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter, which InterviewSources to fetch.
     */
    where?: InterviewSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSources to fetch.
     */
    orderBy?: Enumerable<InterviewSourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSources.
     */
    cursor?: InterviewSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSources.
     */
    skip?: number
    distinct?: Enumerable<InterviewSourceScalarFieldEnum>
  }


  /**
   * InterviewSource create
   */
  export type InterviewSourceCreateArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * The data needed to create a InterviewSource.
     */
    data: XOR<InterviewSourceCreateInput, InterviewSourceUncheckedCreateInput>
  }


  /**
   * InterviewSource createMany
   */
  export type InterviewSourceCreateManyArgs = {
    /**
     * The data used to create many InterviewSources.
     */
    data: Enumerable<InterviewSourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InterviewSource update
   */
  export type InterviewSourceUpdateArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * The data needed to update a InterviewSource.
     */
    data: XOR<InterviewSourceUpdateInput, InterviewSourceUncheckedUpdateInput>
    /**
     * Choose, which InterviewSource to update.
     */
    where: InterviewSourceWhereUniqueInput
  }


  /**
   * InterviewSource updateMany
   */
  export type InterviewSourceUpdateManyArgs = {
    /**
     * The data used to update InterviewSources.
     */
    data: XOR<InterviewSourceUpdateManyMutationInput, InterviewSourceUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSources to update
     */
    where?: InterviewSourceWhereInput
  }


  /**
   * InterviewSource upsert
   */
  export type InterviewSourceUpsertArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * The filter to search for the InterviewSource to update in case it exists.
     */
    where: InterviewSourceWhereUniqueInput
    /**
     * In case the InterviewSource found by the `where` argument doesn't exist, create a new InterviewSource with this data.
     */
    create: XOR<InterviewSourceCreateInput, InterviewSourceUncheckedCreateInput>
    /**
     * In case the InterviewSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSourceUpdateInput, InterviewSourceUncheckedUpdateInput>
  }


  /**
   * InterviewSource delete
   */
  export type InterviewSourceDeleteArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
    /**
     * Filter which InterviewSource to delete.
     */
    where: InterviewSourceWhereUniqueInput
  }


  /**
   * InterviewSource deleteMany
   */
  export type InterviewSourceDeleteManyArgs = {
    /**
     * Filter which InterviewSources to delete
     */
    where?: InterviewSourceWhereInput
  }


  /**
   * InterviewSource without action
   */
  export type InterviewSourceArgs = {
    /**
     * Select specific fields to fetch from the InterviewSource
     */
    select?: InterviewSourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewSourceInclude | null
  }



  /**
   * Model Interview
   */


  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewMinAggregateOutputType = {
    id: string | null
    name: string | null
    recordingId: string | null
    workspaceId: string | null
    creatorId: string | null
    archived: boolean | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    recordingError: string | null
    projectId: string | null
  }

  export type InterviewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    recordingId: string | null
    workspaceId: string | null
    creatorId: string | null
    archived: boolean | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    recordingError: string | null
    projectId: string | null
  }

  export type InterviewCountAggregateOutputType = {
    id: number
    name: number
    recordingId: number
    workspaceId: number
    creatorId: number
    archived: number
    date: number
    createdAt: number
    updatedAt: number
    recordingError: number
    projectId: number
    _all: number
  }


  export type InterviewMinAggregateInputType = {
    id?: true
    name?: true
    recordingId?: true
    workspaceId?: true
    creatorId?: true
    archived?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    recordingError?: true
    projectId?: true
  }

  export type InterviewMaxAggregateInputType = {
    id?: true
    name?: true
    recordingId?: true
    workspaceId?: true
    creatorId?: true
    archived?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    recordingError?: true
    projectId?: true
  }

  export type InterviewCountAggregateInputType = {
    id?: true
    name?: true
    recordingId?: true
    workspaceId?: true
    creatorId?: true
    archived?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    recordingError?: true
    projectId?: true
    _all?: true
  }

  export type InterviewAggregateArgs = {
    /**
     * Filter which Interview to aggregate.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type InterviewGroupByArgs = {
    where?: InterviewWhereInput
    orderBy?: Enumerable<InterviewOrderByWithAggregationInput>
    by: InterviewScalarFieldEnum[]
    having?: InterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }


  export type InterviewGroupByOutputType = {
    id: string
    name: string
    recordingId: string | null
    workspaceId: string
    creatorId: string
    archived: boolean
    date: Date
    createdAt: Date
    updatedAt: Date
    recordingError: string | null
    projectId: string | null
    _count: InterviewCountAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends InterviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSelect = {
    id?: boolean
    name?: boolean
    recording?: boolean | VideoArgs
    recordingId?: boolean
    transcript?: boolean | TranscriptArgs
    highlights?: boolean | Interview$highlightsArgs
    workspaceId?: boolean
    workspace?: boolean | WorkspaceArgs
    source?: boolean | InterviewSourceArgs
    summary?: boolean | InterviewSummaryArgs
    creator?: boolean | UserArgs
    creatorId?: boolean
    archived?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordingError?: boolean
    suggestedHighlights?: boolean | Interview$suggestedHighlightsArgs
    project?: boolean | ProjectArgs
    projectId?: boolean
    _count?: boolean | InterviewCountOutputTypeArgs
  }


  export type InterviewInclude = {
    recording?: boolean | VideoArgs
    transcript?: boolean | TranscriptArgs
    highlights?: boolean | Interview$highlightsArgs
    workspace?: boolean | WorkspaceArgs
    source?: boolean | InterviewSourceArgs
    summary?: boolean | InterviewSummaryArgs
    creator?: boolean | UserArgs
    suggestedHighlights?: boolean | Interview$suggestedHighlightsArgs
    project?: boolean | ProjectArgs
    _count?: boolean | InterviewCountOutputTypeArgs
  }

  export type InterviewGetPayload<S extends boolean | null | undefined | InterviewArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Interview :
    S extends undefined ? never :
    S extends { include: any } & (InterviewArgs | InterviewFindManyArgs)
    ? Interview  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recording' ? VideoGetPayload<S['include'][P]> | null :
        P extends 'transcript' ? TranscriptGetPayload<S['include'][P]> | null :
        P extends 'highlights' ? Array < HighlightGetPayload<S['include'][P]>>  :
        P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
        P extends 'source' ? InterviewSourceGetPayload<S['include'][P]> | null :
        P extends 'summary' ? InterviewSummaryGetPayload<S['include'][P]> | null :
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'suggestedHighlights' ? Array < SuggestedHighlightGetPayload<S['include'][P]>>  :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :
        P extends '_count' ? InterviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InterviewArgs | InterviewFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recording' ? VideoGetPayload<S['select'][P]> | null :
        P extends 'transcript' ? TranscriptGetPayload<S['select'][P]> | null :
        P extends 'highlights' ? Array < HighlightGetPayload<S['select'][P]>>  :
        P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
        P extends 'source' ? InterviewSourceGetPayload<S['select'][P]> | null :
        P extends 'summary' ? InterviewSummaryGetPayload<S['select'][P]> | null :
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'suggestedHighlights' ? Array < SuggestedHighlightGetPayload<S['select'][P]>>  :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :
        P extends '_count' ? InterviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Interview ? Interview[P] : never
  } 
      : Interview


  type InterviewCountArgs = 
    Omit<InterviewFindManyArgs, 'select' | 'include'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface InterviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Interview that matches the filter.
     * @param {InterviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InterviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InterviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Interview'> extends True ? Prisma__InterviewClient<InterviewGetPayload<T>> : Prisma__InterviewClient<InterviewGetPayload<T> | null, null>

    /**
     * Find one Interview that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InterviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InterviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InterviewFindUniqueOrThrowArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InterviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InterviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Interview'> extends True ? Prisma__InterviewClient<InterviewGetPayload<T>> : Prisma__InterviewClient<InterviewGetPayload<T> | null, null>

    /**
     * Find the first Interview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InterviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InterviewFindFirstOrThrowArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewWithIdOnly = await prisma.interview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InterviewFindManyArgs>(
      args?: SelectSubset<T, InterviewFindManyArgs>
    ): PrismaPromise<Array<InterviewGetPayload<T>>>

    /**
     * Create a Interview.
     * @param {InterviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
    **/
    create<T extends InterviewCreateArgs>(
      args: SelectSubset<T, InterviewCreateArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Create many Interviews.
     *     @param {InterviewCreateManyArgs} args - Arguments to create many Interviews.
     *     @example
     *     // Create many Interviews
     *     const interview = await prisma.interview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InterviewCreateManyArgs>(
      args?: SelectSubset<T, InterviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Interview.
     * @param {InterviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
    **/
    delete<T extends InterviewDeleteArgs>(
      args: SelectSubset<T, InterviewDeleteArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Update one Interview.
     * @param {InterviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InterviewUpdateArgs>(
      args: SelectSubset<T, InterviewUpdateArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Delete zero or more Interviews.
     * @param {InterviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InterviewDeleteManyArgs>(
      args?: SelectSubset<T, InterviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InterviewUpdateManyArgs>(
      args: SelectSubset<T, InterviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Interview.
     * @param {InterviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
    **/
    upsert<T extends InterviewUpsertArgs>(
      args: SelectSubset<T, InterviewUpsertArgs>
    ): Prisma__InterviewClient<InterviewGetPayload<T>>

    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends InterviewCountArgs>(
      args?: Subset<T, InterviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewGroupByArgs['orderBy'] }
        : { orderBy?: InterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InterviewClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recording<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    transcript<T extends TranscriptArgs= {}>(args?: Subset<T, TranscriptArgs>): Prisma__TranscriptClient<TranscriptGetPayload<T> | Null>;

    highlights<T extends Interview$highlightsArgs= {}>(args?: Subset<T, Interview$highlightsArgs>): PrismaPromise<Array<HighlightGetPayload<T>>| Null>;

    workspace<T extends WorkspaceArgs= {}>(args?: Subset<T, WorkspaceArgs>): Prisma__WorkspaceClient<WorkspaceGetPayload<T> | Null>;

    source<T extends InterviewSourceArgs= {}>(args?: Subset<T, InterviewSourceArgs>): Prisma__InterviewSourceClient<InterviewSourceGetPayload<T> | Null>;

    summary<T extends InterviewSummaryArgs= {}>(args?: Subset<T, InterviewSummaryArgs>): Prisma__InterviewSummaryClient<InterviewSummaryGetPayload<T> | Null>;

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    suggestedHighlights<T extends Interview$suggestedHighlightsArgs= {}>(args?: Subset<T, Interview$suggestedHighlightsArgs>): PrismaPromise<Array<SuggestedHighlightGetPayload<T>>| Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Interview base type for findUnique actions
   */
  export type InterviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findUnique
   */
  export interface InterviewFindUniqueArgs extends InterviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Interview findUniqueOrThrow
   */
  export type InterviewFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }


  /**
   * Interview base type for findFirst actions
   */
  export type InterviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }

  /**
   * Interview findFirst
   */
  export interface InterviewFindFirstArgs extends InterviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Interview findFirstOrThrow
   */
  export type InterviewFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }


  /**
   * Interview findMany
   */
  export type InterviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter, which Interviews to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }


  /**
   * Interview create
   */
  export type InterviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * The data needed to create a Interview.
     */
    data: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
  }


  /**
   * Interview createMany
   */
  export type InterviewCreateManyArgs = {
    /**
     * The data used to create many Interviews.
     */
    data: Enumerable<InterviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Interview update
   */
  export type InterviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * The data needed to update a Interview.
     */
    data: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
    /**
     * Choose, which Interview to update.
     */
    where: InterviewWhereUniqueInput
  }


  /**
   * Interview updateMany
   */
  export type InterviewUpdateManyArgs = {
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
  }


  /**
   * Interview upsert
   */
  export type InterviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * The filter to search for the Interview to update in case it exists.
     */
    where: InterviewWhereUniqueInput
    /**
     * In case the Interview found by the `where` argument doesn't exist, create a new Interview with this data.
     */
    create: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
    /**
     * In case the Interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
  }


  /**
   * Interview delete
   */
  export type InterviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    /**
     * Filter which Interview to delete.
     */
    where: InterviewWhereUniqueInput
  }


  /**
   * Interview deleteMany
   */
  export type InterviewDeleteManyArgs = {
    /**
     * Filter which Interviews to delete
     */
    where?: InterviewWhereInput
  }


  /**
   * Interview.highlights
   */
  export type Interview$highlightsArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    where?: HighlightWhereInput
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    cursor?: HighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HighlightScalarFieldEnum>
  }


  /**
   * Interview.suggestedHighlights
   */
  export type Interview$suggestedHighlightsArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    where?: SuggestedHighlightWhereInput
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    cursor?: SuggestedHighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SuggestedHighlightScalarFieldEnum>
  }


  /**
   * Interview without action
   */
  export type InterviewArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    recorderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    recorderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    startTime: number
    recorderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoMinAggregateInputType = {
    id?: true
    startTime?: true
    recorderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    startTime?: true
    recorderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    startTime?: true
    recorderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs = {
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithAggregationInput>
    by: VideoScalarFieldEnum[]
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }


  export type VideoGroupByOutputType = {
    id: string
    startTime: Date
    recorderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect = {
    id?: boolean
    interview?: boolean | InterviewArgs
    highlight?: boolean | HighlightArgs
    startTime?: boolean
    editableAsset?: boolean | EditableAssetArgs
    playableAsset?: boolean | PlayableAssetArgs
    recorder?: boolean | RecorderArgs
    recorderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type VideoInclude = {
    interview?: boolean | InterviewArgs
    highlight?: boolean | HighlightArgs
    editableAsset?: boolean | EditableAssetArgs
    playableAsset?: boolean | PlayableAssetArgs
    recorder?: boolean | RecorderArgs
  }

  export type VideoGetPayload<S extends boolean | null | undefined | VideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Video :
    S extends undefined ? never :
    S extends { include: any } & (VideoArgs | VideoFindManyArgs)
    ? Video  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> | null :
        P extends 'highlight' ? HighlightGetPayload<S['include'][P]> | null :
        P extends 'editableAsset' ? EditableAssetGetPayload<S['include'][P]> | null :
        P extends 'playableAsset' ? PlayableAssetGetPayload<S['include'][P]> | null :
        P extends 'recorder' ? RecorderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (VideoArgs | VideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> | null :
        P extends 'highlight' ? HighlightGetPayload<S['select'][P]> | null :
        P extends 'editableAsset' ? EditableAssetGetPayload<S['select'][P]> | null :
        P extends 'playableAsset' ? PlayableAssetGetPayload<S['select'][P]> | null :
        P extends 'recorder' ? RecorderGetPayload<S['select'][P]> | null :  P extends keyof Video ? Video[P] : never
  } 
      : Video


  type VideoCountArgs = 
    Omit<VideoFindManyArgs, 'select' | 'include'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find one Video that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VideoFindUniqueOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find the first Video that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VideoFindFirstOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs>(
      args?: SelectSubset<T, VideoFindManyArgs>
    ): PrismaPromise<Array<VideoGetPayload<T>>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: SelectSubset<T, VideoCreateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs>(
      args?: SelectSubset<T, VideoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: SelectSubset<T, VideoDeleteArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: SelectSubset<T, VideoUpdateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args?: SelectSubset<T, VideoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: SelectSubset<T, VideoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: SelectSubset<T, VideoUpsertArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    highlight<T extends HighlightArgs= {}>(args?: Subset<T, HighlightArgs>): Prisma__HighlightClient<HighlightGetPayload<T> | Null>;

    editableAsset<T extends EditableAssetArgs= {}>(args?: Subset<T, EditableAssetArgs>): Prisma__EditableAssetClient<EditableAssetGetPayload<T> | Null>;

    playableAsset<T extends PlayableAssetArgs= {}>(args?: Subset<T, PlayableAssetArgs>): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T> | Null>;

    recorder<T extends RecorderArgs= {}>(args?: Subset<T, RecorderArgs>): Prisma__RecorderClient<RecorderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Video base type for findUnique actions
   */
  export type VideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUnique
   */
  export interface VideoFindUniqueArgs extends VideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video base type for findFirst actions
   */
  export type VideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }

  /**
   * Video findFirst
   */
  export interface VideoFindFirstArgs extends VideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs = {
    /**
     * The data used to create many Videos.
     */
    data: Enumerable<VideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
  }



  /**
   * Model EditableAsset
   */


  export type AggregateEditableAsset = {
    _count: EditableAssetCountAggregateOutputType | null
    _min: EditableAssetMinAggregateOutputType | null
    _max: EditableAssetMaxAggregateOutputType | null
  }

  export type EditableAssetMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    status: EditableAssetStatus | null
    playbackId: string | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditableAssetMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    status: EditableAssetStatus | null
    playbackId: string | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditableAssetCountAggregateOutputType = {
    id: number
    videoId: number
    status: number
    playbackId: number
    isSigned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EditableAssetMinAggregateInputType = {
    id?: true
    videoId?: true
    status?: true
    playbackId?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditableAssetMaxAggregateInputType = {
    id?: true
    videoId?: true
    status?: true
    playbackId?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditableAssetCountAggregateInputType = {
    id?: true
    videoId?: true
    status?: true
    playbackId?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EditableAssetAggregateArgs = {
    /**
     * Filter which EditableAsset to aggregate.
     */
    where?: EditableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditableAssets to fetch.
     */
    orderBy?: Enumerable<EditableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EditableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EditableAssets
    **/
    _count?: true | EditableAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditableAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditableAssetMaxAggregateInputType
  }

  export type GetEditableAssetAggregateType<T extends EditableAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateEditableAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEditableAsset[P]>
      : GetScalarType<T[P], AggregateEditableAsset[P]>
  }




  export type EditableAssetGroupByArgs = {
    where?: EditableAssetWhereInput
    orderBy?: Enumerable<EditableAssetOrderByWithAggregationInput>
    by: EditableAssetScalarFieldEnum[]
    having?: EditableAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditableAssetCountAggregateInputType | true
    _min?: EditableAssetMinAggregateInputType
    _max?: EditableAssetMaxAggregateInputType
  }


  export type EditableAssetGroupByOutputType = {
    id: string
    videoId: string
    status: EditableAssetStatus
    playbackId: string | null
    isSigned: boolean
    createdAt: Date
    updatedAt: Date
    _count: EditableAssetCountAggregateOutputType | null
    _min: EditableAssetMinAggregateOutputType | null
    _max: EditableAssetMaxAggregateOutputType | null
  }

  type GetEditableAssetGroupByPayload<T extends EditableAssetGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EditableAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditableAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditableAssetGroupByOutputType[P]>
            : GetScalarType<T[P], EditableAssetGroupByOutputType[P]>
        }
      >
    >


  export type EditableAssetSelect = {
    id?: boolean
    video?: boolean | VideoArgs
    videoId?: boolean
    status?: boolean
    playbackId?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EditableAssetInclude = {
    video?: boolean | VideoArgs
  }

  export type EditableAssetGetPayload<S extends boolean | null | undefined | EditableAssetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EditableAsset :
    S extends undefined ? never :
    S extends { include: any } & (EditableAssetArgs | EditableAssetFindManyArgs)
    ? EditableAsset  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'video' ? VideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EditableAssetArgs | EditableAssetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'video' ? VideoGetPayload<S['select'][P]> :  P extends keyof EditableAsset ? EditableAsset[P] : never
  } 
      : EditableAsset


  type EditableAssetCountArgs = 
    Omit<EditableAssetFindManyArgs, 'select' | 'include'> & {
      select?: EditableAssetCountAggregateInputType | true
    }

  export interface EditableAssetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one EditableAsset that matches the filter.
     * @param {EditableAssetFindUniqueArgs} args - Arguments to find a EditableAsset
     * @example
     * // Get one EditableAsset
     * const editableAsset = await prisma.editableAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EditableAssetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EditableAssetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EditableAsset'> extends True ? Prisma__EditableAssetClient<EditableAssetGetPayload<T>> : Prisma__EditableAssetClient<EditableAssetGetPayload<T> | null, null>

    /**
     * Find one EditableAsset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EditableAssetFindUniqueOrThrowArgs} args - Arguments to find a EditableAsset
     * @example
     * // Get one EditableAsset
     * const editableAsset = await prisma.editableAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EditableAssetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EditableAssetFindUniqueOrThrowArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Find the first EditableAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetFindFirstArgs} args - Arguments to find a EditableAsset
     * @example
     * // Get one EditableAsset
     * const editableAsset = await prisma.editableAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EditableAssetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EditableAssetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EditableAsset'> extends True ? Prisma__EditableAssetClient<EditableAssetGetPayload<T>> : Prisma__EditableAssetClient<EditableAssetGetPayload<T> | null, null>

    /**
     * Find the first EditableAsset that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetFindFirstOrThrowArgs} args - Arguments to find a EditableAsset
     * @example
     * // Get one EditableAsset
     * const editableAsset = await prisma.editableAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EditableAssetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EditableAssetFindFirstOrThrowArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Find zero or more EditableAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EditableAssets
     * const editableAssets = await prisma.editableAsset.findMany()
     * 
     * // Get first 10 EditableAssets
     * const editableAssets = await prisma.editableAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editableAssetWithIdOnly = await prisma.editableAsset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EditableAssetFindManyArgs>(
      args?: SelectSubset<T, EditableAssetFindManyArgs>
    ): PrismaPromise<Array<EditableAssetGetPayload<T>>>

    /**
     * Create a EditableAsset.
     * @param {EditableAssetCreateArgs} args - Arguments to create a EditableAsset.
     * @example
     * // Create one EditableAsset
     * const EditableAsset = await prisma.editableAsset.create({
     *   data: {
     *     // ... data to create a EditableAsset
     *   }
     * })
     * 
    **/
    create<T extends EditableAssetCreateArgs>(
      args: SelectSubset<T, EditableAssetCreateArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Create many EditableAssets.
     *     @param {EditableAssetCreateManyArgs} args - Arguments to create many EditableAssets.
     *     @example
     *     // Create many EditableAssets
     *     const editableAsset = await prisma.editableAsset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EditableAssetCreateManyArgs>(
      args?: SelectSubset<T, EditableAssetCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EditableAsset.
     * @param {EditableAssetDeleteArgs} args - Arguments to delete one EditableAsset.
     * @example
     * // Delete one EditableAsset
     * const EditableAsset = await prisma.editableAsset.delete({
     *   where: {
     *     // ... filter to delete one EditableAsset
     *   }
     * })
     * 
    **/
    delete<T extends EditableAssetDeleteArgs>(
      args: SelectSubset<T, EditableAssetDeleteArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Update one EditableAsset.
     * @param {EditableAssetUpdateArgs} args - Arguments to update one EditableAsset.
     * @example
     * // Update one EditableAsset
     * const editableAsset = await prisma.editableAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EditableAssetUpdateArgs>(
      args: SelectSubset<T, EditableAssetUpdateArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Delete zero or more EditableAssets.
     * @param {EditableAssetDeleteManyArgs} args - Arguments to filter EditableAssets to delete.
     * @example
     * // Delete a few EditableAssets
     * const { count } = await prisma.editableAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EditableAssetDeleteManyArgs>(
      args?: SelectSubset<T, EditableAssetDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EditableAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EditableAssets
     * const editableAsset = await prisma.editableAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EditableAssetUpdateManyArgs>(
      args: SelectSubset<T, EditableAssetUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EditableAsset.
     * @param {EditableAssetUpsertArgs} args - Arguments to update or create a EditableAsset.
     * @example
     * // Update or create a EditableAsset
     * const editableAsset = await prisma.editableAsset.upsert({
     *   create: {
     *     // ... data to create a EditableAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EditableAsset we want to update
     *   }
     * })
    **/
    upsert<T extends EditableAssetUpsertArgs>(
      args: SelectSubset<T, EditableAssetUpsertArgs>
    ): Prisma__EditableAssetClient<EditableAssetGetPayload<T>>

    /**
     * Count the number of EditableAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetCountArgs} args - Arguments to filter EditableAssets to count.
     * @example
     * // Count the number of EditableAssets
     * const count = await prisma.editableAsset.count({
     *   where: {
     *     // ... the filter for the EditableAssets we want to count
     *   }
     * })
    **/
    count<T extends EditableAssetCountArgs>(
      args?: Subset<T, EditableAssetCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditableAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EditableAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditableAssetAggregateArgs>(args: Subset<T, EditableAssetAggregateArgs>): PrismaPromise<GetEditableAssetAggregateType<T>>

    /**
     * Group by EditableAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditableAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EditableAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EditableAssetGroupByArgs['orderBy'] }
        : { orderBy?: EditableAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EditableAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditableAssetGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EditableAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EditableAssetClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    video<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EditableAsset base type for findUnique actions
   */
  export type EditableAssetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter, which EditableAsset to fetch.
     */
    where: EditableAssetWhereUniqueInput
  }

  /**
   * EditableAsset findUnique
   */
  export interface EditableAssetFindUniqueArgs extends EditableAssetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EditableAsset findUniqueOrThrow
   */
  export type EditableAssetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter, which EditableAsset to fetch.
     */
    where: EditableAssetWhereUniqueInput
  }


  /**
   * EditableAsset base type for findFirst actions
   */
  export type EditableAssetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter, which EditableAsset to fetch.
     */
    where?: EditableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditableAssets to fetch.
     */
    orderBy?: Enumerable<EditableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditableAssets.
     */
    cursor?: EditableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditableAssets.
     */
    distinct?: Enumerable<EditableAssetScalarFieldEnum>
  }

  /**
   * EditableAsset findFirst
   */
  export interface EditableAssetFindFirstArgs extends EditableAssetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EditableAsset findFirstOrThrow
   */
  export type EditableAssetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter, which EditableAsset to fetch.
     */
    where?: EditableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditableAssets to fetch.
     */
    orderBy?: Enumerable<EditableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditableAssets.
     */
    cursor?: EditableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditableAssets.
     */
    distinct?: Enumerable<EditableAssetScalarFieldEnum>
  }


  /**
   * EditableAsset findMany
   */
  export type EditableAssetFindManyArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter, which EditableAssets to fetch.
     */
    where?: EditableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditableAssets to fetch.
     */
    orderBy?: Enumerable<EditableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EditableAssets.
     */
    cursor?: EditableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditableAssets.
     */
    skip?: number
    distinct?: Enumerable<EditableAssetScalarFieldEnum>
  }


  /**
   * EditableAsset create
   */
  export type EditableAssetCreateArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * The data needed to create a EditableAsset.
     */
    data: XOR<EditableAssetCreateInput, EditableAssetUncheckedCreateInput>
  }


  /**
   * EditableAsset createMany
   */
  export type EditableAssetCreateManyArgs = {
    /**
     * The data used to create many EditableAssets.
     */
    data: Enumerable<EditableAssetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EditableAsset update
   */
  export type EditableAssetUpdateArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * The data needed to update a EditableAsset.
     */
    data: XOR<EditableAssetUpdateInput, EditableAssetUncheckedUpdateInput>
    /**
     * Choose, which EditableAsset to update.
     */
    where: EditableAssetWhereUniqueInput
  }


  /**
   * EditableAsset updateMany
   */
  export type EditableAssetUpdateManyArgs = {
    /**
     * The data used to update EditableAssets.
     */
    data: XOR<EditableAssetUpdateManyMutationInput, EditableAssetUncheckedUpdateManyInput>
    /**
     * Filter which EditableAssets to update
     */
    where?: EditableAssetWhereInput
  }


  /**
   * EditableAsset upsert
   */
  export type EditableAssetUpsertArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * The filter to search for the EditableAsset to update in case it exists.
     */
    where: EditableAssetWhereUniqueInput
    /**
     * In case the EditableAsset found by the `where` argument doesn't exist, create a new EditableAsset with this data.
     */
    create: XOR<EditableAssetCreateInput, EditableAssetUncheckedCreateInput>
    /**
     * In case the EditableAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EditableAssetUpdateInput, EditableAssetUncheckedUpdateInput>
  }


  /**
   * EditableAsset delete
   */
  export type EditableAssetDeleteArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
    /**
     * Filter which EditableAsset to delete.
     */
    where: EditableAssetWhereUniqueInput
  }


  /**
   * EditableAsset deleteMany
   */
  export type EditableAssetDeleteManyArgs = {
    /**
     * Filter which EditableAssets to delete
     */
    where?: EditableAssetWhereInput
  }


  /**
   * EditableAsset without action
   */
  export type EditableAssetArgs = {
    /**
     * Select specific fields to fetch from the EditableAsset
     */
    select?: EditableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EditableAssetInclude | null
  }



  /**
   * Model PlayableAsset
   */


  export type AggregatePlayableAsset = {
    _count: PlayableAssetCountAggregateOutputType | null
    _min: PlayableAssetMinAggregateOutputType | null
    _max: PlayableAssetMaxAggregateOutputType | null
  }

  export type PlayableAssetMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    platform: StoragePlatforms | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayableAssetMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    platform: StoragePlatforms | null
    isSigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayableAssetCountAggregateOutputType = {
    id: number
    videoId: number
    platform: number
    isSigned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayableAssetMinAggregateInputType = {
    id?: true
    videoId?: true
    platform?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayableAssetMaxAggregateInputType = {
    id?: true
    videoId?: true
    platform?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayableAssetCountAggregateInputType = {
    id?: true
    videoId?: true
    platform?: true
    isSigned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayableAssetAggregateArgs = {
    /**
     * Filter which PlayableAsset to aggregate.
     */
    where?: PlayableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayableAssets to fetch.
     */
    orderBy?: Enumerable<PlayableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayableAssets
    **/
    _count?: true | PlayableAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayableAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayableAssetMaxAggregateInputType
  }

  export type GetPlayableAssetAggregateType<T extends PlayableAssetAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayableAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayableAsset[P]>
      : GetScalarType<T[P], AggregatePlayableAsset[P]>
  }




  export type PlayableAssetGroupByArgs = {
    where?: PlayableAssetWhereInput
    orderBy?: Enumerable<PlayableAssetOrderByWithAggregationInput>
    by: PlayableAssetScalarFieldEnum[]
    having?: PlayableAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayableAssetCountAggregateInputType | true
    _min?: PlayableAssetMinAggregateInputType
    _max?: PlayableAssetMaxAggregateInputType
  }


  export type PlayableAssetGroupByOutputType = {
    id: string
    videoId: string
    platform: StoragePlatforms
    isSigned: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayableAssetCountAggregateOutputType | null
    _min: PlayableAssetMinAggregateOutputType | null
    _max: PlayableAssetMaxAggregateOutputType | null
  }

  type GetPlayableAssetGroupByPayload<T extends PlayableAssetGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayableAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayableAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayableAssetGroupByOutputType[P]>
            : GetScalarType<T[P], PlayableAssetGroupByOutputType[P]>
        }
      >
    >


  export type PlayableAssetSelect = {
    id?: boolean
    video?: boolean | VideoArgs
    videoId?: boolean
    platform?: boolean
    isSigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type PlayableAssetInclude = {
    video?: boolean | VideoArgs
  }

  export type PlayableAssetGetPayload<S extends boolean | null | undefined | PlayableAssetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PlayableAsset :
    S extends undefined ? never :
    S extends { include: any } & (PlayableAssetArgs | PlayableAssetFindManyArgs)
    ? PlayableAsset  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'video' ? VideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PlayableAssetArgs | PlayableAssetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'video' ? VideoGetPayload<S['select'][P]> :  P extends keyof PlayableAsset ? PlayableAsset[P] : never
  } 
      : PlayableAsset


  type PlayableAssetCountArgs = 
    Omit<PlayableAssetFindManyArgs, 'select' | 'include'> & {
      select?: PlayableAssetCountAggregateInputType | true
    }

  export interface PlayableAssetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PlayableAsset that matches the filter.
     * @param {PlayableAssetFindUniqueArgs} args - Arguments to find a PlayableAsset
     * @example
     * // Get one PlayableAsset
     * const playableAsset = await prisma.playableAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayableAssetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayableAssetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayableAsset'> extends True ? Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>> : Prisma__PlayableAssetClient<PlayableAssetGetPayload<T> | null, null>

    /**
     * Find one PlayableAsset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlayableAssetFindUniqueOrThrowArgs} args - Arguments to find a PlayableAsset
     * @example
     * // Get one PlayableAsset
     * const playableAsset = await prisma.playableAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlayableAssetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PlayableAssetFindUniqueOrThrowArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Find the first PlayableAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetFindFirstArgs} args - Arguments to find a PlayableAsset
     * @example
     * // Get one PlayableAsset
     * const playableAsset = await prisma.playableAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayableAssetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayableAssetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayableAsset'> extends True ? Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>> : Prisma__PlayableAssetClient<PlayableAssetGetPayload<T> | null, null>

    /**
     * Find the first PlayableAsset that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetFindFirstOrThrowArgs} args - Arguments to find a PlayableAsset
     * @example
     * // Get one PlayableAsset
     * const playableAsset = await prisma.playableAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlayableAssetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlayableAssetFindFirstOrThrowArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Find zero or more PlayableAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayableAssets
     * const playableAssets = await prisma.playableAsset.findMany()
     * 
     * // Get first 10 PlayableAssets
     * const playableAssets = await prisma.playableAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playableAssetWithIdOnly = await prisma.playableAsset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayableAssetFindManyArgs>(
      args?: SelectSubset<T, PlayableAssetFindManyArgs>
    ): PrismaPromise<Array<PlayableAssetGetPayload<T>>>

    /**
     * Create a PlayableAsset.
     * @param {PlayableAssetCreateArgs} args - Arguments to create a PlayableAsset.
     * @example
     * // Create one PlayableAsset
     * const PlayableAsset = await prisma.playableAsset.create({
     *   data: {
     *     // ... data to create a PlayableAsset
     *   }
     * })
     * 
    **/
    create<T extends PlayableAssetCreateArgs>(
      args: SelectSubset<T, PlayableAssetCreateArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Create many PlayableAssets.
     *     @param {PlayableAssetCreateManyArgs} args - Arguments to create many PlayableAssets.
     *     @example
     *     // Create many PlayableAssets
     *     const playableAsset = await prisma.playableAsset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayableAssetCreateManyArgs>(
      args?: SelectSubset<T, PlayableAssetCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayableAsset.
     * @param {PlayableAssetDeleteArgs} args - Arguments to delete one PlayableAsset.
     * @example
     * // Delete one PlayableAsset
     * const PlayableAsset = await prisma.playableAsset.delete({
     *   where: {
     *     // ... filter to delete one PlayableAsset
     *   }
     * })
     * 
    **/
    delete<T extends PlayableAssetDeleteArgs>(
      args: SelectSubset<T, PlayableAssetDeleteArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Update one PlayableAsset.
     * @param {PlayableAssetUpdateArgs} args - Arguments to update one PlayableAsset.
     * @example
     * // Update one PlayableAsset
     * const playableAsset = await prisma.playableAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayableAssetUpdateArgs>(
      args: SelectSubset<T, PlayableAssetUpdateArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Delete zero or more PlayableAssets.
     * @param {PlayableAssetDeleteManyArgs} args - Arguments to filter PlayableAssets to delete.
     * @example
     * // Delete a few PlayableAssets
     * const { count } = await prisma.playableAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayableAssetDeleteManyArgs>(
      args?: SelectSubset<T, PlayableAssetDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayableAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayableAssets
     * const playableAsset = await prisma.playableAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayableAssetUpdateManyArgs>(
      args: SelectSubset<T, PlayableAssetUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayableAsset.
     * @param {PlayableAssetUpsertArgs} args - Arguments to update or create a PlayableAsset.
     * @example
     * // Update or create a PlayableAsset
     * const playableAsset = await prisma.playableAsset.upsert({
     *   create: {
     *     // ... data to create a PlayableAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayableAsset we want to update
     *   }
     * })
    **/
    upsert<T extends PlayableAssetUpsertArgs>(
      args: SelectSubset<T, PlayableAssetUpsertArgs>
    ): Prisma__PlayableAssetClient<PlayableAssetGetPayload<T>>

    /**
     * Count the number of PlayableAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetCountArgs} args - Arguments to filter PlayableAssets to count.
     * @example
     * // Count the number of PlayableAssets
     * const count = await prisma.playableAsset.count({
     *   where: {
     *     // ... the filter for the PlayableAssets we want to count
     *   }
     * })
    **/
    count<T extends PlayableAssetCountArgs>(
      args?: Subset<T, PlayableAssetCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayableAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayableAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayableAssetAggregateArgs>(args: Subset<T, PlayableAssetAggregateArgs>): PrismaPromise<GetPlayableAssetAggregateType<T>>

    /**
     * Group by PlayableAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayableAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayableAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayableAssetGroupByArgs['orderBy'] }
        : { orderBy?: PlayableAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayableAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayableAssetGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayableAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayableAssetClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    video<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PlayableAsset base type for findUnique actions
   */
  export type PlayableAssetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter, which PlayableAsset to fetch.
     */
    where: PlayableAssetWhereUniqueInput
  }

  /**
   * PlayableAsset findUnique
   */
  export interface PlayableAssetFindUniqueArgs extends PlayableAssetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PlayableAsset findUniqueOrThrow
   */
  export type PlayableAssetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter, which PlayableAsset to fetch.
     */
    where: PlayableAssetWhereUniqueInput
  }


  /**
   * PlayableAsset base type for findFirst actions
   */
  export type PlayableAssetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter, which PlayableAsset to fetch.
     */
    where?: PlayableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayableAssets to fetch.
     */
    orderBy?: Enumerable<PlayableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayableAssets.
     */
    cursor?: PlayableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayableAssets.
     */
    distinct?: Enumerable<PlayableAssetScalarFieldEnum>
  }

  /**
   * PlayableAsset findFirst
   */
  export interface PlayableAssetFindFirstArgs extends PlayableAssetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PlayableAsset findFirstOrThrow
   */
  export type PlayableAssetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter, which PlayableAsset to fetch.
     */
    where?: PlayableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayableAssets to fetch.
     */
    orderBy?: Enumerable<PlayableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayableAssets.
     */
    cursor?: PlayableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayableAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayableAssets.
     */
    distinct?: Enumerable<PlayableAssetScalarFieldEnum>
  }


  /**
   * PlayableAsset findMany
   */
  export type PlayableAssetFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter, which PlayableAssets to fetch.
     */
    where?: PlayableAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayableAssets to fetch.
     */
    orderBy?: Enumerable<PlayableAssetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayableAssets.
     */
    cursor?: PlayableAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayableAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayableAssets.
     */
    skip?: number
    distinct?: Enumerable<PlayableAssetScalarFieldEnum>
  }


  /**
   * PlayableAsset create
   */
  export type PlayableAssetCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * The data needed to create a PlayableAsset.
     */
    data: XOR<PlayableAssetCreateInput, PlayableAssetUncheckedCreateInput>
  }


  /**
   * PlayableAsset createMany
   */
  export type PlayableAssetCreateManyArgs = {
    /**
     * The data used to create many PlayableAssets.
     */
    data: Enumerable<PlayableAssetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayableAsset update
   */
  export type PlayableAssetUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * The data needed to update a PlayableAsset.
     */
    data: XOR<PlayableAssetUpdateInput, PlayableAssetUncheckedUpdateInput>
    /**
     * Choose, which PlayableAsset to update.
     */
    where: PlayableAssetWhereUniqueInput
  }


  /**
   * PlayableAsset updateMany
   */
  export type PlayableAssetUpdateManyArgs = {
    /**
     * The data used to update PlayableAssets.
     */
    data: XOR<PlayableAssetUpdateManyMutationInput, PlayableAssetUncheckedUpdateManyInput>
    /**
     * Filter which PlayableAssets to update
     */
    where?: PlayableAssetWhereInput
  }


  /**
   * PlayableAsset upsert
   */
  export type PlayableAssetUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * The filter to search for the PlayableAsset to update in case it exists.
     */
    where: PlayableAssetWhereUniqueInput
    /**
     * In case the PlayableAsset found by the `where` argument doesn't exist, create a new PlayableAsset with this data.
     */
    create: XOR<PlayableAssetCreateInput, PlayableAssetUncheckedCreateInput>
    /**
     * In case the PlayableAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayableAssetUpdateInput, PlayableAssetUncheckedUpdateInput>
  }


  /**
   * PlayableAsset delete
   */
  export type PlayableAssetDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
    /**
     * Filter which PlayableAsset to delete.
     */
    where: PlayableAssetWhereUniqueInput
  }


  /**
   * PlayableAsset deleteMany
   */
  export type PlayableAssetDeleteManyArgs = {
    /**
     * Filter which PlayableAssets to delete
     */
    where?: PlayableAssetWhereInput
  }


  /**
   * PlayableAsset without action
   */
  export type PlayableAssetArgs = {
    /**
     * Select specific fields to fetch from the PlayableAsset
     */
    select?: PlayableAssetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayableAssetInclude | null
  }



  /**
   * Model Transcript
   */


  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptAvgAggregateOutputType = {
    version: number | null
  }

  export type TranscriptSumAggregateOutputType = {
    version: number | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    version: number | null
    interviewId: string | null
    isPending: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    version: number | null
    interviewId: string | null
    isPending: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    version: number
    interviewId: number
    isPending: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TranscriptAvgAggregateInputType = {
    version?: true
  }

  export type TranscriptSumAggregateInputType = {
    version?: true
  }

  export type TranscriptMinAggregateInputType = {
    id?: true
    version?: true
    interviewId?: true
    isPending?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    version?: true
    interviewId?: true
    isPending?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    version?: true
    interviewId?: true
    isPending?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TranscriptAggregateArgs = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: Enumerable<TranscriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs = {
    where?: TranscriptWhereInput
    orderBy?: Enumerable<TranscriptOrderByWithAggregationInput>
    by: TranscriptScalarFieldEnum[]
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _avg?: TranscriptAvgAggregateInputType
    _sum?: TranscriptSumAggregateInputType
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }


  export type TranscriptGroupByOutputType = {
    id: string
    version: number
    interviewId: string | null
    isPending: boolean
    createdAt: Date
    updatedAt: Date
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect = {
    id?: boolean
    version?: boolean
    interview?: boolean | InterviewArgs
    interviewId?: boolean
    highlight?: boolean | HighlightArgs
    suggestedHighlight?: boolean | SuggestedHighlightArgs
    isPending?: boolean
    words?: boolean | Transcript$wordsArgs
    groups?: boolean | Transcript$groupsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | TranscriptCountOutputTypeArgs
  }


  export type TranscriptInclude = {
    interview?: boolean | InterviewArgs
    highlight?: boolean | HighlightArgs
    suggestedHighlight?: boolean | SuggestedHighlightArgs
    words?: boolean | Transcript$wordsArgs
    groups?: boolean | Transcript$groupsArgs
    _count?: boolean | TranscriptCountOutputTypeArgs
  }

  export type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Transcript :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptArgs | TranscriptFindManyArgs)
    ? Transcript  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> | null :
        P extends 'highlight' ? HighlightGetPayload<S['include'][P]> | null :
        P extends 'suggestedHighlight' ? SuggestedHighlightGetPayload<S['include'][P]> | null :
        P extends 'words' ? Array < TranscriptWordGetPayload<S['include'][P]>>  :
        P extends 'groups' ? Array < TranscriptGroupGetPayload<S['include'][P]>>  :
        P extends '_count' ? TranscriptCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TranscriptArgs | TranscriptFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> | null :
        P extends 'highlight' ? HighlightGetPayload<S['select'][P]> | null :
        P extends 'suggestedHighlight' ? SuggestedHighlightGetPayload<S['select'][P]> | null :
        P extends 'words' ? Array < TranscriptWordGetPayload<S['select'][P]>>  :
        P extends 'groups' ? Array < TranscriptGroupGetPayload<S['select'][P]>>  :
        P extends '_count' ? TranscriptCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Transcript ? Transcript[P] : never
  } 
      : Transcript


  type TranscriptCountArgs = 
    Omit<TranscriptFindManyArgs, 'select' | 'include'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TranscriptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TranscriptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transcript'> extends True ? Prisma__TranscriptClient<TranscriptGetPayload<T>> : Prisma__TranscriptClient<TranscriptGetPayload<T> | null, null>

    /**
     * Find one Transcript that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TranscriptFindUniqueOrThrowArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TranscriptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TranscriptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transcript'> extends True ? Prisma__TranscriptClient<TranscriptGetPayload<T>> : Prisma__TranscriptClient<TranscriptGetPayload<T> | null, null>

    /**
     * Find the first Transcript that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TranscriptFindManyArgs>(
      args?: SelectSubset<T, TranscriptFindManyArgs>
    ): PrismaPromise<Array<TranscriptGetPayload<T>>>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
    **/
    create<T extends TranscriptCreateArgs>(
      args: SelectSubset<T, TranscriptCreateArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Create many Transcripts.
     *     @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     *     @example
     *     // Create many Transcripts
     *     const transcript = await prisma.transcript.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TranscriptCreateManyArgs>(
      args?: SelectSubset<T, TranscriptCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
    **/
    delete<T extends TranscriptDeleteArgs>(
      args: SelectSubset<T, TranscriptDeleteArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TranscriptUpdateArgs>(
      args: SelectSubset<T, TranscriptUpdateArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TranscriptDeleteManyArgs>(
      args?: SelectSubset<T, TranscriptDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TranscriptUpdateManyArgs>(
      args: SelectSubset<T, TranscriptUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
    **/
    upsert<T extends TranscriptUpsertArgs>(
      args: SelectSubset<T, TranscriptUpsertArgs>
    ): Prisma__TranscriptClient<TranscriptGetPayload<T>>

    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TranscriptClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    highlight<T extends HighlightArgs= {}>(args?: Subset<T, HighlightArgs>): Prisma__HighlightClient<HighlightGetPayload<T> | Null>;

    suggestedHighlight<T extends SuggestedHighlightArgs= {}>(args?: Subset<T, SuggestedHighlightArgs>): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T> | Null>;

    words<T extends Transcript$wordsArgs= {}>(args?: Subset<T, Transcript$wordsArgs>): PrismaPromise<Array<TranscriptWordGetPayload<T>>| Null>;

    groups<T extends Transcript$groupsArgs= {}>(args?: Subset<T, Transcript$groupsArgs>): PrismaPromise<Array<TranscriptGroupGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Transcript base type for findUnique actions
   */
  export type TranscriptFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUnique
   */
  export interface TranscriptFindUniqueArgs extends TranscriptFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }


  /**
   * Transcript base type for findFirst actions
   */
  export type TranscriptFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: Enumerable<TranscriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: Enumerable<TranscriptScalarFieldEnum>
  }

  /**
   * Transcript findFirst
   */
  export interface TranscriptFindFirstArgs extends TranscriptFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: Enumerable<TranscriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: Enumerable<TranscriptScalarFieldEnum>
  }


  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: Enumerable<TranscriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: Enumerable<TranscriptScalarFieldEnum>
  }


  /**
   * Transcript create
   */
  export type TranscriptCreateArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }


  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs = {
    /**
     * The data used to create many Transcripts.
     */
    data: Enumerable<TranscriptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }


  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
  }


  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }


  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }


  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
  }


  /**
   * Transcript.words
   */
  export type Transcript$wordsArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    where?: TranscriptWordWhereInput
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    cursor?: TranscriptWordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TranscriptWordScalarFieldEnum>
  }


  /**
   * Transcript.groups
   */
  export type Transcript$groupsArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    where?: TranscriptGroupWhereInput
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    cursor?: TranscriptGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TranscriptGroupScalarFieldEnum>
  }


  /**
   * Transcript without action
   */
  export type TranscriptArgs = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptInclude | null
  }



  /**
   * Model TranscriptGroup
   */


  export type AggregateTranscriptGroup = {
    _count: TranscriptGroupCountAggregateOutputType | null
    _avg: TranscriptGroupAvgAggregateOutputType | null
    _sum: TranscriptGroupSumAggregateOutputType | null
    _min: TranscriptGroupMinAggregateOutputType | null
    _max: TranscriptGroupMaxAggregateOutputType | null
  }

  export type TranscriptGroupAvgAggregateOutputType = {
    groupNumber: number | null
  }

  export type TranscriptGroupSumAggregateOutputType = {
    groupNumber: number | null
  }

  export type TranscriptGroupMinAggregateOutputType = {
    text: string | null
    transcriptId: string | null
    groupNumber: number | null
    speakerId: string | null
  }

  export type TranscriptGroupMaxAggregateOutputType = {
    text: string | null
    transcriptId: string | null
    groupNumber: number | null
    speakerId: string | null
  }

  export type TranscriptGroupCountAggregateOutputType = {
    text: number
    transcriptId: number
    groupNumber: number
    speakerId: number
    _all: number
  }


  export type TranscriptGroupAvgAggregateInputType = {
    groupNumber?: true
  }

  export type TranscriptGroupSumAggregateInputType = {
    groupNumber?: true
  }

  export type TranscriptGroupMinAggregateInputType = {
    text?: true
    transcriptId?: true
    groupNumber?: true
    speakerId?: true
  }

  export type TranscriptGroupMaxAggregateInputType = {
    text?: true
    transcriptId?: true
    groupNumber?: true
    speakerId?: true
  }

  export type TranscriptGroupCountAggregateInputType = {
    text?: true
    transcriptId?: true
    groupNumber?: true
    speakerId?: true
    _all?: true
  }

  export type TranscriptGroupAggregateArgs = {
    /**
     * Filter which TranscriptGroup to aggregate.
     */
    where?: TranscriptGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptGroups to fetch.
     */
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptGroups
    **/
    _count?: true | TranscriptGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptGroupMaxAggregateInputType
  }

  export type GetTranscriptGroupAggregateType<T extends TranscriptGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptGroup[P]>
      : GetScalarType<T[P], AggregateTranscriptGroup[P]>
  }




  export type TranscriptGroupGroupByArgs = {
    where?: TranscriptGroupWhereInput
    orderBy?: Enumerable<TranscriptGroupOrderByWithAggregationInput>
    by: TranscriptGroupScalarFieldEnum[]
    having?: TranscriptGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptGroupCountAggregateInputType | true
    _avg?: TranscriptGroupAvgAggregateInputType
    _sum?: TranscriptGroupSumAggregateInputType
    _min?: TranscriptGroupMinAggregateInputType
    _max?: TranscriptGroupMaxAggregateInputType
  }


  export type TranscriptGroupGroupByOutputType = {
    text: string
    transcriptId: string
    groupNumber: number
    speakerId: string
    _count: TranscriptGroupCountAggregateOutputType | null
    _avg: TranscriptGroupAvgAggregateOutputType | null
    _sum: TranscriptGroupSumAggregateOutputType | null
    _min: TranscriptGroupMinAggregateOutputType | null
    _max: TranscriptGroupMaxAggregateOutputType | null
  }

  type GetTranscriptGroupGroupByPayload<T extends TranscriptGroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranscriptGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptGroupSelect = {
    transcript?: boolean | TranscriptArgs
    words?: boolean | TranscriptGroup$wordsArgs
    text?: boolean
    transcriptId?: boolean
    groupNumber?: boolean
    speakerId?: boolean
    speaker?: boolean | ParticipantArgs
    _count?: boolean | TranscriptGroupCountOutputTypeArgs
  }


  export type TranscriptGroupInclude = {
    transcript?: boolean | TranscriptArgs
    words?: boolean | TranscriptGroup$wordsArgs
    speaker?: boolean | ParticipantArgs
    _count?: boolean | TranscriptGroupCountOutputTypeArgs
  }

  export type TranscriptGroupGetPayload<S extends boolean | null | undefined | TranscriptGroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TranscriptGroup :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptGroupArgs | TranscriptGroupFindManyArgs)
    ? TranscriptGroup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transcript' ? TranscriptGetPayload<S['include'][P]> :
        P extends 'words' ? Array < TranscriptWordGetPayload<S['include'][P]>>  :
        P extends 'speaker' ? ParticipantGetPayload<S['include'][P]> :
        P extends '_count' ? TranscriptGroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TranscriptGroupArgs | TranscriptGroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transcript' ? TranscriptGetPayload<S['select'][P]> :
        P extends 'words' ? Array < TranscriptWordGetPayload<S['select'][P]>>  :
        P extends 'speaker' ? ParticipantGetPayload<S['select'][P]> :
        P extends '_count' ? TranscriptGroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TranscriptGroup ? TranscriptGroup[P] : never
  } 
      : TranscriptGroup


  type TranscriptGroupCountArgs = 
    Omit<TranscriptGroupFindManyArgs, 'select' | 'include'> & {
      select?: TranscriptGroupCountAggregateInputType | true
    }

  export interface TranscriptGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TranscriptGroup that matches the filter.
     * @param {TranscriptGroupFindUniqueArgs} args - Arguments to find a TranscriptGroup
     * @example
     * // Get one TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TranscriptGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TranscriptGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TranscriptGroup'> extends True ? Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>> : Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T> | null, null>

    /**
     * Find one TranscriptGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TranscriptGroupFindUniqueOrThrowArgs} args - Arguments to find a TranscriptGroup
     * @example
     * // Get one TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TranscriptGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TranscriptGroupFindUniqueOrThrowArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Find the first TranscriptGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupFindFirstArgs} args - Arguments to find a TranscriptGroup
     * @example
     * // Get one TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TranscriptGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TranscriptGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TranscriptGroup'> extends True ? Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>> : Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T> | null, null>

    /**
     * Find the first TranscriptGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupFindFirstOrThrowArgs} args - Arguments to find a TranscriptGroup
     * @example
     * // Get one TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TranscriptGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TranscriptGroupFindFirstOrThrowArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Find zero or more TranscriptGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptGroups
     * const transcriptGroups = await prisma.transcriptGroup.findMany()
     * 
     * // Get first 10 TranscriptGroups
     * const transcriptGroups = await prisma.transcriptGroup.findMany({ take: 10 })
     * 
     * // Only select the `text`
     * const transcriptGroupWithTextOnly = await prisma.transcriptGroup.findMany({ select: { text: true } })
     * 
    **/
    findMany<T extends TranscriptGroupFindManyArgs>(
      args?: SelectSubset<T, TranscriptGroupFindManyArgs>
    ): PrismaPromise<Array<TranscriptGroupGetPayload<T>>>

    /**
     * Create a TranscriptGroup.
     * @param {TranscriptGroupCreateArgs} args - Arguments to create a TranscriptGroup.
     * @example
     * // Create one TranscriptGroup
     * const TranscriptGroup = await prisma.transcriptGroup.create({
     *   data: {
     *     // ... data to create a TranscriptGroup
     *   }
     * })
     * 
    **/
    create<T extends TranscriptGroupCreateArgs>(
      args: SelectSubset<T, TranscriptGroupCreateArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Create many TranscriptGroups.
     *     @param {TranscriptGroupCreateManyArgs} args - Arguments to create many TranscriptGroups.
     *     @example
     *     // Create many TranscriptGroups
     *     const transcriptGroup = await prisma.transcriptGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TranscriptGroupCreateManyArgs>(
      args?: SelectSubset<T, TranscriptGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TranscriptGroup.
     * @param {TranscriptGroupDeleteArgs} args - Arguments to delete one TranscriptGroup.
     * @example
     * // Delete one TranscriptGroup
     * const TranscriptGroup = await prisma.transcriptGroup.delete({
     *   where: {
     *     // ... filter to delete one TranscriptGroup
     *   }
     * })
     * 
    **/
    delete<T extends TranscriptGroupDeleteArgs>(
      args: SelectSubset<T, TranscriptGroupDeleteArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Update one TranscriptGroup.
     * @param {TranscriptGroupUpdateArgs} args - Arguments to update one TranscriptGroup.
     * @example
     * // Update one TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TranscriptGroupUpdateArgs>(
      args: SelectSubset<T, TranscriptGroupUpdateArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Delete zero or more TranscriptGroups.
     * @param {TranscriptGroupDeleteManyArgs} args - Arguments to filter TranscriptGroups to delete.
     * @example
     * // Delete a few TranscriptGroups
     * const { count } = await prisma.transcriptGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TranscriptGroupDeleteManyArgs>(
      args?: SelectSubset<T, TranscriptGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptGroups
     * const transcriptGroup = await prisma.transcriptGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TranscriptGroupUpdateManyArgs>(
      args: SelectSubset<T, TranscriptGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TranscriptGroup.
     * @param {TranscriptGroupUpsertArgs} args - Arguments to update or create a TranscriptGroup.
     * @example
     * // Update or create a TranscriptGroup
     * const transcriptGroup = await prisma.transcriptGroup.upsert({
     *   create: {
     *     // ... data to create a TranscriptGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptGroup we want to update
     *   }
     * })
    **/
    upsert<T extends TranscriptGroupUpsertArgs>(
      args: SelectSubset<T, TranscriptGroupUpsertArgs>
    ): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T>>

    /**
     * Count the number of TranscriptGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupCountArgs} args - Arguments to filter TranscriptGroups to count.
     * @example
     * // Count the number of TranscriptGroups
     * const count = await prisma.transcriptGroup.count({
     *   where: {
     *     // ... the filter for the TranscriptGroups we want to count
     *   }
     * })
    **/
    count<T extends TranscriptGroupCountArgs>(
      args?: Subset<T, TranscriptGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptGroupAggregateArgs>(args: Subset<T, TranscriptGroupAggregateArgs>): PrismaPromise<GetTranscriptGroupAggregateType<T>>

    /**
     * Group by TranscriptGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TranscriptGroupClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transcript<T extends TranscriptArgs= {}>(args?: Subset<T, TranscriptArgs>): Prisma__TranscriptClient<TranscriptGetPayload<T> | Null>;

    words<T extends TranscriptGroup$wordsArgs= {}>(args?: Subset<T, TranscriptGroup$wordsArgs>): PrismaPromise<Array<TranscriptWordGetPayload<T>>| Null>;

    speaker<T extends ParticipantArgs= {}>(args?: Subset<T, ParticipantArgs>): Prisma__ParticipantClient<ParticipantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TranscriptGroup base type for findUnique actions
   */
  export type TranscriptGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter, which TranscriptGroup to fetch.
     */
    where: TranscriptGroupWhereUniqueInput
  }

  /**
   * TranscriptGroup findUnique
   */
  export interface TranscriptGroupFindUniqueArgs extends TranscriptGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TranscriptGroup findUniqueOrThrow
   */
  export type TranscriptGroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter, which TranscriptGroup to fetch.
     */
    where: TranscriptGroupWhereUniqueInput
  }


  /**
   * TranscriptGroup base type for findFirst actions
   */
  export type TranscriptGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter, which TranscriptGroup to fetch.
     */
    where?: TranscriptGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptGroups to fetch.
     */
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptGroups.
     */
    cursor?: TranscriptGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptGroups.
     */
    distinct?: Enumerable<TranscriptGroupScalarFieldEnum>
  }

  /**
   * TranscriptGroup findFirst
   */
  export interface TranscriptGroupFindFirstArgs extends TranscriptGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TranscriptGroup findFirstOrThrow
   */
  export type TranscriptGroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter, which TranscriptGroup to fetch.
     */
    where?: TranscriptGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptGroups to fetch.
     */
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptGroups.
     */
    cursor?: TranscriptGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptGroups.
     */
    distinct?: Enumerable<TranscriptGroupScalarFieldEnum>
  }


  /**
   * TranscriptGroup findMany
   */
  export type TranscriptGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter, which TranscriptGroups to fetch.
     */
    where?: TranscriptGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptGroups to fetch.
     */
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptGroups.
     */
    cursor?: TranscriptGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptGroups.
     */
    skip?: number
    distinct?: Enumerable<TranscriptGroupScalarFieldEnum>
  }


  /**
   * TranscriptGroup create
   */
  export type TranscriptGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * The data needed to create a TranscriptGroup.
     */
    data: XOR<TranscriptGroupCreateInput, TranscriptGroupUncheckedCreateInput>
  }


  /**
   * TranscriptGroup createMany
   */
  export type TranscriptGroupCreateManyArgs = {
    /**
     * The data used to create many TranscriptGroups.
     */
    data: Enumerable<TranscriptGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TranscriptGroup update
   */
  export type TranscriptGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * The data needed to update a TranscriptGroup.
     */
    data: XOR<TranscriptGroupUpdateInput, TranscriptGroupUncheckedUpdateInput>
    /**
     * Choose, which TranscriptGroup to update.
     */
    where: TranscriptGroupWhereUniqueInput
  }


  /**
   * TranscriptGroup updateMany
   */
  export type TranscriptGroupUpdateManyArgs = {
    /**
     * The data used to update TranscriptGroups.
     */
    data: XOR<TranscriptGroupUpdateManyMutationInput, TranscriptGroupUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptGroups to update
     */
    where?: TranscriptGroupWhereInput
  }


  /**
   * TranscriptGroup upsert
   */
  export type TranscriptGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * The filter to search for the TranscriptGroup to update in case it exists.
     */
    where: TranscriptGroupWhereUniqueInput
    /**
     * In case the TranscriptGroup found by the `where` argument doesn't exist, create a new TranscriptGroup with this data.
     */
    create: XOR<TranscriptGroupCreateInput, TranscriptGroupUncheckedCreateInput>
    /**
     * In case the TranscriptGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptGroupUpdateInput, TranscriptGroupUncheckedUpdateInput>
  }


  /**
   * TranscriptGroup delete
   */
  export type TranscriptGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    /**
     * Filter which TranscriptGroup to delete.
     */
    where: TranscriptGroupWhereUniqueInput
  }


  /**
   * TranscriptGroup deleteMany
   */
  export type TranscriptGroupDeleteManyArgs = {
    /**
     * Filter which TranscriptGroups to delete
     */
    where?: TranscriptGroupWhereInput
  }


  /**
   * TranscriptGroup.words
   */
  export type TranscriptGroup$wordsArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    where?: TranscriptWordWhereInput
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    cursor?: TranscriptWordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TranscriptWordScalarFieldEnum>
  }


  /**
   * TranscriptGroup without action
   */
  export type TranscriptGroupArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
  }



  /**
   * Model TranscriptWord
   */


  export type AggregateTranscriptWord = {
    _count: TranscriptWordCountAggregateOutputType | null
    _avg: TranscriptWordAvgAggregateOutputType | null
    _sum: TranscriptWordSumAggregateOutputType | null
    _min: TranscriptWordMinAggregateOutputType | null
    _max: TranscriptWordMaxAggregateOutputType | null
  }

  export type TranscriptWordAvgAggregateOutputType = {
    groupNumber: number | null
    wordNumber: number | null
    start: number | null
    end: number | null
  }

  export type TranscriptWordSumAggregateOutputType = {
    groupNumber: number | null
    wordNumber: number | null
    start: number | null
    end: number | null
  }

  export type TranscriptWordMinAggregateOutputType = {
    transcriptId: string | null
    groupNumber: number | null
    wordNumber: number | null
    start: number | null
    end: number | null
    text: string | null
  }

  export type TranscriptWordMaxAggregateOutputType = {
    transcriptId: string | null
    groupNumber: number | null
    wordNumber: number | null
    start: number | null
    end: number | null
    text: string | null
  }

  export type TranscriptWordCountAggregateOutputType = {
    transcriptId: number
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: number
    _all: number
  }


  export type TranscriptWordAvgAggregateInputType = {
    groupNumber?: true
    wordNumber?: true
    start?: true
    end?: true
  }

  export type TranscriptWordSumAggregateInputType = {
    groupNumber?: true
    wordNumber?: true
    start?: true
    end?: true
  }

  export type TranscriptWordMinAggregateInputType = {
    transcriptId?: true
    groupNumber?: true
    wordNumber?: true
    start?: true
    end?: true
    text?: true
  }

  export type TranscriptWordMaxAggregateInputType = {
    transcriptId?: true
    groupNumber?: true
    wordNumber?: true
    start?: true
    end?: true
    text?: true
  }

  export type TranscriptWordCountAggregateInputType = {
    transcriptId?: true
    groupNumber?: true
    wordNumber?: true
    start?: true
    end?: true
    text?: true
    _all?: true
  }

  export type TranscriptWordAggregateArgs = {
    /**
     * Filter which TranscriptWord to aggregate.
     */
    where?: TranscriptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptWords to fetch.
     */
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptWords
    **/
    _count?: true | TranscriptWordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptWordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptWordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptWordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptWordMaxAggregateInputType
  }

  export type GetTranscriptWordAggregateType<T extends TranscriptWordAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptWord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptWord[P]>
      : GetScalarType<T[P], AggregateTranscriptWord[P]>
  }




  export type TranscriptWordGroupByArgs = {
    where?: TranscriptWordWhereInput
    orderBy?: Enumerable<TranscriptWordOrderByWithAggregationInput>
    by: TranscriptWordScalarFieldEnum[]
    having?: TranscriptWordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptWordCountAggregateInputType | true
    _avg?: TranscriptWordAvgAggregateInputType
    _sum?: TranscriptWordSumAggregateInputType
    _min?: TranscriptWordMinAggregateInputType
    _max?: TranscriptWordMaxAggregateInputType
  }


  export type TranscriptWordGroupByOutputType = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
    _count: TranscriptWordCountAggregateOutputType | null
    _avg: TranscriptWordAvgAggregateOutputType | null
    _sum: TranscriptWordSumAggregateOutputType | null
    _min: TranscriptWordMinAggregateOutputType | null
    _max: TranscriptWordMaxAggregateOutputType | null
  }

  type GetTranscriptWordGroupByPayload<T extends TranscriptWordGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranscriptWordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptWordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptWordGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptWordGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptWordSelect = {
    transcript?: boolean | TranscriptArgs
    group?: boolean | TranscriptGroupArgs
    transcriptId?: boolean
    groupNumber?: boolean
    wordNumber?: boolean
    start?: boolean
    end?: boolean
    text?: boolean
    startWordRanges?: boolean | TranscriptWord$startWordRangesArgs
    endWordRanges?: boolean | TranscriptWord$endWordRangesArgs
    _count?: boolean | TranscriptWordCountOutputTypeArgs
  }


  export type TranscriptWordInclude = {
    transcript?: boolean | TranscriptArgs
    group?: boolean | TranscriptGroupArgs
    startWordRanges?: boolean | TranscriptWord$startWordRangesArgs
    endWordRanges?: boolean | TranscriptWord$endWordRangesArgs
    _count?: boolean | TranscriptWordCountOutputTypeArgs
  }

  export type TranscriptWordGetPayload<S extends boolean | null | undefined | TranscriptWordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TranscriptWord :
    S extends undefined ? never :
    S extends { include: any } & (TranscriptWordArgs | TranscriptWordFindManyArgs)
    ? TranscriptWord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transcript' ? TranscriptGetPayload<S['include'][P]> :
        P extends 'group' ? TranscriptGroupGetPayload<S['include'][P]> :
        P extends 'startWordRanges' ? Array < WordRangeGetPayload<S['include'][P]>>  :
        P extends 'endWordRanges' ? Array < WordRangeGetPayload<S['include'][P]>>  :
        P extends '_count' ? TranscriptWordCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TranscriptWordArgs | TranscriptWordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transcript' ? TranscriptGetPayload<S['select'][P]> :
        P extends 'group' ? TranscriptGroupGetPayload<S['select'][P]> :
        P extends 'startWordRanges' ? Array < WordRangeGetPayload<S['select'][P]>>  :
        P extends 'endWordRanges' ? Array < WordRangeGetPayload<S['select'][P]>>  :
        P extends '_count' ? TranscriptWordCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TranscriptWord ? TranscriptWord[P] : never
  } 
      : TranscriptWord


  type TranscriptWordCountArgs = 
    Omit<TranscriptWordFindManyArgs, 'select' | 'include'> & {
      select?: TranscriptWordCountAggregateInputType | true
    }

  export interface TranscriptWordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TranscriptWord that matches the filter.
     * @param {TranscriptWordFindUniqueArgs} args - Arguments to find a TranscriptWord
     * @example
     * // Get one TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TranscriptWordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TranscriptWordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TranscriptWord'> extends True ? Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>> : Prisma__TranscriptWordClient<TranscriptWordGetPayload<T> | null, null>

    /**
     * Find one TranscriptWord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TranscriptWordFindUniqueOrThrowArgs} args - Arguments to find a TranscriptWord
     * @example
     * // Get one TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TranscriptWordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TranscriptWordFindUniqueOrThrowArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Find the first TranscriptWord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordFindFirstArgs} args - Arguments to find a TranscriptWord
     * @example
     * // Get one TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TranscriptWordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TranscriptWordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TranscriptWord'> extends True ? Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>> : Prisma__TranscriptWordClient<TranscriptWordGetPayload<T> | null, null>

    /**
     * Find the first TranscriptWord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordFindFirstOrThrowArgs} args - Arguments to find a TranscriptWord
     * @example
     * // Get one TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TranscriptWordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TranscriptWordFindFirstOrThrowArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Find zero or more TranscriptWords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptWords
     * const transcriptWords = await prisma.transcriptWord.findMany()
     * 
     * // Get first 10 TranscriptWords
     * const transcriptWords = await prisma.transcriptWord.findMany({ take: 10 })
     * 
     * // Only select the `transcriptId`
     * const transcriptWordWithTranscriptIdOnly = await prisma.transcriptWord.findMany({ select: { transcriptId: true } })
     * 
    **/
    findMany<T extends TranscriptWordFindManyArgs>(
      args?: SelectSubset<T, TranscriptWordFindManyArgs>
    ): PrismaPromise<Array<TranscriptWordGetPayload<T>>>

    /**
     * Create a TranscriptWord.
     * @param {TranscriptWordCreateArgs} args - Arguments to create a TranscriptWord.
     * @example
     * // Create one TranscriptWord
     * const TranscriptWord = await prisma.transcriptWord.create({
     *   data: {
     *     // ... data to create a TranscriptWord
     *   }
     * })
     * 
    **/
    create<T extends TranscriptWordCreateArgs>(
      args: SelectSubset<T, TranscriptWordCreateArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Create many TranscriptWords.
     *     @param {TranscriptWordCreateManyArgs} args - Arguments to create many TranscriptWords.
     *     @example
     *     // Create many TranscriptWords
     *     const transcriptWord = await prisma.transcriptWord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TranscriptWordCreateManyArgs>(
      args?: SelectSubset<T, TranscriptWordCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TranscriptWord.
     * @param {TranscriptWordDeleteArgs} args - Arguments to delete one TranscriptWord.
     * @example
     * // Delete one TranscriptWord
     * const TranscriptWord = await prisma.transcriptWord.delete({
     *   where: {
     *     // ... filter to delete one TranscriptWord
     *   }
     * })
     * 
    **/
    delete<T extends TranscriptWordDeleteArgs>(
      args: SelectSubset<T, TranscriptWordDeleteArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Update one TranscriptWord.
     * @param {TranscriptWordUpdateArgs} args - Arguments to update one TranscriptWord.
     * @example
     * // Update one TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TranscriptWordUpdateArgs>(
      args: SelectSubset<T, TranscriptWordUpdateArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Delete zero or more TranscriptWords.
     * @param {TranscriptWordDeleteManyArgs} args - Arguments to filter TranscriptWords to delete.
     * @example
     * // Delete a few TranscriptWords
     * const { count } = await prisma.transcriptWord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TranscriptWordDeleteManyArgs>(
      args?: SelectSubset<T, TranscriptWordDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptWords
     * const transcriptWord = await prisma.transcriptWord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TranscriptWordUpdateManyArgs>(
      args: SelectSubset<T, TranscriptWordUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TranscriptWord.
     * @param {TranscriptWordUpsertArgs} args - Arguments to update or create a TranscriptWord.
     * @example
     * // Update or create a TranscriptWord
     * const transcriptWord = await prisma.transcriptWord.upsert({
     *   create: {
     *     // ... data to create a TranscriptWord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptWord we want to update
     *   }
     * })
    **/
    upsert<T extends TranscriptWordUpsertArgs>(
      args: SelectSubset<T, TranscriptWordUpsertArgs>
    ): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T>>

    /**
     * Count the number of TranscriptWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordCountArgs} args - Arguments to filter TranscriptWords to count.
     * @example
     * // Count the number of TranscriptWords
     * const count = await prisma.transcriptWord.count({
     *   where: {
     *     // ... the filter for the TranscriptWords we want to count
     *   }
     * })
    **/
    count<T extends TranscriptWordCountArgs>(
      args?: Subset<T, TranscriptWordCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptWordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptWordAggregateArgs>(args: Subset<T, TranscriptWordAggregateArgs>): PrismaPromise<GetTranscriptWordAggregateType<T>>

    /**
     * Group by TranscriptWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptWordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptWordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptWordGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptWordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptWordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptWordGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptWord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TranscriptWordClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transcript<T extends TranscriptArgs= {}>(args?: Subset<T, TranscriptArgs>): Prisma__TranscriptClient<TranscriptGetPayload<T> | Null>;

    group<T extends TranscriptGroupArgs= {}>(args?: Subset<T, TranscriptGroupArgs>): Prisma__TranscriptGroupClient<TranscriptGroupGetPayload<T> | Null>;

    startWordRanges<T extends TranscriptWord$startWordRangesArgs= {}>(args?: Subset<T, TranscriptWord$startWordRangesArgs>): PrismaPromise<Array<WordRangeGetPayload<T>>| Null>;

    endWordRanges<T extends TranscriptWord$endWordRangesArgs= {}>(args?: Subset<T, TranscriptWord$endWordRangesArgs>): PrismaPromise<Array<WordRangeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TranscriptWord base type for findUnique actions
   */
  export type TranscriptWordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter, which TranscriptWord to fetch.
     */
    where: TranscriptWordWhereUniqueInput
  }

  /**
   * TranscriptWord findUnique
   */
  export interface TranscriptWordFindUniqueArgs extends TranscriptWordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TranscriptWord findUniqueOrThrow
   */
  export type TranscriptWordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter, which TranscriptWord to fetch.
     */
    where: TranscriptWordWhereUniqueInput
  }


  /**
   * TranscriptWord base type for findFirst actions
   */
  export type TranscriptWordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter, which TranscriptWord to fetch.
     */
    where?: TranscriptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptWords to fetch.
     */
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptWords.
     */
    cursor?: TranscriptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptWords.
     */
    distinct?: Enumerable<TranscriptWordScalarFieldEnum>
  }

  /**
   * TranscriptWord findFirst
   */
  export interface TranscriptWordFindFirstArgs extends TranscriptWordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TranscriptWord findFirstOrThrow
   */
  export type TranscriptWordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter, which TranscriptWord to fetch.
     */
    where?: TranscriptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptWords to fetch.
     */
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptWords.
     */
    cursor?: TranscriptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptWords.
     */
    distinct?: Enumerable<TranscriptWordScalarFieldEnum>
  }


  /**
   * TranscriptWord findMany
   */
  export type TranscriptWordFindManyArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter, which TranscriptWords to fetch.
     */
    where?: TranscriptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptWords to fetch.
     */
    orderBy?: Enumerable<TranscriptWordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptWords.
     */
    cursor?: TranscriptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptWords.
     */
    skip?: number
    distinct?: Enumerable<TranscriptWordScalarFieldEnum>
  }


  /**
   * TranscriptWord create
   */
  export type TranscriptWordCreateArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * The data needed to create a TranscriptWord.
     */
    data: XOR<TranscriptWordCreateInput, TranscriptWordUncheckedCreateInput>
  }


  /**
   * TranscriptWord createMany
   */
  export type TranscriptWordCreateManyArgs = {
    /**
     * The data used to create many TranscriptWords.
     */
    data: Enumerable<TranscriptWordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TranscriptWord update
   */
  export type TranscriptWordUpdateArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * The data needed to update a TranscriptWord.
     */
    data: XOR<TranscriptWordUpdateInput, TranscriptWordUncheckedUpdateInput>
    /**
     * Choose, which TranscriptWord to update.
     */
    where: TranscriptWordWhereUniqueInput
  }


  /**
   * TranscriptWord updateMany
   */
  export type TranscriptWordUpdateManyArgs = {
    /**
     * The data used to update TranscriptWords.
     */
    data: XOR<TranscriptWordUpdateManyMutationInput, TranscriptWordUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptWords to update
     */
    where?: TranscriptWordWhereInput
  }


  /**
   * TranscriptWord upsert
   */
  export type TranscriptWordUpsertArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * The filter to search for the TranscriptWord to update in case it exists.
     */
    where: TranscriptWordWhereUniqueInput
    /**
     * In case the TranscriptWord found by the `where` argument doesn't exist, create a new TranscriptWord with this data.
     */
    create: XOR<TranscriptWordCreateInput, TranscriptWordUncheckedCreateInput>
    /**
     * In case the TranscriptWord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptWordUpdateInput, TranscriptWordUncheckedUpdateInput>
  }


  /**
   * TranscriptWord delete
   */
  export type TranscriptWordDeleteArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
    /**
     * Filter which TranscriptWord to delete.
     */
    where: TranscriptWordWhereUniqueInput
  }


  /**
   * TranscriptWord deleteMany
   */
  export type TranscriptWordDeleteManyArgs = {
    /**
     * Filter which TranscriptWords to delete
     */
    where?: TranscriptWordWhereInput
  }


  /**
   * TranscriptWord.startWordRanges
   */
  export type TranscriptWord$startWordRangesArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    where?: WordRangeWhereInput
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    cursor?: WordRangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WordRangeScalarFieldEnum>
  }


  /**
   * TranscriptWord.endWordRanges
   */
  export type TranscriptWord$endWordRangesArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    where?: WordRangeWhereInput
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    cursor?: WordRangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WordRangeScalarFieldEnum>
  }


  /**
   * TranscriptWord without action
   */
  export type TranscriptWordArgs = {
    /**
     * Select specific fields to fetch from the TranscriptWord
     */
    select?: TranscriptWordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptWordInclude | null
  }



  /**
   * Model WordRange
   */


  export type AggregateWordRange = {
    _count: WordRangeCountAggregateOutputType | null
    _avg: WordRangeAvgAggregateOutputType | null
    _sum: WordRangeSumAggregateOutputType | null
    _min: WordRangeMinAggregateOutputType | null
    _max: WordRangeMaxAggregateOutputType | null
  }

  export type WordRangeAvgAggregateOutputType = {
    startWordNumber: number | null
    startGroupNumber: number | null
    endWordNumber: number | null
    endGroupNumber: number | null
  }

  export type WordRangeSumAggregateOutputType = {
    startWordNumber: number | null
    startGroupNumber: number | null
    endWordNumber: number | null
    endGroupNumber: number | null
  }

  export type WordRangeMinAggregateOutputType = {
    id: string | null
    transcriptId: string | null
    startWordNumber: number | null
    startGroupNumber: number | null
    endWordNumber: number | null
    endGroupNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WordRangeMaxAggregateOutputType = {
    id: string | null
    transcriptId: string | null
    startWordNumber: number | null
    startGroupNumber: number | null
    endWordNumber: number | null
    endGroupNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WordRangeCountAggregateOutputType = {
    id: number
    transcriptId: number
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WordRangeAvgAggregateInputType = {
    startWordNumber?: true
    startGroupNumber?: true
    endWordNumber?: true
    endGroupNumber?: true
  }

  export type WordRangeSumAggregateInputType = {
    startWordNumber?: true
    startGroupNumber?: true
    endWordNumber?: true
    endGroupNumber?: true
  }

  export type WordRangeMinAggregateInputType = {
    id?: true
    transcriptId?: true
    startWordNumber?: true
    startGroupNumber?: true
    endWordNumber?: true
    endGroupNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WordRangeMaxAggregateInputType = {
    id?: true
    transcriptId?: true
    startWordNumber?: true
    startGroupNumber?: true
    endWordNumber?: true
    endGroupNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WordRangeCountAggregateInputType = {
    id?: true
    transcriptId?: true
    startWordNumber?: true
    startGroupNumber?: true
    endWordNumber?: true
    endGroupNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WordRangeAggregateArgs = {
    /**
     * Filter which WordRange to aggregate.
     */
    where?: WordRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordRanges to fetch.
     */
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WordRanges
    **/
    _count?: true | WordRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WordRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WordRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordRangeMaxAggregateInputType
  }

  export type GetWordRangeAggregateType<T extends WordRangeAggregateArgs> = {
        [P in keyof T & keyof AggregateWordRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWordRange[P]>
      : GetScalarType<T[P], AggregateWordRange[P]>
  }




  export type WordRangeGroupByArgs = {
    where?: WordRangeWhereInput
    orderBy?: Enumerable<WordRangeOrderByWithAggregationInput>
    by: WordRangeScalarFieldEnum[]
    having?: WordRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordRangeCountAggregateInputType | true
    _avg?: WordRangeAvgAggregateInputType
    _sum?: WordRangeSumAggregateInputType
    _min?: WordRangeMinAggregateInputType
    _max?: WordRangeMaxAggregateInputType
  }


  export type WordRangeGroupByOutputType = {
    id: string
    transcriptId: string
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    createdAt: Date
    updatedAt: Date
    _count: WordRangeCountAggregateOutputType | null
    _avg: WordRangeAvgAggregateOutputType | null
    _sum: WordRangeSumAggregateOutputType | null
    _min: WordRangeMinAggregateOutputType | null
    _max: WordRangeMaxAggregateOutputType | null
  }

  type GetWordRangeGroupByPayload<T extends WordRangeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WordRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordRangeGroupByOutputType[P]>
            : GetScalarType<T[P], WordRangeGroupByOutputType[P]>
        }
      >
    >


  export type WordRangeSelect = {
    id?: boolean
    startWord?: boolean | TranscriptWordArgs
    transcriptId?: boolean
    startWordNumber?: boolean
    startGroupNumber?: boolean
    endWord?: boolean | TranscriptWordArgs
    endWordNumber?: boolean
    endGroupNumber?: boolean
    highlight?: boolean | HighlightArgs
    suggestedHighlight?: boolean | SuggestedHighlightArgs
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WordRangeInclude = {
    startWord?: boolean | TranscriptWordArgs
    endWord?: boolean | TranscriptWordArgs
    highlight?: boolean | HighlightArgs
    suggestedHighlight?: boolean | SuggestedHighlightArgs
  }

  export type WordRangeGetPayload<S extends boolean | null | undefined | WordRangeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WordRange :
    S extends undefined ? never :
    S extends { include: any } & (WordRangeArgs | WordRangeFindManyArgs)
    ? WordRange  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'startWord' ? TranscriptWordGetPayload<S['include'][P]> :
        P extends 'endWord' ? TranscriptWordGetPayload<S['include'][P]> :
        P extends 'highlight' ? HighlightGetPayload<S['include'][P]> | null :
        P extends 'suggestedHighlight' ? SuggestedHighlightGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (WordRangeArgs | WordRangeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'startWord' ? TranscriptWordGetPayload<S['select'][P]> :
        P extends 'endWord' ? TranscriptWordGetPayload<S['select'][P]> :
        P extends 'highlight' ? HighlightGetPayload<S['select'][P]> | null :
        P extends 'suggestedHighlight' ? SuggestedHighlightGetPayload<S['select'][P]> | null :  P extends keyof WordRange ? WordRange[P] : never
  } 
      : WordRange


  type WordRangeCountArgs = 
    Omit<WordRangeFindManyArgs, 'select' | 'include'> & {
      select?: WordRangeCountAggregateInputType | true
    }

  export interface WordRangeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WordRange that matches the filter.
     * @param {WordRangeFindUniqueArgs} args - Arguments to find a WordRange
     * @example
     * // Get one WordRange
     * const wordRange = await prisma.wordRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WordRangeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WordRangeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WordRange'> extends True ? Prisma__WordRangeClient<WordRangeGetPayload<T>> : Prisma__WordRangeClient<WordRangeGetPayload<T> | null, null>

    /**
     * Find one WordRange that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WordRangeFindUniqueOrThrowArgs} args - Arguments to find a WordRange
     * @example
     * // Get one WordRange
     * const wordRange = await prisma.wordRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WordRangeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WordRangeFindUniqueOrThrowArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Find the first WordRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeFindFirstArgs} args - Arguments to find a WordRange
     * @example
     * // Get one WordRange
     * const wordRange = await prisma.wordRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WordRangeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WordRangeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WordRange'> extends True ? Prisma__WordRangeClient<WordRangeGetPayload<T>> : Prisma__WordRangeClient<WordRangeGetPayload<T> | null, null>

    /**
     * Find the first WordRange that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeFindFirstOrThrowArgs} args - Arguments to find a WordRange
     * @example
     * // Get one WordRange
     * const wordRange = await prisma.wordRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WordRangeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WordRangeFindFirstOrThrowArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Find zero or more WordRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WordRanges
     * const wordRanges = await prisma.wordRange.findMany()
     * 
     * // Get first 10 WordRanges
     * const wordRanges = await prisma.wordRange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wordRangeWithIdOnly = await prisma.wordRange.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WordRangeFindManyArgs>(
      args?: SelectSubset<T, WordRangeFindManyArgs>
    ): PrismaPromise<Array<WordRangeGetPayload<T>>>

    /**
     * Create a WordRange.
     * @param {WordRangeCreateArgs} args - Arguments to create a WordRange.
     * @example
     * // Create one WordRange
     * const WordRange = await prisma.wordRange.create({
     *   data: {
     *     // ... data to create a WordRange
     *   }
     * })
     * 
    **/
    create<T extends WordRangeCreateArgs>(
      args: SelectSubset<T, WordRangeCreateArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Create many WordRanges.
     *     @param {WordRangeCreateManyArgs} args - Arguments to create many WordRanges.
     *     @example
     *     // Create many WordRanges
     *     const wordRange = await prisma.wordRange.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WordRangeCreateManyArgs>(
      args?: SelectSubset<T, WordRangeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WordRange.
     * @param {WordRangeDeleteArgs} args - Arguments to delete one WordRange.
     * @example
     * // Delete one WordRange
     * const WordRange = await prisma.wordRange.delete({
     *   where: {
     *     // ... filter to delete one WordRange
     *   }
     * })
     * 
    **/
    delete<T extends WordRangeDeleteArgs>(
      args: SelectSubset<T, WordRangeDeleteArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Update one WordRange.
     * @param {WordRangeUpdateArgs} args - Arguments to update one WordRange.
     * @example
     * // Update one WordRange
     * const wordRange = await prisma.wordRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WordRangeUpdateArgs>(
      args: SelectSubset<T, WordRangeUpdateArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Delete zero or more WordRanges.
     * @param {WordRangeDeleteManyArgs} args - Arguments to filter WordRanges to delete.
     * @example
     * // Delete a few WordRanges
     * const { count } = await prisma.wordRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WordRangeDeleteManyArgs>(
      args?: SelectSubset<T, WordRangeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WordRanges
     * const wordRange = await prisma.wordRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WordRangeUpdateManyArgs>(
      args: SelectSubset<T, WordRangeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WordRange.
     * @param {WordRangeUpsertArgs} args - Arguments to update or create a WordRange.
     * @example
     * // Update or create a WordRange
     * const wordRange = await prisma.wordRange.upsert({
     *   create: {
     *     // ... data to create a WordRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WordRange we want to update
     *   }
     * })
    **/
    upsert<T extends WordRangeUpsertArgs>(
      args: SelectSubset<T, WordRangeUpsertArgs>
    ): Prisma__WordRangeClient<WordRangeGetPayload<T>>

    /**
     * Count the number of WordRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeCountArgs} args - Arguments to filter WordRanges to count.
     * @example
     * // Count the number of WordRanges
     * const count = await prisma.wordRange.count({
     *   where: {
     *     // ... the filter for the WordRanges we want to count
     *   }
     * })
    **/
    count<T extends WordRangeCountArgs>(
      args?: Subset<T, WordRangeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WordRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordRangeAggregateArgs>(args: Subset<T, WordRangeAggregateArgs>): PrismaPromise<GetWordRangeAggregateType<T>>

    /**
     * Group by WordRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordRangeGroupByArgs['orderBy'] }
        : { orderBy?: WordRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordRangeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WordRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WordRangeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startWord<T extends TranscriptWordArgs= {}>(args?: Subset<T, TranscriptWordArgs>): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T> | Null>;

    endWord<T extends TranscriptWordArgs= {}>(args?: Subset<T, TranscriptWordArgs>): Prisma__TranscriptWordClient<TranscriptWordGetPayload<T> | Null>;

    highlight<T extends HighlightArgs= {}>(args?: Subset<T, HighlightArgs>): Prisma__HighlightClient<HighlightGetPayload<T> | Null>;

    suggestedHighlight<T extends SuggestedHighlightArgs= {}>(args?: Subset<T, SuggestedHighlightArgs>): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WordRange base type for findUnique actions
   */
  export type WordRangeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter, which WordRange to fetch.
     */
    where: WordRangeWhereUniqueInput
  }

  /**
   * WordRange findUnique
   */
  export interface WordRangeFindUniqueArgs extends WordRangeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WordRange findUniqueOrThrow
   */
  export type WordRangeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter, which WordRange to fetch.
     */
    where: WordRangeWhereUniqueInput
  }


  /**
   * WordRange base type for findFirst actions
   */
  export type WordRangeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter, which WordRange to fetch.
     */
    where?: WordRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordRanges to fetch.
     */
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordRanges.
     */
    cursor?: WordRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordRanges.
     */
    distinct?: Enumerable<WordRangeScalarFieldEnum>
  }

  /**
   * WordRange findFirst
   */
  export interface WordRangeFindFirstArgs extends WordRangeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WordRange findFirstOrThrow
   */
  export type WordRangeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter, which WordRange to fetch.
     */
    where?: WordRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordRanges to fetch.
     */
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordRanges.
     */
    cursor?: WordRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordRanges.
     */
    distinct?: Enumerable<WordRangeScalarFieldEnum>
  }


  /**
   * WordRange findMany
   */
  export type WordRangeFindManyArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter, which WordRanges to fetch.
     */
    where?: WordRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordRanges to fetch.
     */
    orderBy?: Enumerable<WordRangeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WordRanges.
     */
    cursor?: WordRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordRanges.
     */
    skip?: number
    distinct?: Enumerable<WordRangeScalarFieldEnum>
  }


  /**
   * WordRange create
   */
  export type WordRangeCreateArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * The data needed to create a WordRange.
     */
    data: XOR<WordRangeCreateInput, WordRangeUncheckedCreateInput>
  }


  /**
   * WordRange createMany
   */
  export type WordRangeCreateManyArgs = {
    /**
     * The data used to create many WordRanges.
     */
    data: Enumerable<WordRangeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WordRange update
   */
  export type WordRangeUpdateArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * The data needed to update a WordRange.
     */
    data: XOR<WordRangeUpdateInput, WordRangeUncheckedUpdateInput>
    /**
     * Choose, which WordRange to update.
     */
    where: WordRangeWhereUniqueInput
  }


  /**
   * WordRange updateMany
   */
  export type WordRangeUpdateManyArgs = {
    /**
     * The data used to update WordRanges.
     */
    data: XOR<WordRangeUpdateManyMutationInput, WordRangeUncheckedUpdateManyInput>
    /**
     * Filter which WordRanges to update
     */
    where?: WordRangeWhereInput
  }


  /**
   * WordRange upsert
   */
  export type WordRangeUpsertArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * The filter to search for the WordRange to update in case it exists.
     */
    where: WordRangeWhereUniqueInput
    /**
     * In case the WordRange found by the `where` argument doesn't exist, create a new WordRange with this data.
     */
    create: XOR<WordRangeCreateInput, WordRangeUncheckedCreateInput>
    /**
     * In case the WordRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordRangeUpdateInput, WordRangeUncheckedUpdateInput>
  }


  /**
   * WordRange delete
   */
  export type WordRangeDeleteArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
    /**
     * Filter which WordRange to delete.
     */
    where: WordRangeWhereUniqueInput
  }


  /**
   * WordRange deleteMany
   */
  export type WordRangeDeleteManyArgs = {
    /**
     * Filter which WordRanges to delete
     */
    where?: WordRangeWhereInput
  }


  /**
   * WordRange without action
   */
  export type WordRangeArgs = {
    /**
     * Select specific fields to fetch from the WordRange
     */
    select?: WordRangeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordRangeInclude | null
  }



  /**
   * Model Highlight
   */


  export type AggregateHighlight = {
    _count: HighlightCountAggregateOutputType | null
    _min: HighlightMinAggregateOutputType | null
    _max: HighlightMaxAggregateOutputType | null
  }

  export type HighlightMinAggregateOutputType = {
    id: string | null
    highlightedRangeId: string | null
    timestamp: Date | null
    interviewId: string | null
    videoId: string | null
    transcriptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    originSuggestionId: string | null
  }

  export type HighlightMaxAggregateOutputType = {
    id: string | null
    highlightedRangeId: string | null
    timestamp: Date | null
    interviewId: string | null
    videoId: string | null
    transcriptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    originSuggestionId: string | null
  }

  export type HighlightCountAggregateOutputType = {
    id: number
    highlightedRangeId: number
    timestamp: number
    interviewId: number
    videoId: number
    transcriptId: number
    createdAt: number
    updatedAt: number
    originSuggestionId: number
    _all: number
  }


  export type HighlightMinAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    timestamp?: true
    interviewId?: true
    videoId?: true
    transcriptId?: true
    createdAt?: true
    updatedAt?: true
    originSuggestionId?: true
  }

  export type HighlightMaxAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    timestamp?: true
    interviewId?: true
    videoId?: true
    transcriptId?: true
    createdAt?: true
    updatedAt?: true
    originSuggestionId?: true
  }

  export type HighlightCountAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    timestamp?: true
    interviewId?: true
    videoId?: true
    transcriptId?: true
    createdAt?: true
    updatedAt?: true
    originSuggestionId?: true
    _all?: true
  }

  export type HighlightAggregateArgs = {
    /**
     * Filter which Highlight to aggregate.
     */
    where?: HighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Highlights to fetch.
     */
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Highlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Highlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Highlights
    **/
    _count?: true | HighlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HighlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HighlightMaxAggregateInputType
  }

  export type GetHighlightAggregateType<T extends HighlightAggregateArgs> = {
        [P in keyof T & keyof AggregateHighlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHighlight[P]>
      : GetScalarType<T[P], AggregateHighlight[P]>
  }




  export type HighlightGroupByArgs = {
    where?: HighlightWhereInput
    orderBy?: Enumerable<HighlightOrderByWithAggregationInput>
    by: HighlightScalarFieldEnum[]
    having?: HighlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HighlightCountAggregateInputType | true
    _min?: HighlightMinAggregateInputType
    _max?: HighlightMaxAggregateInputType
  }


  export type HighlightGroupByOutputType = {
    id: string
    highlightedRangeId: string | null
    timestamp: Date | null
    interviewId: string
    videoId: string | null
    transcriptId: string | null
    createdAt: Date
    updatedAt: Date
    originSuggestionId: string | null
    _count: HighlightCountAggregateOutputType | null
    _min: HighlightMinAggregateOutputType | null
    _max: HighlightMaxAggregateOutputType | null
  }

  type GetHighlightGroupByPayload<T extends HighlightGroupByArgs> = PrismaPromise<
    Array<
      PickArray<HighlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HighlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HighlightGroupByOutputType[P]>
            : GetScalarType<T[P], HighlightGroupByOutputType[P]>
        }
      >
    >


  export type HighlightSelect = {
    id?: boolean
    highlightedRange?: boolean | WordRangeArgs
    highlightedRangeId?: boolean
    timestamp?: boolean
    interview?: boolean | InterviewArgs
    interviewId?: boolean
    videoId?: boolean
    video?: boolean | VideoArgs
    transcriptId?: boolean
    transcript?: boolean | TranscriptArgs
    tags?: boolean | Highlight$tagsArgs
    createdAt?: boolean
    updatedAt?: boolean
    originSuggestion?: boolean | SuggestedHighlightArgs
    originSuggestionId?: boolean
    _count?: boolean | HighlightCountOutputTypeArgs
  }


  export type HighlightInclude = {
    highlightedRange?: boolean | WordRangeArgs
    interview?: boolean | InterviewArgs
    video?: boolean | VideoArgs
    transcript?: boolean | TranscriptArgs
    tags?: boolean | Highlight$tagsArgs
    originSuggestion?: boolean | SuggestedHighlightArgs
    _count?: boolean | HighlightCountOutputTypeArgs
  }

  export type HighlightGetPayload<S extends boolean | null | undefined | HighlightArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Highlight :
    S extends undefined ? never :
    S extends { include: any } & (HighlightArgs | HighlightFindManyArgs)
    ? Highlight  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'highlightedRange' ? WordRangeGetPayload<S['include'][P]> | null :
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> :
        P extends 'video' ? VideoGetPayload<S['include'][P]> | null :
        P extends 'transcript' ? TranscriptGetPayload<S['include'][P]> | null :
        P extends 'tags' ? Array < TagGetPayload<S['include'][P]>>  :
        P extends 'originSuggestion' ? SuggestedHighlightGetPayload<S['include'][P]> | null :
        P extends '_count' ? HighlightCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HighlightArgs | HighlightFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'highlightedRange' ? WordRangeGetPayload<S['select'][P]> | null :
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> :
        P extends 'video' ? VideoGetPayload<S['select'][P]> | null :
        P extends 'transcript' ? TranscriptGetPayload<S['select'][P]> | null :
        P extends 'tags' ? Array < TagGetPayload<S['select'][P]>>  :
        P extends 'originSuggestion' ? SuggestedHighlightGetPayload<S['select'][P]> | null :
        P extends '_count' ? HighlightCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Highlight ? Highlight[P] : never
  } 
      : Highlight


  type HighlightCountArgs = 
    Omit<HighlightFindManyArgs, 'select' | 'include'> & {
      select?: HighlightCountAggregateInputType | true
    }

  export interface HighlightDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Highlight that matches the filter.
     * @param {HighlightFindUniqueArgs} args - Arguments to find a Highlight
     * @example
     * // Get one Highlight
     * const highlight = await prisma.highlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HighlightFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HighlightFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Highlight'> extends True ? Prisma__HighlightClient<HighlightGetPayload<T>> : Prisma__HighlightClient<HighlightGetPayload<T> | null, null>

    /**
     * Find one Highlight that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HighlightFindUniqueOrThrowArgs} args - Arguments to find a Highlight
     * @example
     * // Get one Highlight
     * const highlight = await prisma.highlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HighlightFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HighlightFindUniqueOrThrowArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Find the first Highlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightFindFirstArgs} args - Arguments to find a Highlight
     * @example
     * // Get one Highlight
     * const highlight = await prisma.highlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HighlightFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HighlightFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Highlight'> extends True ? Prisma__HighlightClient<HighlightGetPayload<T>> : Prisma__HighlightClient<HighlightGetPayload<T> | null, null>

    /**
     * Find the first Highlight that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightFindFirstOrThrowArgs} args - Arguments to find a Highlight
     * @example
     * // Get one Highlight
     * const highlight = await prisma.highlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HighlightFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HighlightFindFirstOrThrowArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Find zero or more Highlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Highlights
     * const highlights = await prisma.highlight.findMany()
     * 
     * // Get first 10 Highlights
     * const highlights = await prisma.highlight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const highlightWithIdOnly = await prisma.highlight.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HighlightFindManyArgs>(
      args?: SelectSubset<T, HighlightFindManyArgs>
    ): PrismaPromise<Array<HighlightGetPayload<T>>>

    /**
     * Create a Highlight.
     * @param {HighlightCreateArgs} args - Arguments to create a Highlight.
     * @example
     * // Create one Highlight
     * const Highlight = await prisma.highlight.create({
     *   data: {
     *     // ... data to create a Highlight
     *   }
     * })
     * 
    **/
    create<T extends HighlightCreateArgs>(
      args: SelectSubset<T, HighlightCreateArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Create many Highlights.
     *     @param {HighlightCreateManyArgs} args - Arguments to create many Highlights.
     *     @example
     *     // Create many Highlights
     *     const highlight = await prisma.highlight.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HighlightCreateManyArgs>(
      args?: SelectSubset<T, HighlightCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Highlight.
     * @param {HighlightDeleteArgs} args - Arguments to delete one Highlight.
     * @example
     * // Delete one Highlight
     * const Highlight = await prisma.highlight.delete({
     *   where: {
     *     // ... filter to delete one Highlight
     *   }
     * })
     * 
    **/
    delete<T extends HighlightDeleteArgs>(
      args: SelectSubset<T, HighlightDeleteArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Update one Highlight.
     * @param {HighlightUpdateArgs} args - Arguments to update one Highlight.
     * @example
     * // Update one Highlight
     * const highlight = await prisma.highlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HighlightUpdateArgs>(
      args: SelectSubset<T, HighlightUpdateArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Delete zero or more Highlights.
     * @param {HighlightDeleteManyArgs} args - Arguments to filter Highlights to delete.
     * @example
     * // Delete a few Highlights
     * const { count } = await prisma.highlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HighlightDeleteManyArgs>(
      args?: SelectSubset<T, HighlightDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Highlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Highlights
     * const highlight = await prisma.highlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HighlightUpdateManyArgs>(
      args: SelectSubset<T, HighlightUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Highlight.
     * @param {HighlightUpsertArgs} args - Arguments to update or create a Highlight.
     * @example
     * // Update or create a Highlight
     * const highlight = await prisma.highlight.upsert({
     *   create: {
     *     // ... data to create a Highlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Highlight we want to update
     *   }
     * })
    **/
    upsert<T extends HighlightUpsertArgs>(
      args: SelectSubset<T, HighlightUpsertArgs>
    ): Prisma__HighlightClient<HighlightGetPayload<T>>

    /**
     * Count the number of Highlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightCountArgs} args - Arguments to filter Highlights to count.
     * @example
     * // Count the number of Highlights
     * const count = await prisma.highlight.count({
     *   where: {
     *     // ... the filter for the Highlights we want to count
     *   }
     * })
    **/
    count<T extends HighlightCountArgs>(
      args?: Subset<T, HighlightCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HighlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Highlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HighlightAggregateArgs>(args: Subset<T, HighlightAggregateArgs>): PrismaPromise<GetHighlightAggregateType<T>>

    /**
     * Group by Highlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HighlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HighlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HighlightGroupByArgs['orderBy'] }
        : { orderBy?: HighlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HighlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHighlightGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Highlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HighlightClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    highlightedRange<T extends WordRangeArgs= {}>(args?: Subset<T, WordRangeArgs>): Prisma__WordRangeClient<WordRangeGetPayload<T> | Null>;

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    video<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    transcript<T extends TranscriptArgs= {}>(args?: Subset<T, TranscriptArgs>): Prisma__TranscriptClient<TranscriptGetPayload<T> | Null>;

    tags<T extends Highlight$tagsArgs= {}>(args?: Subset<T, Highlight$tagsArgs>): PrismaPromise<Array<TagGetPayload<T>>| Null>;

    originSuggestion<T extends SuggestedHighlightArgs= {}>(args?: Subset<T, SuggestedHighlightArgs>): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Highlight base type for findUnique actions
   */
  export type HighlightFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter, which Highlight to fetch.
     */
    where: HighlightWhereUniqueInput
  }

  /**
   * Highlight findUnique
   */
  export interface HighlightFindUniqueArgs extends HighlightFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Highlight findUniqueOrThrow
   */
  export type HighlightFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter, which Highlight to fetch.
     */
    where: HighlightWhereUniqueInput
  }


  /**
   * Highlight base type for findFirst actions
   */
  export type HighlightFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter, which Highlight to fetch.
     */
    where?: HighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Highlights to fetch.
     */
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Highlights.
     */
    cursor?: HighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Highlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Highlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Highlights.
     */
    distinct?: Enumerable<HighlightScalarFieldEnum>
  }

  /**
   * Highlight findFirst
   */
  export interface HighlightFindFirstArgs extends HighlightFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Highlight findFirstOrThrow
   */
  export type HighlightFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter, which Highlight to fetch.
     */
    where?: HighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Highlights to fetch.
     */
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Highlights.
     */
    cursor?: HighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Highlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Highlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Highlights.
     */
    distinct?: Enumerable<HighlightScalarFieldEnum>
  }


  /**
   * Highlight findMany
   */
  export type HighlightFindManyArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter, which Highlights to fetch.
     */
    where?: HighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Highlights to fetch.
     */
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Highlights.
     */
    cursor?: HighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Highlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Highlights.
     */
    skip?: number
    distinct?: Enumerable<HighlightScalarFieldEnum>
  }


  /**
   * Highlight create
   */
  export type HighlightCreateArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * The data needed to create a Highlight.
     */
    data: XOR<HighlightCreateInput, HighlightUncheckedCreateInput>
  }


  /**
   * Highlight createMany
   */
  export type HighlightCreateManyArgs = {
    /**
     * The data used to create many Highlights.
     */
    data: Enumerable<HighlightCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Highlight update
   */
  export type HighlightUpdateArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * The data needed to update a Highlight.
     */
    data: XOR<HighlightUpdateInput, HighlightUncheckedUpdateInput>
    /**
     * Choose, which Highlight to update.
     */
    where: HighlightWhereUniqueInput
  }


  /**
   * Highlight updateMany
   */
  export type HighlightUpdateManyArgs = {
    /**
     * The data used to update Highlights.
     */
    data: XOR<HighlightUpdateManyMutationInput, HighlightUncheckedUpdateManyInput>
    /**
     * Filter which Highlights to update
     */
    where?: HighlightWhereInput
  }


  /**
   * Highlight upsert
   */
  export type HighlightUpsertArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * The filter to search for the Highlight to update in case it exists.
     */
    where: HighlightWhereUniqueInput
    /**
     * In case the Highlight found by the `where` argument doesn't exist, create a new Highlight with this data.
     */
    create: XOR<HighlightCreateInput, HighlightUncheckedCreateInput>
    /**
     * In case the Highlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HighlightUpdateInput, HighlightUncheckedUpdateInput>
  }


  /**
   * Highlight delete
   */
  export type HighlightDeleteArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    /**
     * Filter which Highlight to delete.
     */
    where: HighlightWhereUniqueInput
  }


  /**
   * Highlight deleteMany
   */
  export type HighlightDeleteManyArgs = {
    /**
     * Filter which Highlights to delete
     */
    where?: HighlightWhereInput
  }


  /**
   * Highlight.tags
   */
  export type Highlight$tagsArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Highlight without action
   */
  export type HighlightArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    session: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    session: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    session: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    session?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    session?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    session?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: SessionScalarFieldEnum[]
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    session: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    session?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SessionGetPayload<S extends boolean | null | undefined | SessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Session :
    S extends undefined ? never :
    S extends { include: any } & (SessionArgs | SessionFindManyArgs)
    ? Session 
    : S extends { select: any } & (SessionArgs | SessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Session ? Session[P] : never
  } 
      : Session


  type SessionCountArgs = 
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): PrismaPromise<Array<SessionGetPayload<T>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     */
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailHash: string | null
    fullName: string | null
    confirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailHash: string | null
    fullName: string | null
    confirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailHash: number
    fullName: number
    confirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailHash?: true
    fullName?: true
    confirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailHash?: true
    fullName?: true
    confirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailHash?: true
    fullName?: true
    confirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    emailHash: string | null
    fullName: string
    confirmed: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    emailHash?: boolean
    fullName?: boolean
    confirmed?: boolean
    interviews?: boolean | User$interviewsArgs
    roles?: boolean | User$rolesArgs
    sourceAuths?: boolean | User$sourceAuthsArgs
    identities?: boolean | User$identitiesArgs
    inviteTokens?: boolean | User$inviteTokensArgs
    createdAt?: boolean
    updatedAt?: boolean
    notificationPreferences?: boolean | NotificationPreferencesArgs
    tagOrder?: boolean | User$tagOrderArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    interviews?: boolean | User$interviewsArgs
    roles?: boolean | User$rolesArgs
    sourceAuths?: boolean | User$sourceAuthsArgs
    identities?: boolean | User$identitiesArgs
    inviteTokens?: boolean | User$inviteTokensArgs
    notificationPreferences?: boolean | NotificationPreferencesArgs
    tagOrder?: boolean | User$tagOrderArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interviews' ? Array < InterviewGetPayload<S['include'][P]>>  :
        P extends 'roles' ? Array < WorkspaceRoleGetPayload<S['include'][P]>>  :
        P extends 'sourceAuths' ? Array < ExternalAuthGetPayload<S['include'][P]>>  :
        P extends 'identities' ? Array < IdentityGetPayload<S['include'][P]>>  :
        P extends 'inviteTokens' ? Array < WorkspaceInviteGetPayload<S['include'][P]>>  :
        P extends 'notificationPreferences' ? NotificationPreferencesGetPayload<S['include'][P]> | null :
        P extends 'tagOrder' ? Array < UserTagOrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interviews' ? Array < InterviewGetPayload<S['select'][P]>>  :
        P extends 'roles' ? Array < WorkspaceRoleGetPayload<S['select'][P]>>  :
        P extends 'sourceAuths' ? Array < ExternalAuthGetPayload<S['select'][P]>>  :
        P extends 'identities' ? Array < IdentityGetPayload<S['select'][P]>>  :
        P extends 'inviteTokens' ? Array < WorkspaceInviteGetPayload<S['select'][P]>>  :
        P extends 'notificationPreferences' ? NotificationPreferencesGetPayload<S['select'][P]> | null :
        P extends 'tagOrder' ? Array < UserTagOrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interviews<T extends User$interviewsArgs= {}>(args?: Subset<T, User$interviewsArgs>): PrismaPromise<Array<InterviewGetPayload<T>>| Null>;

    roles<T extends User$rolesArgs= {}>(args?: Subset<T, User$rolesArgs>): PrismaPromise<Array<WorkspaceRoleGetPayload<T>>| Null>;

    sourceAuths<T extends User$sourceAuthsArgs= {}>(args?: Subset<T, User$sourceAuthsArgs>): PrismaPromise<Array<ExternalAuthGetPayload<T>>| Null>;

    identities<T extends User$identitiesArgs= {}>(args?: Subset<T, User$identitiesArgs>): PrismaPromise<Array<IdentityGetPayload<T>>| Null>;

    inviteTokens<T extends User$inviteTokensArgs= {}>(args?: Subset<T, User$inviteTokensArgs>): PrismaPromise<Array<WorkspaceInviteGetPayload<T>>| Null>;

    notificationPreferences<T extends NotificationPreferencesArgs= {}>(args?: Subset<T, NotificationPreferencesArgs>): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T> | Null>;

    tagOrder<T extends User$tagOrderArgs= {}>(args?: Subset<T, User$tagOrderArgs>): PrismaPromise<Array<UserTagOrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.interviews
   */
  export type User$interviewsArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    where?: InterviewWhereInput
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }


  /**
   * User.roles
   */
  export type User$rolesArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    where?: WorkspaceRoleWhereInput
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    cursor?: WorkspaceRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkspaceRoleScalarFieldEnum>
  }


  /**
   * User.sourceAuths
   */
  export type User$sourceAuthsArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    where?: ExternalAuthWhereInput
    orderBy?: Enumerable<ExternalAuthOrderByWithRelationInput>
    cursor?: ExternalAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExternalAuthScalarFieldEnum>
  }


  /**
   * User.identities
   */
  export type User$identitiesArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    where?: IdentityWhereInput
    orderBy?: Enumerable<IdentityOrderByWithRelationInput>
    cursor?: IdentityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IdentityScalarFieldEnum>
  }


  /**
   * User.inviteTokens
   */
  export type User$inviteTokensArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    where?: WorkspaceInviteWhereInput
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    cursor?: WorkspaceInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkspaceInviteScalarFieldEnum>
  }


  /**
   * User.tagOrder
   */
  export type User$tagOrderArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    where?: UserTagOrderWhereInput
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    cursor?: UserTagOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserTagOrderScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Identity
   */


  export type AggregateIdentity = {
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  export type IdentityMinAggregateOutputType = {
    token: string | null
    userId: string | null
    type: IdentityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentityMaxAggregateOutputType = {
    token: string | null
    userId: string | null
    type: IdentityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentityCountAggregateOutputType = {
    token: number
    userId: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdentityMinAggregateInputType = {
    token?: true
    userId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentityMaxAggregateInputType = {
    token?: true
    userId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentityCountAggregateInputType = {
    token?: true
    userId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdentityAggregateArgs = {
    /**
     * Filter which Identity to aggregate.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: Enumerable<IdentityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Identities
    **/
    _count?: true | IdentityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentityMaxAggregateInputType
  }

  export type GetIdentityAggregateType<T extends IdentityAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentity[P]>
      : GetScalarType<T[P], AggregateIdentity[P]>
  }




  export type IdentityGroupByArgs = {
    where?: IdentityWhereInput
    orderBy?: Enumerable<IdentityOrderByWithAggregationInput>
    by: IdentityScalarFieldEnum[]
    having?: IdentityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentityCountAggregateInputType | true
    _min?: IdentityMinAggregateInputType
    _max?: IdentityMaxAggregateInputType
  }


  export type IdentityGroupByOutputType = {
    token: string
    userId: string
    type: IdentityType
    createdAt: Date
    updatedAt: Date
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  type GetIdentityGroupByPayload<T extends IdentityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IdentityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentityGroupByOutputType[P]>
            : GetScalarType<T[P], IdentityGroupByOutputType[P]>
        }
      >
    >


  export type IdentitySelect = {
    token?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type IdentityInclude = {
    user?: boolean | UserArgs
  }

  export type IdentityGetPayload<S extends boolean | null | undefined | IdentityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Identity :
    S extends undefined ? never :
    S extends { include: any } & (IdentityArgs | IdentityFindManyArgs)
    ? Identity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IdentityArgs | IdentityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Identity ? Identity[P] : never
  } 
      : Identity


  type IdentityCountArgs = 
    Omit<IdentityFindManyArgs, 'select' | 'include'> & {
      select?: IdentityCountAggregateInputType | true
    }

  export interface IdentityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Identity that matches the filter.
     * @param {IdentityFindUniqueArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IdentityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IdentityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Identity'> extends True ? Prisma__IdentityClient<IdentityGetPayload<T>> : Prisma__IdentityClient<IdentityGetPayload<T> | null, null>

    /**
     * Find one Identity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IdentityFindUniqueOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IdentityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IdentityFindUniqueOrThrowArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Find the first Identity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IdentityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IdentityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Identity'> extends True ? Prisma__IdentityClient<IdentityGetPayload<T>> : Prisma__IdentityClient<IdentityGetPayload<T> | null, null>

    /**
     * Find the first Identity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IdentityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IdentityFindFirstOrThrowArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Find zero or more Identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identities
     * const identities = await prisma.identity.findMany()
     * 
     * // Get first 10 Identities
     * const identities = await prisma.identity.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const identityWithTokenOnly = await prisma.identity.findMany({ select: { token: true } })
     * 
    **/
    findMany<T extends IdentityFindManyArgs>(
      args?: SelectSubset<T, IdentityFindManyArgs>
    ): PrismaPromise<Array<IdentityGetPayload<T>>>

    /**
     * Create a Identity.
     * @param {IdentityCreateArgs} args - Arguments to create a Identity.
     * @example
     * // Create one Identity
     * const Identity = await prisma.identity.create({
     *   data: {
     *     // ... data to create a Identity
     *   }
     * })
     * 
    **/
    create<T extends IdentityCreateArgs>(
      args: SelectSubset<T, IdentityCreateArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Create many Identities.
     *     @param {IdentityCreateManyArgs} args - Arguments to create many Identities.
     *     @example
     *     // Create many Identities
     *     const identity = await prisma.identity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IdentityCreateManyArgs>(
      args?: SelectSubset<T, IdentityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Identity.
     * @param {IdentityDeleteArgs} args - Arguments to delete one Identity.
     * @example
     * // Delete one Identity
     * const Identity = await prisma.identity.delete({
     *   where: {
     *     // ... filter to delete one Identity
     *   }
     * })
     * 
    **/
    delete<T extends IdentityDeleteArgs>(
      args: SelectSubset<T, IdentityDeleteArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Update one Identity.
     * @param {IdentityUpdateArgs} args - Arguments to update one Identity.
     * @example
     * // Update one Identity
     * const identity = await prisma.identity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IdentityUpdateArgs>(
      args: SelectSubset<T, IdentityUpdateArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Delete zero or more Identities.
     * @param {IdentityDeleteManyArgs} args - Arguments to filter Identities to delete.
     * @example
     * // Delete a few Identities
     * const { count } = await prisma.identity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IdentityDeleteManyArgs>(
      args?: SelectSubset<T, IdentityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identities
     * const identity = await prisma.identity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IdentityUpdateManyArgs>(
      args: SelectSubset<T, IdentityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Identity.
     * @param {IdentityUpsertArgs} args - Arguments to update or create a Identity.
     * @example
     * // Update or create a Identity
     * const identity = await prisma.identity.upsert({
     *   create: {
     *     // ... data to create a Identity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identity we want to update
     *   }
     * })
    **/
    upsert<T extends IdentityUpsertArgs>(
      args: SelectSubset<T, IdentityUpsertArgs>
    ): Prisma__IdentityClient<IdentityGetPayload<T>>

    /**
     * Count the number of Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityCountArgs} args - Arguments to filter Identities to count.
     * @example
     * // Count the number of Identities
     * const count = await prisma.identity.count({
     *   where: {
     *     // ... the filter for the Identities we want to count
     *   }
     * })
    **/
    count<T extends IdentityCountArgs>(
      args?: Subset<T, IdentityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentityAggregateArgs>(args: Subset<T, IdentityAggregateArgs>): PrismaPromise<GetIdentityAggregateType<T>>

    /**
     * Group by Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentityGroupByArgs['orderBy'] }
        : { orderBy?: IdentityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Identity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IdentityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Identity base type for findUnique actions
   */
  export type IdentityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity findUnique
   */
  export interface IdentityFindUniqueArgs extends IdentityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Identity findUniqueOrThrow
   */
  export type IdentityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }


  /**
   * Identity base type for findFirst actions
   */
  export type IdentityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: Enumerable<IdentityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: Enumerable<IdentityScalarFieldEnum>
  }

  /**
   * Identity findFirst
   */
  export interface IdentityFindFirstArgs extends IdentityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Identity findFirstOrThrow
   */
  export type IdentityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: Enumerable<IdentityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: Enumerable<IdentityScalarFieldEnum>
  }


  /**
   * Identity findMany
   */
  export type IdentityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter, which Identities to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: Enumerable<IdentityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    distinct?: Enumerable<IdentityScalarFieldEnum>
  }


  /**
   * Identity create
   */
  export type IdentityCreateArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * The data needed to create a Identity.
     */
    data: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
  }


  /**
   * Identity createMany
   */
  export type IdentityCreateManyArgs = {
    /**
     * The data used to create many Identities.
     */
    data: Enumerable<IdentityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Identity update
   */
  export type IdentityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * The data needed to update a Identity.
     */
    data: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
    /**
     * Choose, which Identity to update.
     */
    where: IdentityWhereUniqueInput
  }


  /**
   * Identity updateMany
   */
  export type IdentityUpdateManyArgs = {
    /**
     * The data used to update Identities.
     */
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyInput>
    /**
     * Filter which Identities to update
     */
    where?: IdentityWhereInput
  }


  /**
   * Identity upsert
   */
  export type IdentityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * The filter to search for the Identity to update in case it exists.
     */
    where: IdentityWhereUniqueInput
    /**
     * In case the Identity found by the `where` argument doesn't exist, create a new Identity with this data.
     */
    create: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
    /**
     * In case the Identity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
  }


  /**
   * Identity delete
   */
  export type IdentityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
    /**
     * Filter which Identity to delete.
     */
    where: IdentityWhereUniqueInput
  }


  /**
   * Identity deleteMany
   */
  export type IdentityDeleteManyArgs = {
    /**
     * Filter which Identities to delete
     */
    where?: IdentityWhereInput
  }


  /**
   * Identity without action
   */
  export type IdentityArgs = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IdentityInclude | null
  }



  /**
   * Model ExternalAuth
   */


  export type AggregateExternalAuth = {
    _count: ExternalAuthCountAggregateOutputType | null
    _min: ExternalAuthMinAggregateOutputType | null
    _max: ExternalAuthMaxAggregateOutputType | null
  }

  export type ExternalAuthMinAggregateOutputType = {
    userId: string | null
    type: ExternalAuthTypes | null
    authToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAuthMaxAggregateOutputType = {
    userId: string | null
    type: ExternalAuthTypes | null
    authToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAuthCountAggregateOutputType = {
    userId: number
    type: number
    authToken: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalAuthMinAggregateInputType = {
    userId?: true
    type?: true
    authToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAuthMaxAggregateInputType = {
    userId?: true
    type?: true
    authToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAuthCountAggregateInputType = {
    userId?: true
    type?: true
    authToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalAuthAggregateArgs = {
    /**
     * Filter which ExternalAuth to aggregate.
     */
    where?: ExternalAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAuths to fetch.
     */
    orderBy?: Enumerable<ExternalAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAuths
    **/
    _count?: true | ExternalAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAuthMaxAggregateInputType
  }

  export type GetExternalAuthAggregateType<T extends ExternalAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAuth[P]>
      : GetScalarType<T[P], AggregateExternalAuth[P]>
  }




  export type ExternalAuthGroupByArgs = {
    where?: ExternalAuthWhereInput
    orderBy?: Enumerable<ExternalAuthOrderByWithAggregationInput>
    by: ExternalAuthScalarFieldEnum[]
    having?: ExternalAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAuthCountAggregateInputType | true
    _min?: ExternalAuthMinAggregateInputType
    _max?: ExternalAuthMaxAggregateInputType
  }


  export type ExternalAuthGroupByOutputType = {
    userId: string
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExternalAuthCountAggregateOutputType | null
    _min: ExternalAuthMinAggregateOutputType | null
    _max: ExternalAuthMaxAggregateOutputType | null
  }

  type GetExternalAuthGroupByPayload<T extends ExternalAuthGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExternalAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAuthGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAuthGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAuthSelect = {
    userId?: boolean
    type?: boolean
    user?: boolean | UserArgs
    authToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ExternalAuthInclude = {
    user?: boolean | UserArgs
  }

  export type ExternalAuthGetPayload<S extends boolean | null | undefined | ExternalAuthArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ExternalAuth :
    S extends undefined ? never :
    S extends { include: any } & (ExternalAuthArgs | ExternalAuthFindManyArgs)
    ? ExternalAuth  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ExternalAuthArgs | ExternalAuthFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof ExternalAuth ? ExternalAuth[P] : never
  } 
      : ExternalAuth


  type ExternalAuthCountArgs = 
    Omit<ExternalAuthFindManyArgs, 'select' | 'include'> & {
      select?: ExternalAuthCountAggregateInputType | true
    }

  export interface ExternalAuthDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ExternalAuth that matches the filter.
     * @param {ExternalAuthFindUniqueArgs} args - Arguments to find a ExternalAuth
     * @example
     * // Get one ExternalAuth
     * const externalAuth = await prisma.externalAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExternalAuthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExternalAuthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExternalAuth'> extends True ? Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>> : Prisma__ExternalAuthClient<ExternalAuthGetPayload<T> | null, null>

    /**
     * Find one ExternalAuth that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExternalAuthFindUniqueOrThrowArgs} args - Arguments to find a ExternalAuth
     * @example
     * // Get one ExternalAuth
     * const externalAuth = await prisma.externalAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExternalAuthFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExternalAuthFindUniqueOrThrowArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Find the first ExternalAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthFindFirstArgs} args - Arguments to find a ExternalAuth
     * @example
     * // Get one ExternalAuth
     * const externalAuth = await prisma.externalAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExternalAuthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExternalAuthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExternalAuth'> extends True ? Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>> : Prisma__ExternalAuthClient<ExternalAuthGetPayload<T> | null, null>

    /**
     * Find the first ExternalAuth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthFindFirstOrThrowArgs} args - Arguments to find a ExternalAuth
     * @example
     * // Get one ExternalAuth
     * const externalAuth = await prisma.externalAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExternalAuthFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExternalAuthFindFirstOrThrowArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Find zero or more ExternalAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAuths
     * const externalAuths = await prisma.externalAuth.findMany()
     * 
     * // Get first 10 ExternalAuths
     * const externalAuths = await prisma.externalAuth.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const externalAuthWithUserIdOnly = await prisma.externalAuth.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends ExternalAuthFindManyArgs>(
      args?: SelectSubset<T, ExternalAuthFindManyArgs>
    ): PrismaPromise<Array<ExternalAuthGetPayload<T>>>

    /**
     * Create a ExternalAuth.
     * @param {ExternalAuthCreateArgs} args - Arguments to create a ExternalAuth.
     * @example
     * // Create one ExternalAuth
     * const ExternalAuth = await prisma.externalAuth.create({
     *   data: {
     *     // ... data to create a ExternalAuth
     *   }
     * })
     * 
    **/
    create<T extends ExternalAuthCreateArgs>(
      args: SelectSubset<T, ExternalAuthCreateArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Create many ExternalAuths.
     *     @param {ExternalAuthCreateManyArgs} args - Arguments to create many ExternalAuths.
     *     @example
     *     // Create many ExternalAuths
     *     const externalAuth = await prisma.externalAuth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExternalAuthCreateManyArgs>(
      args?: SelectSubset<T, ExternalAuthCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalAuth.
     * @param {ExternalAuthDeleteArgs} args - Arguments to delete one ExternalAuth.
     * @example
     * // Delete one ExternalAuth
     * const ExternalAuth = await prisma.externalAuth.delete({
     *   where: {
     *     // ... filter to delete one ExternalAuth
     *   }
     * })
     * 
    **/
    delete<T extends ExternalAuthDeleteArgs>(
      args: SelectSubset<T, ExternalAuthDeleteArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Update one ExternalAuth.
     * @param {ExternalAuthUpdateArgs} args - Arguments to update one ExternalAuth.
     * @example
     * // Update one ExternalAuth
     * const externalAuth = await prisma.externalAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExternalAuthUpdateArgs>(
      args: SelectSubset<T, ExternalAuthUpdateArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Delete zero or more ExternalAuths.
     * @param {ExternalAuthDeleteManyArgs} args - Arguments to filter ExternalAuths to delete.
     * @example
     * // Delete a few ExternalAuths
     * const { count } = await prisma.externalAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExternalAuthDeleteManyArgs>(
      args?: SelectSubset<T, ExternalAuthDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAuths
     * const externalAuth = await prisma.externalAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExternalAuthUpdateManyArgs>(
      args: SelectSubset<T, ExternalAuthUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAuth.
     * @param {ExternalAuthUpsertArgs} args - Arguments to update or create a ExternalAuth.
     * @example
     * // Update or create a ExternalAuth
     * const externalAuth = await prisma.externalAuth.upsert({
     *   create: {
     *     // ... data to create a ExternalAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAuth we want to update
     *   }
     * })
    **/
    upsert<T extends ExternalAuthUpsertArgs>(
      args: SelectSubset<T, ExternalAuthUpsertArgs>
    ): Prisma__ExternalAuthClient<ExternalAuthGetPayload<T>>

    /**
     * Count the number of ExternalAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthCountArgs} args - Arguments to filter ExternalAuths to count.
     * @example
     * // Count the number of ExternalAuths
     * const count = await prisma.externalAuth.count({
     *   where: {
     *     // ... the filter for the ExternalAuths we want to count
     *   }
     * })
    **/
    count<T extends ExternalAuthCountArgs>(
      args?: Subset<T, ExternalAuthCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAuthAggregateArgs>(args: Subset<T, ExternalAuthAggregateArgs>): PrismaPromise<GetExternalAuthAggregateType<T>>

    /**
     * Group by ExternalAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAuthGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAuthGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExternalAuthClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ExternalAuth base type for findUnique actions
   */
  export type ExternalAuthFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter, which ExternalAuth to fetch.
     */
    where: ExternalAuthWhereUniqueInput
  }

  /**
   * ExternalAuth findUnique
   */
  export interface ExternalAuthFindUniqueArgs extends ExternalAuthFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExternalAuth findUniqueOrThrow
   */
  export type ExternalAuthFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter, which ExternalAuth to fetch.
     */
    where: ExternalAuthWhereUniqueInput
  }


  /**
   * ExternalAuth base type for findFirst actions
   */
  export type ExternalAuthFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter, which ExternalAuth to fetch.
     */
    where?: ExternalAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAuths to fetch.
     */
    orderBy?: Enumerable<ExternalAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAuths.
     */
    cursor?: ExternalAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAuths.
     */
    distinct?: Enumerable<ExternalAuthScalarFieldEnum>
  }

  /**
   * ExternalAuth findFirst
   */
  export interface ExternalAuthFindFirstArgs extends ExternalAuthFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExternalAuth findFirstOrThrow
   */
  export type ExternalAuthFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter, which ExternalAuth to fetch.
     */
    where?: ExternalAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAuths to fetch.
     */
    orderBy?: Enumerable<ExternalAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAuths.
     */
    cursor?: ExternalAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAuths.
     */
    distinct?: Enumerable<ExternalAuthScalarFieldEnum>
  }


  /**
   * ExternalAuth findMany
   */
  export type ExternalAuthFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter, which ExternalAuths to fetch.
     */
    where?: ExternalAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAuths to fetch.
     */
    orderBy?: Enumerable<ExternalAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAuths.
     */
    cursor?: ExternalAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAuths.
     */
    skip?: number
    distinct?: Enumerable<ExternalAuthScalarFieldEnum>
  }


  /**
   * ExternalAuth create
   */
  export type ExternalAuthCreateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * The data needed to create a ExternalAuth.
     */
    data: XOR<ExternalAuthCreateInput, ExternalAuthUncheckedCreateInput>
  }


  /**
   * ExternalAuth createMany
   */
  export type ExternalAuthCreateManyArgs = {
    /**
     * The data used to create many ExternalAuths.
     */
    data: Enumerable<ExternalAuthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ExternalAuth update
   */
  export type ExternalAuthUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * The data needed to update a ExternalAuth.
     */
    data: XOR<ExternalAuthUpdateInput, ExternalAuthUncheckedUpdateInput>
    /**
     * Choose, which ExternalAuth to update.
     */
    where: ExternalAuthWhereUniqueInput
  }


  /**
   * ExternalAuth updateMany
   */
  export type ExternalAuthUpdateManyArgs = {
    /**
     * The data used to update ExternalAuths.
     */
    data: XOR<ExternalAuthUpdateManyMutationInput, ExternalAuthUncheckedUpdateManyInput>
    /**
     * Filter which ExternalAuths to update
     */
    where?: ExternalAuthWhereInput
  }


  /**
   * ExternalAuth upsert
   */
  export type ExternalAuthUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * The filter to search for the ExternalAuth to update in case it exists.
     */
    where: ExternalAuthWhereUniqueInput
    /**
     * In case the ExternalAuth found by the `where` argument doesn't exist, create a new ExternalAuth with this data.
     */
    create: XOR<ExternalAuthCreateInput, ExternalAuthUncheckedCreateInput>
    /**
     * In case the ExternalAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalAuthUpdateInput, ExternalAuthUncheckedUpdateInput>
  }


  /**
   * ExternalAuth delete
   */
  export type ExternalAuthDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
    /**
     * Filter which ExternalAuth to delete.
     */
    where: ExternalAuthWhereUniqueInput
  }


  /**
   * ExternalAuth deleteMany
   */
  export type ExternalAuthDeleteManyArgs = {
    /**
     * Filter which ExternalAuths to delete
     */
    where?: ExternalAuthWhereInput
  }


  /**
   * ExternalAuth without action
   */
  export type ExternalAuthArgs = {
    /**
     * Select specific fields to fetch from the ExternalAuth
     */
    select?: ExternalAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExternalAuthInclude | null
  }



  /**
   * Model Workspace
   */


  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    publicInterviewLinks: boolean | null
    ownedDomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    publicInterviewLinks: boolean | null
    ownedDomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    publicInterviewLinks: number
    ownedDomain: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    publicInterviewLinks?: true
    ownedDomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    publicInterviewLinks?: true
    ownedDomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    publicInterviewLinks?: true
    ownedDomain?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs = {
    where?: WorkspaceWhereInput
    orderBy?: Enumerable<WorkspaceOrderByWithAggregationInput>
    by: WorkspaceScalarFieldEnum[]
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }


  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    publicInterviewLinks: boolean
    ownedDomain: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect = {
    id?: boolean
    name?: boolean
    roles?: boolean | Workspace$rolesArgs
    interviews?: boolean | Workspace$interviewsArgs
    inviteTokens?: boolean | Workspace$inviteTokensArgs
    publicInterviewLinks?: boolean
    ownedDomain?: boolean
    tags?: boolean | Workspace$tagsArgs
    projects?: boolean | Workspace$projectsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | WorkspaceCountOutputTypeArgs
  }


  export type WorkspaceInclude = {
    roles?: boolean | Workspace$rolesArgs
    interviews?: boolean | Workspace$interviewsArgs
    inviteTokens?: boolean | Workspace$inviteTokensArgs
    tags?: boolean | Workspace$tagsArgs
    projects?: boolean | Workspace$projectsArgs
    _count?: boolean | WorkspaceCountOutputTypeArgs
  }

  export type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Workspace :
    S extends undefined ? never :
    S extends { include: any } & (WorkspaceArgs | WorkspaceFindManyArgs)
    ? Workspace  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'roles' ? Array < WorkspaceRoleGetPayload<S['include'][P]>>  :
        P extends 'interviews' ? Array < InterviewGetPayload<S['include'][P]>>  :
        P extends 'inviteTokens' ? Array < WorkspaceInviteGetPayload<S['include'][P]>>  :
        P extends 'tags' ? Array < TagGetPayload<S['include'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkspaceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkspaceArgs | WorkspaceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'roles' ? Array < WorkspaceRoleGetPayload<S['select'][P]>>  :
        P extends 'interviews' ? Array < InterviewGetPayload<S['select'][P]>>  :
        P extends 'inviteTokens' ? Array < WorkspaceInviteGetPayload<S['select'][P]>>  :
        P extends 'tags' ? Array < TagGetPayload<S['select'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkspaceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Workspace ? Workspace[P] : never
  } 
      : Workspace


  type WorkspaceCountArgs = 
    Omit<WorkspaceFindManyArgs, 'select' | 'include'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkspaceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkspaceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Workspace'> extends True ? Prisma__WorkspaceClient<WorkspaceGetPayload<T>> : Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null, null>

    /**
     * Find one Workspace that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkspaceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkspaceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Workspace'> extends True ? Prisma__WorkspaceClient<WorkspaceGetPayload<T>> : Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null, null>

    /**
     * Find the first Workspace that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkspaceFindManyArgs>(
      args?: SelectSubset<T, WorkspaceFindManyArgs>
    ): PrismaPromise<Array<WorkspaceGetPayload<T>>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
    **/
    create<T extends WorkspaceCreateArgs>(
      args: SelectSubset<T, WorkspaceCreateArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Create many Workspaces.
     *     @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     *     @example
     *     // Create many Workspaces
     *     const workspace = await prisma.workspace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkspaceCreateManyArgs>(
      args?: SelectSubset<T, WorkspaceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
    **/
    delete<T extends WorkspaceDeleteArgs>(
      args: SelectSubset<T, WorkspaceDeleteArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkspaceUpdateArgs>(
      args: SelectSubset<T, WorkspaceUpdateArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkspaceDeleteManyArgs>(
      args?: SelectSubset<T, WorkspaceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkspaceUpdateManyArgs>(
      args: SelectSubset<T, WorkspaceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
    **/
    upsert<T extends WorkspaceUpsertArgs>(
      args: SelectSubset<T, WorkspaceUpsertArgs>
    ): Prisma__WorkspaceClient<WorkspaceGetPayload<T>>

    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkspaceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    roles<T extends Workspace$rolesArgs= {}>(args?: Subset<T, Workspace$rolesArgs>): PrismaPromise<Array<WorkspaceRoleGetPayload<T>>| Null>;

    interviews<T extends Workspace$interviewsArgs= {}>(args?: Subset<T, Workspace$interviewsArgs>): PrismaPromise<Array<InterviewGetPayload<T>>| Null>;

    inviteTokens<T extends Workspace$inviteTokensArgs= {}>(args?: Subset<T, Workspace$inviteTokensArgs>): PrismaPromise<Array<WorkspaceInviteGetPayload<T>>| Null>;

    tags<T extends Workspace$tagsArgs= {}>(args?: Subset<T, Workspace$tagsArgs>): PrismaPromise<Array<TagGetPayload<T>>| Null>;

    projects<T extends Workspace$projectsArgs= {}>(args?: Subset<T, Workspace$projectsArgs>): PrismaPromise<Array<ProjectGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Workspace base type for findUnique actions
   */
  export type WorkspaceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUnique
   */
  export interface WorkspaceFindUniqueArgs extends WorkspaceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }


  /**
   * Workspace base type for findFirst actions
   */
  export type WorkspaceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: Enumerable<WorkspaceScalarFieldEnum>
  }

  /**
   * Workspace findFirst
   */
  export interface WorkspaceFindFirstArgs extends WorkspaceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: Enumerable<WorkspaceScalarFieldEnum>
  }


  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: Enumerable<WorkspaceScalarFieldEnum>
  }


  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }


  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs = {
    /**
     * The data used to create many Workspaces.
     */
    data: Enumerable<WorkspaceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }


  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
  }


  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }


  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }


  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
  }


  /**
   * Workspace.roles
   */
  export type Workspace$rolesArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    where?: WorkspaceRoleWhereInput
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    cursor?: WorkspaceRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkspaceRoleScalarFieldEnum>
  }


  /**
   * Workspace.interviews
   */
  export type Workspace$interviewsArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    where?: InterviewWhereInput
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }


  /**
   * Workspace.inviteTokens
   */
  export type Workspace$inviteTokensArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    where?: WorkspaceInviteWhereInput
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    cursor?: WorkspaceInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkspaceInviteScalarFieldEnum>
  }


  /**
   * Workspace.tags
   */
  export type Workspace$tagsArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Workspace.projects
   */
  export type Workspace$projectsArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Workspace without action
   */
  export type WorkspaceArgs = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInclude | null
  }



  /**
   * Model WorkspaceInvite
   */


  export type AggregateWorkspaceInvite = {
    _count: WorkspaceInviteCountAggregateOutputType | null
    _min: WorkspaceInviteMinAggregateOutputType | null
    _max: WorkspaceInviteMaxAggregateOutputType | null
  }

  export type WorkspaceInviteMinAggregateOutputType = {
    token: string | null
    workspaceId: string | null
    inviterId: string | null
    isExpired: boolean | null
    inviteeEmail: string | null
    isAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceInviteMaxAggregateOutputType = {
    token: string | null
    workspaceId: string | null
    inviterId: string | null
    isExpired: boolean | null
    inviteeEmail: string | null
    isAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceInviteCountAggregateOutputType = {
    token: number
    workspaceId: number
    inviterId: number
    isExpired: number
    inviteeEmail: number
    isAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceInviteMinAggregateInputType = {
    token?: true
    workspaceId?: true
    inviterId?: true
    isExpired?: true
    inviteeEmail?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceInviteMaxAggregateInputType = {
    token?: true
    workspaceId?: true
    inviterId?: true
    isExpired?: true
    inviteeEmail?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceInviteCountAggregateInputType = {
    token?: true
    workspaceId?: true
    inviterId?: true
    isExpired?: true
    inviteeEmail?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceInviteAggregateArgs = {
    /**
     * Filter which WorkspaceInvite to aggregate.
     */
    where?: WorkspaceInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvites to fetch.
     */
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvites
    **/
    _count?: true | WorkspaceInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInviteMaxAggregateInputType
  }

  export type GetWorkspaceInviteAggregateType<T extends WorkspaceInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvite[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvite[P]>
  }




  export type WorkspaceInviteGroupByArgs = {
    where?: WorkspaceInviteWhereInput
    orderBy?: Enumerable<WorkspaceInviteOrderByWithAggregationInput>
    by: WorkspaceInviteScalarFieldEnum[]
    having?: WorkspaceInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInviteCountAggregateInputType | true
    _min?: WorkspaceInviteMinAggregateInputType
    _max?: WorkspaceInviteMaxAggregateInputType
  }


  export type WorkspaceInviteGroupByOutputType = {
    token: string
    workspaceId: string
    inviterId: string
    isExpired: boolean
    inviteeEmail: string | null
    isAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceInviteCountAggregateOutputType | null
    _min: WorkspaceInviteMinAggregateOutputType | null
    _max: WorkspaceInviteMaxAggregateOutputType | null
  }

  type GetWorkspaceInviteGroupByPayload<T extends WorkspaceInviteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WorkspaceInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInviteGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInviteGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInviteSelect = {
    token?: boolean
    workspace?: boolean | WorkspaceArgs
    workspaceId?: boolean
    inviterId?: boolean
    isExpired?: boolean
    inviteeEmail?: boolean
    isAccepted?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WorkspaceInviteInclude = {
    workspace?: boolean | WorkspaceArgs
    user?: boolean | UserArgs
  }

  export type WorkspaceInviteGetPayload<S extends boolean | null | undefined | WorkspaceInviteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkspaceInvite :
    S extends undefined ? never :
    S extends { include: any } & (WorkspaceInviteArgs | WorkspaceInviteFindManyArgs)
    ? WorkspaceInvite  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkspaceInviteArgs | WorkspaceInviteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof WorkspaceInvite ? WorkspaceInvite[P] : never
  } 
      : WorkspaceInvite


  type WorkspaceInviteCountArgs = 
    Omit<WorkspaceInviteFindManyArgs, 'select' | 'include'> & {
      select?: WorkspaceInviteCountAggregateInputType | true
    }

  export interface WorkspaceInviteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WorkspaceInvite that matches the filter.
     * @param {WorkspaceInviteFindUniqueArgs} args - Arguments to find a WorkspaceInvite
     * @example
     * // Get one WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkspaceInviteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkspaceInviteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkspaceInvite'> extends True ? Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>> : Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T> | null, null>

    /**
     * Find one WorkspaceInvite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkspaceInviteFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvite
     * @example
     * // Get one WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkspaceInviteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceInviteFindUniqueOrThrowArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Find the first WorkspaceInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteFindFirstArgs} args - Arguments to find a WorkspaceInvite
     * @example
     * // Get one WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkspaceInviteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkspaceInviteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkspaceInvite'> extends True ? Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>> : Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T> | null, null>

    /**
     * Find the first WorkspaceInvite that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvite
     * @example
     * // Get one WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkspaceInviteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceInviteFindFirstOrThrowArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Find zero or more WorkspaceInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvites
     * const workspaceInvites = await prisma.workspaceInvite.findMany()
     * 
     * // Get first 10 WorkspaceInvites
     * const workspaceInvites = await prisma.workspaceInvite.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const workspaceInviteWithTokenOnly = await prisma.workspaceInvite.findMany({ select: { token: true } })
     * 
    **/
    findMany<T extends WorkspaceInviteFindManyArgs>(
      args?: SelectSubset<T, WorkspaceInviteFindManyArgs>
    ): PrismaPromise<Array<WorkspaceInviteGetPayload<T>>>

    /**
     * Create a WorkspaceInvite.
     * @param {WorkspaceInviteCreateArgs} args - Arguments to create a WorkspaceInvite.
     * @example
     * // Create one WorkspaceInvite
     * const WorkspaceInvite = await prisma.workspaceInvite.create({
     *   data: {
     *     // ... data to create a WorkspaceInvite
     *   }
     * })
     * 
    **/
    create<T extends WorkspaceInviteCreateArgs>(
      args: SelectSubset<T, WorkspaceInviteCreateArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Create many WorkspaceInvites.
     *     @param {WorkspaceInviteCreateManyArgs} args - Arguments to create many WorkspaceInvites.
     *     @example
     *     // Create many WorkspaceInvites
     *     const workspaceInvite = await prisma.workspaceInvite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkspaceInviteCreateManyArgs>(
      args?: SelectSubset<T, WorkspaceInviteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkspaceInvite.
     * @param {WorkspaceInviteDeleteArgs} args - Arguments to delete one WorkspaceInvite.
     * @example
     * // Delete one WorkspaceInvite
     * const WorkspaceInvite = await prisma.workspaceInvite.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvite
     *   }
     * })
     * 
    **/
    delete<T extends WorkspaceInviteDeleteArgs>(
      args: SelectSubset<T, WorkspaceInviteDeleteArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Update one WorkspaceInvite.
     * @param {WorkspaceInviteUpdateArgs} args - Arguments to update one WorkspaceInvite.
     * @example
     * // Update one WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkspaceInviteUpdateArgs>(
      args: SelectSubset<T, WorkspaceInviteUpdateArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Delete zero or more WorkspaceInvites.
     * @param {WorkspaceInviteDeleteManyArgs} args - Arguments to filter WorkspaceInvites to delete.
     * @example
     * // Delete a few WorkspaceInvites
     * const { count } = await prisma.workspaceInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkspaceInviteDeleteManyArgs>(
      args?: SelectSubset<T, WorkspaceInviteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvites
     * const workspaceInvite = await prisma.workspaceInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkspaceInviteUpdateManyArgs>(
      args: SelectSubset<T, WorkspaceInviteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceInvite.
     * @param {WorkspaceInviteUpsertArgs} args - Arguments to update or create a WorkspaceInvite.
     * @example
     * // Update or create a WorkspaceInvite
     * const workspaceInvite = await prisma.workspaceInvite.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvite we want to update
     *   }
     * })
    **/
    upsert<T extends WorkspaceInviteUpsertArgs>(
      args: SelectSubset<T, WorkspaceInviteUpsertArgs>
    ): Prisma__WorkspaceInviteClient<WorkspaceInviteGetPayload<T>>

    /**
     * Count the number of WorkspaceInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteCountArgs} args - Arguments to filter WorkspaceInvites to count.
     * @example
     * // Count the number of WorkspaceInvites
     * const count = await prisma.workspaceInvite.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvites we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInviteCountArgs>(
      args?: Subset<T, WorkspaceInviteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInviteAggregateArgs>(args: Subset<T, WorkspaceInviteAggregateArgs>): PrismaPromise<GetWorkspaceInviteAggregateType<T>>

    /**
     * Group by WorkspaceInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInviteGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInviteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkspaceInviteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workspace<T extends WorkspaceArgs= {}>(args?: Subset<T, WorkspaceArgs>): Prisma__WorkspaceClient<WorkspaceGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WorkspaceInvite base type for findUnique actions
   */
  export type WorkspaceInviteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter, which WorkspaceInvite to fetch.
     */
    where: WorkspaceInviteWhereUniqueInput
  }

  /**
   * WorkspaceInvite findUnique
   */
  export interface WorkspaceInviteFindUniqueArgs extends WorkspaceInviteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkspaceInvite findUniqueOrThrow
   */
  export type WorkspaceInviteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter, which WorkspaceInvite to fetch.
     */
    where: WorkspaceInviteWhereUniqueInput
  }


  /**
   * WorkspaceInvite base type for findFirst actions
   */
  export type WorkspaceInviteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter, which WorkspaceInvite to fetch.
     */
    where?: WorkspaceInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvites to fetch.
     */
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvites.
     */
    cursor?: WorkspaceInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvites.
     */
    distinct?: Enumerable<WorkspaceInviteScalarFieldEnum>
  }

  /**
   * WorkspaceInvite findFirst
   */
  export interface WorkspaceInviteFindFirstArgs extends WorkspaceInviteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkspaceInvite findFirstOrThrow
   */
  export type WorkspaceInviteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter, which WorkspaceInvite to fetch.
     */
    where?: WorkspaceInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvites to fetch.
     */
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvites.
     */
    cursor?: WorkspaceInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvites.
     */
    distinct?: Enumerable<WorkspaceInviteScalarFieldEnum>
  }


  /**
   * WorkspaceInvite findMany
   */
  export type WorkspaceInviteFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter, which WorkspaceInvites to fetch.
     */
    where?: WorkspaceInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvites to fetch.
     */
    orderBy?: Enumerable<WorkspaceInviteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvites.
     */
    cursor?: WorkspaceInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvites.
     */
    skip?: number
    distinct?: Enumerable<WorkspaceInviteScalarFieldEnum>
  }


  /**
   * WorkspaceInvite create
   */
  export type WorkspaceInviteCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * The data needed to create a WorkspaceInvite.
     */
    data: XOR<WorkspaceInviteCreateInput, WorkspaceInviteUncheckedCreateInput>
  }


  /**
   * WorkspaceInvite createMany
   */
  export type WorkspaceInviteCreateManyArgs = {
    /**
     * The data used to create many WorkspaceInvites.
     */
    data: Enumerable<WorkspaceInviteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkspaceInvite update
   */
  export type WorkspaceInviteUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * The data needed to update a WorkspaceInvite.
     */
    data: XOR<WorkspaceInviteUpdateInput, WorkspaceInviteUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvite to update.
     */
    where: WorkspaceInviteWhereUniqueInput
  }


  /**
   * WorkspaceInvite updateMany
   */
  export type WorkspaceInviteUpdateManyArgs = {
    /**
     * The data used to update WorkspaceInvites.
     */
    data: XOR<WorkspaceInviteUpdateManyMutationInput, WorkspaceInviteUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvites to update
     */
    where?: WorkspaceInviteWhereInput
  }


  /**
   * WorkspaceInvite upsert
   */
  export type WorkspaceInviteUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * The filter to search for the WorkspaceInvite to update in case it exists.
     */
    where: WorkspaceInviteWhereUniqueInput
    /**
     * In case the WorkspaceInvite found by the `where` argument doesn't exist, create a new WorkspaceInvite with this data.
     */
    create: XOR<WorkspaceInviteCreateInput, WorkspaceInviteUncheckedCreateInput>
    /**
     * In case the WorkspaceInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInviteUpdateInput, WorkspaceInviteUncheckedUpdateInput>
  }


  /**
   * WorkspaceInvite delete
   */
  export type WorkspaceInviteDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
    /**
     * Filter which WorkspaceInvite to delete.
     */
    where: WorkspaceInviteWhereUniqueInput
  }


  /**
   * WorkspaceInvite deleteMany
   */
  export type WorkspaceInviteDeleteManyArgs = {
    /**
     * Filter which WorkspaceInvites to delete
     */
    where?: WorkspaceInviteWhereInput
  }


  /**
   * WorkspaceInvite without action
   */
  export type WorkspaceInviteArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceInvite
     */
    select?: WorkspaceInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceInviteInclude | null
  }



  /**
   * Model WorkspaceRole
   */


  export type AggregateWorkspaceRole = {
    _count: WorkspaceRoleCountAggregateOutputType | null
    _min: WorkspaceRoleMinAggregateOutputType | null
    _max: WorkspaceRoleMaxAggregateOutputType | null
  }

  export type WorkspaceRoleMinAggregateOutputType = {
    userId: string | null
    workspaceId: string | null
    type: RoleType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceRoleMaxAggregateOutputType = {
    userId: string | null
    workspaceId: string | null
    type: RoleType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceRoleCountAggregateOutputType = {
    userId: number
    workspaceId: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceRoleMinAggregateInputType = {
    userId?: true
    workspaceId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceRoleMaxAggregateInputType = {
    userId?: true
    workspaceId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceRoleCountAggregateInputType = {
    userId?: true
    workspaceId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceRoleAggregateArgs = {
    /**
     * Filter which WorkspaceRole to aggregate.
     */
    where?: WorkspaceRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceRoles to fetch.
     */
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceRoles
    **/
    _count?: true | WorkspaceRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceRoleMaxAggregateInputType
  }

  export type GetWorkspaceRoleAggregateType<T extends WorkspaceRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceRole[P]>
      : GetScalarType<T[P], AggregateWorkspaceRole[P]>
  }




  export type WorkspaceRoleGroupByArgs = {
    where?: WorkspaceRoleWhereInput
    orderBy?: Enumerable<WorkspaceRoleOrderByWithAggregationInput>
    by: WorkspaceRoleScalarFieldEnum[]
    having?: WorkspaceRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceRoleCountAggregateInputType | true
    _min?: WorkspaceRoleMinAggregateInputType
    _max?: WorkspaceRoleMaxAggregateInputType
  }


  export type WorkspaceRoleGroupByOutputType = {
    userId: string
    workspaceId: string
    type: RoleType
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceRoleCountAggregateOutputType | null
    _min: WorkspaceRoleMinAggregateOutputType | null
    _max: WorkspaceRoleMaxAggregateOutputType | null
  }

  type GetWorkspaceRoleGroupByPayload<T extends WorkspaceRoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WorkspaceRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceRoleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceRoleGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceRoleSelect = {
    userId?: boolean
    user?: boolean | UserArgs
    workspaceId?: boolean
    workspace?: boolean | WorkspaceArgs
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WorkspaceRoleInclude = {
    user?: boolean | UserArgs
    workspace?: boolean | WorkspaceArgs
  }

  export type WorkspaceRoleGetPayload<S extends boolean | null | undefined | WorkspaceRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkspaceRole :
    S extends undefined ? never :
    S extends { include: any } & (WorkspaceRoleArgs | WorkspaceRoleFindManyArgs)
    ? WorkspaceRole  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkspaceRoleArgs | WorkspaceRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :  P extends keyof WorkspaceRole ? WorkspaceRole[P] : never
  } 
      : WorkspaceRole


  type WorkspaceRoleCountArgs = 
    Omit<WorkspaceRoleFindManyArgs, 'select' | 'include'> & {
      select?: WorkspaceRoleCountAggregateInputType | true
    }

  export interface WorkspaceRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WorkspaceRole that matches the filter.
     * @param {WorkspaceRoleFindUniqueArgs} args - Arguments to find a WorkspaceRole
     * @example
     * // Get one WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkspaceRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkspaceRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkspaceRole'> extends True ? Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>> : Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T> | null, null>

    /**
     * Find one WorkspaceRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkspaceRoleFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceRole
     * @example
     * // Get one WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkspaceRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceRoleFindUniqueOrThrowArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Find the first WorkspaceRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleFindFirstArgs} args - Arguments to find a WorkspaceRole
     * @example
     * // Get one WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkspaceRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkspaceRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkspaceRole'> extends True ? Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>> : Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T> | null, null>

    /**
     * Find the first WorkspaceRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleFindFirstOrThrowArgs} args - Arguments to find a WorkspaceRole
     * @example
     * // Get one WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkspaceRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkspaceRoleFindFirstOrThrowArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Find zero or more WorkspaceRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceRoles
     * const workspaceRoles = await prisma.workspaceRole.findMany()
     * 
     * // Get first 10 WorkspaceRoles
     * const workspaceRoles = await prisma.workspaceRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const workspaceRoleWithUserIdOnly = await prisma.workspaceRole.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends WorkspaceRoleFindManyArgs>(
      args?: SelectSubset<T, WorkspaceRoleFindManyArgs>
    ): PrismaPromise<Array<WorkspaceRoleGetPayload<T>>>

    /**
     * Create a WorkspaceRole.
     * @param {WorkspaceRoleCreateArgs} args - Arguments to create a WorkspaceRole.
     * @example
     * // Create one WorkspaceRole
     * const WorkspaceRole = await prisma.workspaceRole.create({
     *   data: {
     *     // ... data to create a WorkspaceRole
     *   }
     * })
     * 
    **/
    create<T extends WorkspaceRoleCreateArgs>(
      args: SelectSubset<T, WorkspaceRoleCreateArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Create many WorkspaceRoles.
     *     @param {WorkspaceRoleCreateManyArgs} args - Arguments to create many WorkspaceRoles.
     *     @example
     *     // Create many WorkspaceRoles
     *     const workspaceRole = await prisma.workspaceRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkspaceRoleCreateManyArgs>(
      args?: SelectSubset<T, WorkspaceRoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkspaceRole.
     * @param {WorkspaceRoleDeleteArgs} args - Arguments to delete one WorkspaceRole.
     * @example
     * // Delete one WorkspaceRole
     * const WorkspaceRole = await prisma.workspaceRole.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceRole
     *   }
     * })
     * 
    **/
    delete<T extends WorkspaceRoleDeleteArgs>(
      args: SelectSubset<T, WorkspaceRoleDeleteArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Update one WorkspaceRole.
     * @param {WorkspaceRoleUpdateArgs} args - Arguments to update one WorkspaceRole.
     * @example
     * // Update one WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkspaceRoleUpdateArgs>(
      args: SelectSubset<T, WorkspaceRoleUpdateArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Delete zero or more WorkspaceRoles.
     * @param {WorkspaceRoleDeleteManyArgs} args - Arguments to filter WorkspaceRoles to delete.
     * @example
     * // Delete a few WorkspaceRoles
     * const { count } = await prisma.workspaceRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkspaceRoleDeleteManyArgs>(
      args?: SelectSubset<T, WorkspaceRoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceRoles
     * const workspaceRole = await prisma.workspaceRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkspaceRoleUpdateManyArgs>(
      args: SelectSubset<T, WorkspaceRoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceRole.
     * @param {WorkspaceRoleUpsertArgs} args - Arguments to update or create a WorkspaceRole.
     * @example
     * // Update or create a WorkspaceRole
     * const workspaceRole = await prisma.workspaceRole.upsert({
     *   create: {
     *     // ... data to create a WorkspaceRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceRole we want to update
     *   }
     * })
    **/
    upsert<T extends WorkspaceRoleUpsertArgs>(
      args: SelectSubset<T, WorkspaceRoleUpsertArgs>
    ): Prisma__WorkspaceRoleClient<WorkspaceRoleGetPayload<T>>

    /**
     * Count the number of WorkspaceRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleCountArgs} args - Arguments to filter WorkspaceRoles to count.
     * @example
     * // Count the number of WorkspaceRoles
     * const count = await prisma.workspaceRole.count({
     *   where: {
     *     // ... the filter for the WorkspaceRoles we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceRoleCountArgs>(
      args?: Subset<T, WorkspaceRoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceRoleAggregateArgs>(args: Subset<T, WorkspaceRoleAggregateArgs>): PrismaPromise<GetWorkspaceRoleAggregateType<T>>

    /**
     * Group by WorkspaceRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceRoleGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkspaceRoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    workspace<T extends WorkspaceArgs= {}>(args?: Subset<T, WorkspaceArgs>): Prisma__WorkspaceClient<WorkspaceGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WorkspaceRole base type for findUnique actions
   */
  export type WorkspaceRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter, which WorkspaceRole to fetch.
     */
    where: WorkspaceRoleWhereUniqueInput
  }

  /**
   * WorkspaceRole findUnique
   */
  export interface WorkspaceRoleFindUniqueArgs extends WorkspaceRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkspaceRole findUniqueOrThrow
   */
  export type WorkspaceRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter, which WorkspaceRole to fetch.
     */
    where: WorkspaceRoleWhereUniqueInput
  }


  /**
   * WorkspaceRole base type for findFirst actions
   */
  export type WorkspaceRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter, which WorkspaceRole to fetch.
     */
    where?: WorkspaceRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceRoles to fetch.
     */
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceRoles.
     */
    cursor?: WorkspaceRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceRoles.
     */
    distinct?: Enumerable<WorkspaceRoleScalarFieldEnum>
  }

  /**
   * WorkspaceRole findFirst
   */
  export interface WorkspaceRoleFindFirstArgs extends WorkspaceRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkspaceRole findFirstOrThrow
   */
  export type WorkspaceRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter, which WorkspaceRole to fetch.
     */
    where?: WorkspaceRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceRoles to fetch.
     */
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceRoles.
     */
    cursor?: WorkspaceRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceRoles.
     */
    distinct?: Enumerable<WorkspaceRoleScalarFieldEnum>
  }


  /**
   * WorkspaceRole findMany
   */
  export type WorkspaceRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter, which WorkspaceRoles to fetch.
     */
    where?: WorkspaceRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceRoles to fetch.
     */
    orderBy?: Enumerable<WorkspaceRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceRoles.
     */
    cursor?: WorkspaceRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceRoles.
     */
    skip?: number
    distinct?: Enumerable<WorkspaceRoleScalarFieldEnum>
  }


  /**
   * WorkspaceRole create
   */
  export type WorkspaceRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * The data needed to create a WorkspaceRole.
     */
    data: XOR<WorkspaceRoleCreateInput, WorkspaceRoleUncheckedCreateInput>
  }


  /**
   * WorkspaceRole createMany
   */
  export type WorkspaceRoleCreateManyArgs = {
    /**
     * The data used to create many WorkspaceRoles.
     */
    data: Enumerable<WorkspaceRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkspaceRole update
   */
  export type WorkspaceRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * The data needed to update a WorkspaceRole.
     */
    data: XOR<WorkspaceRoleUpdateInput, WorkspaceRoleUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceRole to update.
     */
    where: WorkspaceRoleWhereUniqueInput
  }


  /**
   * WorkspaceRole updateMany
   */
  export type WorkspaceRoleUpdateManyArgs = {
    /**
     * The data used to update WorkspaceRoles.
     */
    data: XOR<WorkspaceRoleUpdateManyMutationInput, WorkspaceRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceRoles to update
     */
    where?: WorkspaceRoleWhereInput
  }


  /**
   * WorkspaceRole upsert
   */
  export type WorkspaceRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * The filter to search for the WorkspaceRole to update in case it exists.
     */
    where: WorkspaceRoleWhereUniqueInput
    /**
     * In case the WorkspaceRole found by the `where` argument doesn't exist, create a new WorkspaceRole with this data.
     */
    create: XOR<WorkspaceRoleCreateInput, WorkspaceRoleUncheckedCreateInput>
    /**
     * In case the WorkspaceRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceRoleUpdateInput, WorkspaceRoleUncheckedUpdateInput>
  }


  /**
   * WorkspaceRole delete
   */
  export type WorkspaceRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
    /**
     * Filter which WorkspaceRole to delete.
     */
    where: WorkspaceRoleWhereUniqueInput
  }


  /**
   * WorkspaceRole deleteMany
   */
  export type WorkspaceRoleDeleteManyArgs = {
    /**
     * Filter which WorkspaceRoles to delete
     */
    where?: WorkspaceRoleWhereInput
  }


  /**
   * WorkspaceRole without action
   */
  export type WorkspaceRoleArgs = {
    /**
     * Select specific fields to fetch from the WorkspaceRole
     */
    select?: WorkspaceRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkspaceRoleInclude | null
  }



  /**
   * Model Participant
   */


  export type AggregateParticipant = {
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  export type ParticipantMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ParticipantMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ParticipantCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ParticipantMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ParticipantMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ParticipantCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ParticipantAggregateArgs = {
    /**
     * Filter which Participant to aggregate.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: Enumerable<ParticipantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participants
    **/
    _count?: true | ParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantMaxAggregateInputType
  }

  export type GetParticipantAggregateType<T extends ParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipant[P]>
      : GetScalarType<T[P], AggregateParticipant[P]>
  }




  export type ParticipantGroupByArgs = {
    where?: ParticipantWhereInput
    orderBy?: Enumerable<ParticipantOrderByWithAggregationInput>
    by: ParticipantScalarFieldEnum[]
    having?: ParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantCountAggregateInputType | true
    _min?: ParticipantMinAggregateInputType
    _max?: ParticipantMaxAggregateInputType
  }


  export type ParticipantGroupByOutputType = {
    id: string
    name: string
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  type GetParticipantGroupByPayload<T extends ParticipantGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantSelect = {
    id?: boolean
    name?: boolean
    groups?: boolean | Participant$groupsArgs
    _count?: boolean | ParticipantCountOutputTypeArgs
  }


  export type ParticipantInclude = {
    groups?: boolean | Participant$groupsArgs
    _count?: boolean | ParticipantCountOutputTypeArgs
  }

  export type ParticipantGetPayload<S extends boolean | null | undefined | ParticipantArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Participant :
    S extends undefined ? never :
    S extends { include: any } & (ParticipantArgs | ParticipantFindManyArgs)
    ? Participant  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'groups' ? Array < TranscriptGroupGetPayload<S['include'][P]>>  :
        P extends '_count' ? ParticipantCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ParticipantArgs | ParticipantFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'groups' ? Array < TranscriptGroupGetPayload<S['select'][P]>>  :
        P extends '_count' ? ParticipantCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Participant ? Participant[P] : never
  } 
      : Participant


  type ParticipantCountArgs = 
    Omit<ParticipantFindManyArgs, 'select' | 'include'> & {
      select?: ParticipantCountAggregateInputType | true
    }

  export interface ParticipantDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Participant that matches the filter.
     * @param {ParticipantFindUniqueArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParticipantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParticipantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Participant'> extends True ? Prisma__ParticipantClient<ParticipantGetPayload<T>> : Prisma__ParticipantClient<ParticipantGetPayload<T> | null, null>

    /**
     * Find one Participant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParticipantFindUniqueOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParticipantFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ParticipantFindUniqueOrThrowArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Find the first Participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParticipantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParticipantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Participant'> extends True ? Prisma__ParticipantClient<ParticipantGetPayload<T>> : Prisma__ParticipantClient<ParticipantGetPayload<T> | null, null>

    /**
     * Find the first Participant that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParticipantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ParticipantFindFirstOrThrowArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Find zero or more Participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participant.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantWithIdOnly = await prisma.participant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParticipantFindManyArgs>(
      args?: SelectSubset<T, ParticipantFindManyArgs>
    ): PrismaPromise<Array<ParticipantGetPayload<T>>>

    /**
     * Create a Participant.
     * @param {ParticipantCreateArgs} args - Arguments to create a Participant.
     * @example
     * // Create one Participant
     * const Participant = await prisma.participant.create({
     *   data: {
     *     // ... data to create a Participant
     *   }
     * })
     * 
    **/
    create<T extends ParticipantCreateArgs>(
      args: SelectSubset<T, ParticipantCreateArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Create many Participants.
     *     @param {ParticipantCreateManyArgs} args - Arguments to create many Participants.
     *     @example
     *     // Create many Participants
     *     const participant = await prisma.participant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParticipantCreateManyArgs>(
      args?: SelectSubset<T, ParticipantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Participant.
     * @param {ParticipantDeleteArgs} args - Arguments to delete one Participant.
     * @example
     * // Delete one Participant
     * const Participant = await prisma.participant.delete({
     *   where: {
     *     // ... filter to delete one Participant
     *   }
     * })
     * 
    **/
    delete<T extends ParticipantDeleteArgs>(
      args: SelectSubset<T, ParticipantDeleteArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Update one Participant.
     * @param {ParticipantUpdateArgs} args - Arguments to update one Participant.
     * @example
     * // Update one Participant
     * const participant = await prisma.participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParticipantUpdateArgs>(
      args: SelectSubset<T, ParticipantUpdateArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Delete zero or more Participants.
     * @param {ParticipantDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParticipantDeleteManyArgs>(
      args?: SelectSubset<T, ParticipantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParticipantUpdateManyArgs>(
      args: SelectSubset<T, ParticipantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Participant.
     * @param {ParticipantUpsertArgs} args - Arguments to update or create a Participant.
     * @example
     * // Update or create a Participant
     * const participant = await prisma.participant.upsert({
     *   create: {
     *     // ... data to create a Participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participant we want to update
     *   }
     * })
    **/
    upsert<T extends ParticipantUpsertArgs>(
      args: SelectSubset<T, ParticipantUpsertArgs>
    ): Prisma__ParticipantClient<ParticipantGetPayload<T>>

    /**
     * Count the number of Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participant.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends ParticipantCountArgs>(
      args?: Subset<T, ParticipantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantAggregateArgs>(args: Subset<T, ParticipantAggregateArgs>): PrismaPromise<GetParticipantAggregateType<T>>

    /**
     * Group by Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParticipantClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groups<T extends Participant$groupsArgs= {}>(args?: Subset<T, Participant$groupsArgs>): PrismaPromise<Array<TranscriptGroupGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Participant base type for findUnique actions
   */
  export type ParticipantFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findUnique
   */
  export interface ParticipantFindUniqueArgs extends ParticipantFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Participant findUniqueOrThrow
   */
  export type ParticipantFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant base type for findFirst actions
   */
  export type ParticipantFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: Enumerable<ParticipantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: Enumerable<ParticipantScalarFieldEnum>
  }

  /**
   * Participant findFirst
   */
  export interface ParticipantFindFirstArgs extends ParticipantFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Participant findFirstOrThrow
   */
  export type ParticipantFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: Enumerable<ParticipantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: Enumerable<ParticipantScalarFieldEnum>
  }


  /**
   * Participant findMany
   */
  export type ParticipantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter, which Participants to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: Enumerable<ParticipantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    distinct?: Enumerable<ParticipantScalarFieldEnum>
  }


  /**
   * Participant create
   */
  export type ParticipantCreateArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * The data needed to create a Participant.
     */
    data: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
  }


  /**
   * Participant createMany
   */
  export type ParticipantCreateManyArgs = {
    /**
     * The data used to create many Participants.
     */
    data: Enumerable<ParticipantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Participant update
   */
  export type ParticipantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * The data needed to update a Participant.
     */
    data: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
    /**
     * Choose, which Participant to update.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant updateMany
   */
  export type ParticipantUpdateManyArgs = {
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
  }


  /**
   * Participant upsert
   */
  export type ParticipantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * The filter to search for the Participant to update in case it exists.
     */
    where: ParticipantWhereUniqueInput
    /**
     * In case the Participant found by the `where` argument doesn't exist, create a new Participant with this data.
     */
    create: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
    /**
     * In case the Participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
  }


  /**
   * Participant delete
   */
  export type ParticipantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
    /**
     * Filter which Participant to delete.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant deleteMany
   */
  export type ParticipantDeleteManyArgs = {
    /**
     * Filter which Participants to delete
     */
    where?: ParticipantWhereInput
  }


  /**
   * Participant.groups
   */
  export type Participant$groupsArgs = {
    /**
     * Select specific fields to fetch from the TranscriptGroup
     */
    select?: TranscriptGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TranscriptGroupInclude | null
    where?: TranscriptGroupWhereInput
    orderBy?: Enumerable<TranscriptGroupOrderByWithRelationInput>
    cursor?: TranscriptGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TranscriptGroupScalarFieldEnum>
  }


  /**
   * Participant without action
   */
  export type ParticipantArgs = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: TagColor | null
    workspaceId: string | null
    autoExtract: boolean | null
    description: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    emoji: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: TagColor | null
    workspaceId: string | null
    autoExtract: boolean | null
    description: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    emoji: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    workspaceId: number
    autoExtract: number
    description: number
    isDefault: number
    createdAt: number
    updatedAt: number
    emoji: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    workspaceId?: true
    autoExtract?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    emoji?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    workspaceId?: true
    autoExtract?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    emoji?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    workspaceId?: true
    autoExtract?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    emoji?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: TagScalarFieldEnum[]
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: string
    name: string
    color: TagColor
    workspaceId: string
    autoExtract: boolean
    description: string | null
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    emoji: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect = {
    id?: boolean
    name?: boolean
    color?: boolean
    workspace?: boolean | WorkspaceArgs
    workspaceId?: boolean
    highlights?: boolean | Tag$highlightsArgs
    suggestedHighlights?: boolean | Tag$suggestedHighlightsArgs
    userOrders?: boolean | Tag$userOrdersArgs
    autoExtract?: boolean
    description?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectTags?: boolean | Tag$projectTagsArgs
    emoji?: boolean
    _count?: boolean | TagCountOutputTypeArgs
  }


  export type TagInclude = {
    workspace?: boolean | WorkspaceArgs
    highlights?: boolean | Tag$highlightsArgs
    suggestedHighlights?: boolean | Tag$suggestedHighlightsArgs
    userOrders?: boolean | Tag$userOrdersArgs
    projectTags?: boolean | Tag$projectTagsArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagGetPayload<S extends boolean | null | undefined | TagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tag :
    S extends undefined ? never :
    S extends { include: any } & (TagArgs | TagFindManyArgs)
    ? Tag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
        P extends 'highlights' ? Array < HighlightGetPayload<S['include'][P]>>  :
        P extends 'suggestedHighlights' ? Array < SuggestedHighlightGetPayload<S['include'][P]>>  :
        P extends 'userOrders' ? Array < UserTagOrderGetPayload<S['include'][P]>>  :
        P extends 'projectTags' ? Array < ProjectTagsGetPayload<S['include'][P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TagArgs | TagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
        P extends 'highlights' ? Array < HighlightGetPayload<S['select'][P]>>  :
        P extends 'suggestedHighlights' ? Array < SuggestedHighlightGetPayload<S['select'][P]>>  :
        P extends 'userOrders' ? Array < UserTagOrderGetPayload<S['select'][P]>>  :
        P extends 'projectTags' ? Array < ProjectTagsGetPayload<S['select'][P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tag ? Tag[P] : never
  } 
      : Tag


  type TagCountArgs = 
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? Prisma__TagClient<TagGetPayload<T>> : Prisma__TagClient<TagGetPayload<T> | null, null>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? Prisma__TagClient<TagGetPayload<T>> : Prisma__TagClient<TagGetPayload<T> | null, null>

    /**
     * Find the first Tag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): PrismaPromise<Array<TagGetPayload<T>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workspace<T extends WorkspaceArgs= {}>(args?: Subset<T, WorkspaceArgs>): Prisma__WorkspaceClient<WorkspaceGetPayload<T> | Null>;

    highlights<T extends Tag$highlightsArgs= {}>(args?: Subset<T, Tag$highlightsArgs>): PrismaPromise<Array<HighlightGetPayload<T>>| Null>;

    suggestedHighlights<T extends Tag$suggestedHighlightsArgs= {}>(args?: Subset<T, Tag$suggestedHighlightsArgs>): PrismaPromise<Array<SuggestedHighlightGetPayload<T>>| Null>;

    userOrders<T extends Tag$userOrdersArgs= {}>(args?: Subset<T, Tag$userOrdersArgs>): PrismaPromise<Array<UserTagOrderGetPayload<T>>| Null>;

    projectTags<T extends Tag$projectTagsArgs= {}>(args?: Subset<T, Tag$projectTagsArgs>): PrismaPromise<Array<ProjectTagsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tag base type for findUnique actions
   */
  export type TagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUnique
   */
  export interface TagFindUniqueArgs extends TagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag base type for findFirst actions
   */
  export type TagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }

  /**
   * Tag findFirst
   */
  export interface TagFindFirstArgs extends TagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    /**
     * The data used to create many Tags.
     */
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.highlights
   */
  export type Tag$highlightsArgs = {
    /**
     * Select specific fields to fetch from the Highlight
     */
    select?: HighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HighlightInclude | null
    where?: HighlightWhereInput
    orderBy?: Enumerable<HighlightOrderByWithRelationInput>
    cursor?: HighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HighlightScalarFieldEnum>
  }


  /**
   * Tag.suggestedHighlights
   */
  export type Tag$suggestedHighlightsArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    where?: SuggestedHighlightWhereInput
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    cursor?: SuggestedHighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SuggestedHighlightScalarFieldEnum>
  }


  /**
   * Tag.userOrders
   */
  export type Tag$userOrdersArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    where?: UserTagOrderWhereInput
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    cursor?: UserTagOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserTagOrderScalarFieldEnum>
  }


  /**
   * Tag.projectTags
   */
  export type Tag$projectTagsArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    where?: ProjectTagsWhereInput
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    cursor?: ProjectTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectTagsScalarFieldEnum>
  }


  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
  }



  /**
   * Model NotificationPreferences
   */


  export type AggregateNotificationPreferences = {
    _count: NotificationPreferencesCountAggregateOutputType | null
    _min: NotificationPreferencesMinAggregateOutputType | null
    _max: NotificationPreferencesMaxAggregateOutputType | null
  }

  export type NotificationPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationEmails: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationEmails: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    notificationEmails: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    notificationEmails?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationEmails?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    notificationEmails?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferencesAggregateArgs = {
    /**
     * Filter which NotificationPreferences to aggregate.
     */
    where?: NotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferencesMaxAggregateInputType
  }

  export type GetNotificationPreferencesAggregateType<T extends NotificationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreferences[P]>
      : GetScalarType<T[P], AggregateNotificationPreferences[P]>
  }




  export type NotificationPreferencesGroupByArgs = {
    where?: NotificationPreferencesWhereInput
    orderBy?: Enumerable<NotificationPreferencesOrderByWithAggregationInput>
    by: NotificationPreferencesScalarFieldEnum[]
    having?: NotificationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferencesCountAggregateInputType | true
    _min?: NotificationPreferencesMinAggregateInputType
    _max?: NotificationPreferencesMaxAggregateInputType
  }


  export type NotificationPreferencesGroupByOutputType = {
    id: string
    userId: string
    notificationEmails: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferencesCountAggregateOutputType | null
    _min: NotificationPreferencesMinAggregateOutputType | null
    _max: NotificationPreferencesMaxAggregateOutputType | null
  }

  type GetNotificationPreferencesGroupByPayload<T extends NotificationPreferencesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferencesSelect = {
    id?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    notificationEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type NotificationPreferencesInclude = {
    user?: boolean | UserArgs
  }

  export type NotificationPreferencesGetPayload<S extends boolean | null | undefined | NotificationPreferencesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NotificationPreferences :
    S extends undefined ? never :
    S extends { include: any } & (NotificationPreferencesArgs | NotificationPreferencesFindManyArgs)
    ? NotificationPreferences  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NotificationPreferencesArgs | NotificationPreferencesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof NotificationPreferences ? NotificationPreferences[P] : never
  } 
      : NotificationPreferences


  type NotificationPreferencesCountArgs = 
    Omit<NotificationPreferencesFindManyArgs, 'select' | 'include'> & {
      select?: NotificationPreferencesCountAggregateInputType | true
    }

  export interface NotificationPreferencesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NotificationPreferences that matches the filter.
     * @param {NotificationPreferencesFindUniqueArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationPreferencesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationPreferencesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NotificationPreferences'> extends True ? Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>> : Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T> | null, null>

    /**
     * Find one NotificationPreferences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationPreferencesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationPreferencesFindUniqueOrThrowArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Find the first NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesFindFirstArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationPreferencesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationPreferencesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NotificationPreferences'> extends True ? Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>> : Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T> | null, null>

    /**
     * Find the first NotificationPreferences that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesFindFirstOrThrowArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationPreferencesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationPreferencesFindFirstOrThrowArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferencesWithIdOnly = await prisma.notificationPreferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationPreferencesFindManyArgs>(
      args?: SelectSubset<T, NotificationPreferencesFindManyArgs>
    ): PrismaPromise<Array<NotificationPreferencesGetPayload<T>>>

    /**
     * Create a NotificationPreferences.
     * @param {NotificationPreferencesCreateArgs} args - Arguments to create a NotificationPreferences.
     * @example
     * // Create one NotificationPreferences
     * const NotificationPreferences = await prisma.notificationPreferences.create({
     *   data: {
     *     // ... data to create a NotificationPreferences
     *   }
     * })
     * 
    **/
    create<T extends NotificationPreferencesCreateArgs>(
      args: SelectSubset<T, NotificationPreferencesCreateArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Create many NotificationPreferences.
     *     @param {NotificationPreferencesCreateManyArgs} args - Arguments to create many NotificationPreferences.
     *     @example
     *     // Create many NotificationPreferences
     *     const notificationPreferences = await prisma.notificationPreferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationPreferencesCreateManyArgs>(
      args?: SelectSubset<T, NotificationPreferencesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationPreferences.
     * @param {NotificationPreferencesDeleteArgs} args - Arguments to delete one NotificationPreferences.
     * @example
     * // Delete one NotificationPreferences
     * const NotificationPreferences = await prisma.notificationPreferences.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreferences
     *   }
     * })
     * 
    **/
    delete<T extends NotificationPreferencesDeleteArgs>(
      args: SelectSubset<T, NotificationPreferencesDeleteArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Update one NotificationPreferences.
     * @param {NotificationPreferencesUpdateArgs} args - Arguments to update one NotificationPreferences.
     * @example
     * // Update one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationPreferencesUpdateArgs>(
      args: SelectSubset<T, NotificationPreferencesUpdateArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferencesDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationPreferencesDeleteManyArgs>(
      args?: SelectSubset<T, NotificationPreferencesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationPreferencesUpdateManyArgs>(
      args: SelectSubset<T, NotificationPreferencesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreferences.
     * @param {NotificationPreferencesUpsertArgs} args - Arguments to update or create a NotificationPreferences.
     * @example
     * // Update or create a NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.upsert({
     *   create: {
     *     // ... data to create a NotificationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationPreferencesUpsertArgs>(
      args: SelectSubset<T, NotificationPreferencesUpsertArgs>
    ): Prisma__NotificationPreferencesClient<NotificationPreferencesGetPayload<T>>

    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreferences.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferencesCountArgs>(
      args?: Subset<T, NotificationPreferencesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferencesAggregateArgs>(args: Subset<T, NotificationPreferencesAggregateArgs>): PrismaPromise<GetNotificationPreferencesAggregateType<T>>

    /**
     * Group by NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferencesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationPreferencesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NotificationPreferences base type for findUnique actions
   */
  export type NotificationPreferencesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where: NotificationPreferencesWhereUniqueInput
  }

  /**
   * NotificationPreferences findUnique
   */
  export interface NotificationPreferencesFindUniqueArgs extends NotificationPreferencesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotificationPreferences findUniqueOrThrow
   */
  export type NotificationPreferencesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where: NotificationPreferencesWhereUniqueInput
  }


  /**
   * NotificationPreferences base type for findFirst actions
   */
  export type NotificationPreferencesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: Enumerable<NotificationPreferencesScalarFieldEnum>
  }

  /**
   * NotificationPreferences findFirst
   */
  export interface NotificationPreferencesFindFirstArgs extends NotificationPreferencesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotificationPreferences findFirstOrThrow
   */
  export type NotificationPreferencesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: Enumerable<NotificationPreferencesScalarFieldEnum>
  }


  /**
   * NotificationPreferences findMany
   */
  export type NotificationPreferencesFindManyArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: Enumerable<NotificationPreferencesScalarFieldEnum>
  }


  /**
   * NotificationPreferences create
   */
  export type NotificationPreferencesCreateArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * The data needed to create a NotificationPreferences.
     */
    data: XOR<NotificationPreferencesCreateInput, NotificationPreferencesUncheckedCreateInput>
  }


  /**
   * NotificationPreferences createMany
   */
  export type NotificationPreferencesCreateManyArgs = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: Enumerable<NotificationPreferencesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NotificationPreferences update
   */
  export type NotificationPreferencesUpdateArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * The data needed to update a NotificationPreferences.
     */
    data: XOR<NotificationPreferencesUpdateInput, NotificationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreferences to update.
     */
    where: NotificationPreferencesWhereUniqueInput
  }


  /**
   * NotificationPreferences updateMany
   */
  export type NotificationPreferencesUpdateManyArgs = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferencesUpdateManyMutationInput, NotificationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferencesWhereInput
  }


  /**
   * NotificationPreferences upsert
   */
  export type NotificationPreferencesUpsertArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * The filter to search for the NotificationPreferences to update in case it exists.
     */
    where: NotificationPreferencesWhereUniqueInput
    /**
     * In case the NotificationPreferences found by the `where` argument doesn't exist, create a new NotificationPreferences with this data.
     */
    create: XOR<NotificationPreferencesCreateInput, NotificationPreferencesUncheckedCreateInput>
    /**
     * In case the NotificationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferencesUpdateInput, NotificationPreferencesUncheckedUpdateInput>
  }


  /**
   * NotificationPreferences delete
   */
  export type NotificationPreferencesDeleteArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
    /**
     * Filter which NotificationPreferences to delete.
     */
    where: NotificationPreferencesWhereUniqueInput
  }


  /**
   * NotificationPreferences deleteMany
   */
  export type NotificationPreferencesDeleteManyArgs = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferencesWhereInput
  }


  /**
   * NotificationPreferences without action
   */
  export type NotificationPreferencesArgs = {
    /**
     * Select specific fields to fetch from the NotificationPreferences
     */
    select?: NotificationPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferencesInclude | null
  }



  /**
   * Model UserTagOrder
   */


  export type AggregateUserTagOrder = {
    _count: UserTagOrderCountAggregateOutputType | null
    _avg: UserTagOrderAvgAggregateOutputType | null
    _sum: UserTagOrderSumAggregateOutputType | null
    _min: UserTagOrderMinAggregateOutputType | null
    _max: UserTagOrderMaxAggregateOutputType | null
  }

  export type UserTagOrderAvgAggregateOutputType = {
    position: number | null
  }

  export type UserTagOrderSumAggregateOutputType = {
    position: number | null
  }

  export type UserTagOrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tagId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagOrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tagId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagOrderCountAggregateOutputType = {
    id: number
    userId: number
    tagId: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTagOrderAvgAggregateInputType = {
    position?: true
  }

  export type UserTagOrderSumAggregateInputType = {
    position?: true
  }

  export type UserTagOrderMinAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagOrderCountAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTagOrderAggregateArgs = {
    /**
     * Filter which UserTagOrder to aggregate.
     */
    where?: UserTagOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTagOrders to fetch.
     */
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTagOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTagOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTagOrders
    **/
    _count?: true | UserTagOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTagOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTagOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagOrderMaxAggregateInputType
  }

  export type GetUserTagOrderAggregateType<T extends UserTagOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTagOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTagOrder[P]>
      : GetScalarType<T[P], AggregateUserTagOrder[P]>
  }




  export type UserTagOrderGroupByArgs = {
    where?: UserTagOrderWhereInput
    orderBy?: Enumerable<UserTagOrderOrderByWithAggregationInput>
    by: UserTagOrderScalarFieldEnum[]
    having?: UserTagOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagOrderCountAggregateInputType | true
    _avg?: UserTagOrderAvgAggregateInputType
    _sum?: UserTagOrderSumAggregateInputType
    _min?: UserTagOrderMinAggregateInputType
    _max?: UserTagOrderMaxAggregateInputType
  }


  export type UserTagOrderGroupByOutputType = {
    id: string
    userId: string
    tagId: string
    position: number
    createdAt: Date
    updatedAt: Date
    _count: UserTagOrderCountAggregateOutputType | null
    _avg: UserTagOrderAvgAggregateOutputType | null
    _sum: UserTagOrderSumAggregateOutputType | null
    _min: UserTagOrderMinAggregateOutputType | null
    _max: UserTagOrderMaxAggregateOutputType | null
  }

  type GetUserTagOrderGroupByPayload<T extends UserTagOrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserTagOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagOrderGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagOrderGroupByOutputType[P]>
        }
      >
    >


  export type UserTagOrderSelect = {
    id?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    tagId?: boolean
    tag?: boolean | TagArgs
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserTagOrderInclude = {
    user?: boolean | UserArgs
    tag?: boolean | TagArgs
  }

  export type UserTagOrderGetPayload<S extends boolean | null | undefined | UserTagOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserTagOrder :
    S extends undefined ? never :
    S extends { include: any } & (UserTagOrderArgs | UserTagOrderFindManyArgs)
    ? UserTagOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'tag' ? TagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserTagOrderArgs | UserTagOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'tag' ? TagGetPayload<S['select'][P]> :  P extends keyof UserTagOrder ? UserTagOrder[P] : never
  } 
      : UserTagOrder


  type UserTagOrderCountArgs = 
    Omit<UserTagOrderFindManyArgs, 'select' | 'include'> & {
      select?: UserTagOrderCountAggregateInputType | true
    }

  export interface UserTagOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserTagOrder that matches the filter.
     * @param {UserTagOrderFindUniqueArgs} args - Arguments to find a UserTagOrder
     * @example
     * // Get one UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTagOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserTagOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserTagOrder'> extends True ? Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>> : Prisma__UserTagOrderClient<UserTagOrderGetPayload<T> | null, null>

    /**
     * Find one UserTagOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserTagOrderFindUniqueOrThrowArgs} args - Arguments to find a UserTagOrder
     * @example
     * // Get one UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserTagOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserTagOrderFindUniqueOrThrowArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Find the first UserTagOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderFindFirstArgs} args - Arguments to find a UserTagOrder
     * @example
     * // Get one UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTagOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserTagOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserTagOrder'> extends True ? Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>> : Prisma__UserTagOrderClient<UserTagOrderGetPayload<T> | null, null>

    /**
     * Find the first UserTagOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderFindFirstOrThrowArgs} args - Arguments to find a UserTagOrder
     * @example
     * // Get one UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserTagOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserTagOrderFindFirstOrThrowArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Find zero or more UserTagOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTagOrders
     * const userTagOrders = await prisma.userTagOrder.findMany()
     * 
     * // Get first 10 UserTagOrders
     * const userTagOrders = await prisma.userTagOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagOrderWithIdOnly = await prisma.userTagOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserTagOrderFindManyArgs>(
      args?: SelectSubset<T, UserTagOrderFindManyArgs>
    ): PrismaPromise<Array<UserTagOrderGetPayload<T>>>

    /**
     * Create a UserTagOrder.
     * @param {UserTagOrderCreateArgs} args - Arguments to create a UserTagOrder.
     * @example
     * // Create one UserTagOrder
     * const UserTagOrder = await prisma.userTagOrder.create({
     *   data: {
     *     // ... data to create a UserTagOrder
     *   }
     * })
     * 
    **/
    create<T extends UserTagOrderCreateArgs>(
      args: SelectSubset<T, UserTagOrderCreateArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Create many UserTagOrders.
     *     @param {UserTagOrderCreateManyArgs} args - Arguments to create many UserTagOrders.
     *     @example
     *     // Create many UserTagOrders
     *     const userTagOrder = await prisma.userTagOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTagOrderCreateManyArgs>(
      args?: SelectSubset<T, UserTagOrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserTagOrder.
     * @param {UserTagOrderDeleteArgs} args - Arguments to delete one UserTagOrder.
     * @example
     * // Delete one UserTagOrder
     * const UserTagOrder = await prisma.userTagOrder.delete({
     *   where: {
     *     // ... filter to delete one UserTagOrder
     *   }
     * })
     * 
    **/
    delete<T extends UserTagOrderDeleteArgs>(
      args: SelectSubset<T, UserTagOrderDeleteArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Update one UserTagOrder.
     * @param {UserTagOrderUpdateArgs} args - Arguments to update one UserTagOrder.
     * @example
     * // Update one UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTagOrderUpdateArgs>(
      args: SelectSubset<T, UserTagOrderUpdateArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Delete zero or more UserTagOrders.
     * @param {UserTagOrderDeleteManyArgs} args - Arguments to filter UserTagOrders to delete.
     * @example
     * // Delete a few UserTagOrders
     * const { count } = await prisma.userTagOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTagOrderDeleteManyArgs>(
      args?: SelectSubset<T, UserTagOrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTagOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTagOrders
     * const userTagOrder = await prisma.userTagOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTagOrderUpdateManyArgs>(
      args: SelectSubset<T, UserTagOrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTagOrder.
     * @param {UserTagOrderUpsertArgs} args - Arguments to update or create a UserTagOrder.
     * @example
     * // Update or create a UserTagOrder
     * const userTagOrder = await prisma.userTagOrder.upsert({
     *   create: {
     *     // ... data to create a UserTagOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTagOrder we want to update
     *   }
     * })
    **/
    upsert<T extends UserTagOrderUpsertArgs>(
      args: SelectSubset<T, UserTagOrderUpsertArgs>
    ): Prisma__UserTagOrderClient<UserTagOrderGetPayload<T>>

    /**
     * Count the number of UserTagOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderCountArgs} args - Arguments to filter UserTagOrders to count.
     * @example
     * // Count the number of UserTagOrders
     * const count = await prisma.userTagOrder.count({
     *   where: {
     *     // ... the filter for the UserTagOrders we want to count
     *   }
     * })
    **/
    count<T extends UserTagOrderCountArgs>(
      args?: Subset<T, UserTagOrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTagOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagOrderAggregateArgs>(args: Subset<T, UserTagOrderAggregateArgs>): PrismaPromise<GetUserTagOrderAggregateType<T>>

    /**
     * Group by UserTagOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagOrderGroupByArgs['orderBy'] }
        : { orderBy?: UserTagOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTagOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserTagOrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    tag<T extends TagArgs= {}>(args?: Subset<T, TagArgs>): Prisma__TagClient<TagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserTagOrder base type for findUnique actions
   */
  export type UserTagOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter, which UserTagOrder to fetch.
     */
    where: UserTagOrderWhereUniqueInput
  }

  /**
   * UserTagOrder findUnique
   */
  export interface UserTagOrderFindUniqueArgs extends UserTagOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserTagOrder findUniqueOrThrow
   */
  export type UserTagOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter, which UserTagOrder to fetch.
     */
    where: UserTagOrderWhereUniqueInput
  }


  /**
   * UserTagOrder base type for findFirst actions
   */
  export type UserTagOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter, which UserTagOrder to fetch.
     */
    where?: UserTagOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTagOrders to fetch.
     */
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTagOrders.
     */
    cursor?: UserTagOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTagOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTagOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTagOrders.
     */
    distinct?: Enumerable<UserTagOrderScalarFieldEnum>
  }

  /**
   * UserTagOrder findFirst
   */
  export interface UserTagOrderFindFirstArgs extends UserTagOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserTagOrder findFirstOrThrow
   */
  export type UserTagOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter, which UserTagOrder to fetch.
     */
    where?: UserTagOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTagOrders to fetch.
     */
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTagOrders.
     */
    cursor?: UserTagOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTagOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTagOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTagOrders.
     */
    distinct?: Enumerable<UserTagOrderScalarFieldEnum>
  }


  /**
   * UserTagOrder findMany
   */
  export type UserTagOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter, which UserTagOrders to fetch.
     */
    where?: UserTagOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTagOrders to fetch.
     */
    orderBy?: Enumerable<UserTagOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTagOrders.
     */
    cursor?: UserTagOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTagOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTagOrders.
     */
    skip?: number
    distinct?: Enumerable<UserTagOrderScalarFieldEnum>
  }


  /**
   * UserTagOrder create
   */
  export type UserTagOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * The data needed to create a UserTagOrder.
     */
    data: XOR<UserTagOrderCreateInput, UserTagOrderUncheckedCreateInput>
  }


  /**
   * UserTagOrder createMany
   */
  export type UserTagOrderCreateManyArgs = {
    /**
     * The data used to create many UserTagOrders.
     */
    data: Enumerable<UserTagOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserTagOrder update
   */
  export type UserTagOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * The data needed to update a UserTagOrder.
     */
    data: XOR<UserTagOrderUpdateInput, UserTagOrderUncheckedUpdateInput>
    /**
     * Choose, which UserTagOrder to update.
     */
    where: UserTagOrderWhereUniqueInput
  }


  /**
   * UserTagOrder updateMany
   */
  export type UserTagOrderUpdateManyArgs = {
    /**
     * The data used to update UserTagOrders.
     */
    data: XOR<UserTagOrderUpdateManyMutationInput, UserTagOrderUncheckedUpdateManyInput>
    /**
     * Filter which UserTagOrders to update
     */
    where?: UserTagOrderWhereInput
  }


  /**
   * UserTagOrder upsert
   */
  export type UserTagOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * The filter to search for the UserTagOrder to update in case it exists.
     */
    where: UserTagOrderWhereUniqueInput
    /**
     * In case the UserTagOrder found by the `where` argument doesn't exist, create a new UserTagOrder with this data.
     */
    create: XOR<UserTagOrderCreateInput, UserTagOrderUncheckedCreateInput>
    /**
     * In case the UserTagOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagOrderUpdateInput, UserTagOrderUncheckedUpdateInput>
  }


  /**
   * UserTagOrder delete
   */
  export type UserTagOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
    /**
     * Filter which UserTagOrder to delete.
     */
    where: UserTagOrderWhereUniqueInput
  }


  /**
   * UserTagOrder deleteMany
   */
  export type UserTagOrderDeleteManyArgs = {
    /**
     * Filter which UserTagOrders to delete
     */
    where?: UserTagOrderWhereInput
  }


  /**
   * UserTagOrder without action
   */
  export type UserTagOrderArgs = {
    /**
     * Select specific fields to fetch from the UserTagOrder
     */
    select?: UserTagOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTagOrderInclude | null
  }



  /**
   * Model SuggestedHighlight
   */


  export type AggregateSuggestedHighlight = {
    _count: SuggestedHighlightCountAggregateOutputType | null
    _min: SuggestedHighlightMinAggregateOutputType | null
    _max: SuggestedHighlightMaxAggregateOutputType | null
  }

  export type SuggestedHighlightMinAggregateOutputType = {
    id: string | null
    highlightedRangeId: string | null
    interviewId: string | null
    transcriptId: string | null
    status: SuggestedHighlightStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuggestedHighlightMaxAggregateOutputType = {
    id: string | null
    highlightedRangeId: string | null
    interviewId: string | null
    transcriptId: string | null
    status: SuggestedHighlightStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuggestedHighlightCountAggregateOutputType = {
    id: number
    highlightedRangeId: number
    interviewId: number
    transcriptId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuggestedHighlightMinAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    interviewId?: true
    transcriptId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuggestedHighlightMaxAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    interviewId?: true
    transcriptId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuggestedHighlightCountAggregateInputType = {
    id?: true
    highlightedRangeId?: true
    interviewId?: true
    transcriptId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuggestedHighlightAggregateArgs = {
    /**
     * Filter which SuggestedHighlight to aggregate.
     */
    where?: SuggestedHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedHighlights to fetch.
     */
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestedHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuggestedHighlights
    **/
    _count?: true | SuggestedHighlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestedHighlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestedHighlightMaxAggregateInputType
  }

  export type GetSuggestedHighlightAggregateType<T extends SuggestedHighlightAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestedHighlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestedHighlight[P]>
      : GetScalarType<T[P], AggregateSuggestedHighlight[P]>
  }




  export type SuggestedHighlightGroupByArgs = {
    where?: SuggestedHighlightWhereInput
    orderBy?: Enumerable<SuggestedHighlightOrderByWithAggregationInput>
    by: SuggestedHighlightScalarFieldEnum[]
    having?: SuggestedHighlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestedHighlightCountAggregateInputType | true
    _min?: SuggestedHighlightMinAggregateInputType
    _max?: SuggestedHighlightMaxAggregateInputType
  }


  export type SuggestedHighlightGroupByOutputType = {
    id: string
    highlightedRangeId: string
    interviewId: string
    transcriptId: string
    status: SuggestedHighlightStatus
    createdAt: Date
    updatedAt: Date
    _count: SuggestedHighlightCountAggregateOutputType | null
    _min: SuggestedHighlightMinAggregateOutputType | null
    _max: SuggestedHighlightMaxAggregateOutputType | null
  }

  type GetSuggestedHighlightGroupByPayload<T extends SuggestedHighlightGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SuggestedHighlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestedHighlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestedHighlightGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestedHighlightGroupByOutputType[P]>
        }
      >
    >


  export type SuggestedHighlightSelect = {
    id?: boolean
    highlightedRange?: boolean | WordRangeArgs
    highlightedRangeId?: boolean
    interview?: boolean | InterviewArgs
    interviewId?: boolean
    transcriptId?: boolean
    transcript?: boolean | TranscriptArgs
    tags?: boolean | SuggestedHighlight$tagsArgs
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highlight?: boolean | HighlightArgs
    _count?: boolean | SuggestedHighlightCountOutputTypeArgs
  }


  export type SuggestedHighlightInclude = {
    highlightedRange?: boolean | WordRangeArgs
    interview?: boolean | InterviewArgs
    transcript?: boolean | TranscriptArgs
    tags?: boolean | SuggestedHighlight$tagsArgs
    highlight?: boolean | HighlightArgs
    _count?: boolean | SuggestedHighlightCountOutputTypeArgs
  }

  export type SuggestedHighlightGetPayload<S extends boolean | null | undefined | SuggestedHighlightArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SuggestedHighlight :
    S extends undefined ? never :
    S extends { include: any } & (SuggestedHighlightArgs | SuggestedHighlightFindManyArgs)
    ? SuggestedHighlight  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'highlightedRange' ? WordRangeGetPayload<S['include'][P]> :
        P extends 'interview' ? InterviewGetPayload<S['include'][P]> :
        P extends 'transcript' ? TranscriptGetPayload<S['include'][P]> :
        P extends 'tags' ? Array < TagGetPayload<S['include'][P]>>  :
        P extends 'highlight' ? HighlightGetPayload<S['include'][P]> | null :
        P extends '_count' ? SuggestedHighlightCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SuggestedHighlightArgs | SuggestedHighlightFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'highlightedRange' ? WordRangeGetPayload<S['select'][P]> :
        P extends 'interview' ? InterviewGetPayload<S['select'][P]> :
        P extends 'transcript' ? TranscriptGetPayload<S['select'][P]> :
        P extends 'tags' ? Array < TagGetPayload<S['select'][P]>>  :
        P extends 'highlight' ? HighlightGetPayload<S['select'][P]> | null :
        P extends '_count' ? SuggestedHighlightCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SuggestedHighlight ? SuggestedHighlight[P] : never
  } 
      : SuggestedHighlight


  type SuggestedHighlightCountArgs = 
    Omit<SuggestedHighlightFindManyArgs, 'select' | 'include'> & {
      select?: SuggestedHighlightCountAggregateInputType | true
    }

  export interface SuggestedHighlightDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SuggestedHighlight that matches the filter.
     * @param {SuggestedHighlightFindUniqueArgs} args - Arguments to find a SuggestedHighlight
     * @example
     * // Get one SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SuggestedHighlightFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SuggestedHighlightFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SuggestedHighlight'> extends True ? Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>> : Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T> | null, null>

    /**
     * Find one SuggestedHighlight that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SuggestedHighlightFindUniqueOrThrowArgs} args - Arguments to find a SuggestedHighlight
     * @example
     * // Get one SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SuggestedHighlightFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SuggestedHighlightFindUniqueOrThrowArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Find the first SuggestedHighlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightFindFirstArgs} args - Arguments to find a SuggestedHighlight
     * @example
     * // Get one SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SuggestedHighlightFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SuggestedHighlightFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SuggestedHighlight'> extends True ? Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>> : Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T> | null, null>

    /**
     * Find the first SuggestedHighlight that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightFindFirstOrThrowArgs} args - Arguments to find a SuggestedHighlight
     * @example
     * // Get one SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SuggestedHighlightFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SuggestedHighlightFindFirstOrThrowArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Find zero or more SuggestedHighlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuggestedHighlights
     * const suggestedHighlights = await prisma.suggestedHighlight.findMany()
     * 
     * // Get first 10 SuggestedHighlights
     * const suggestedHighlights = await prisma.suggestedHighlight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestedHighlightWithIdOnly = await prisma.suggestedHighlight.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SuggestedHighlightFindManyArgs>(
      args?: SelectSubset<T, SuggestedHighlightFindManyArgs>
    ): PrismaPromise<Array<SuggestedHighlightGetPayload<T>>>

    /**
     * Create a SuggestedHighlight.
     * @param {SuggestedHighlightCreateArgs} args - Arguments to create a SuggestedHighlight.
     * @example
     * // Create one SuggestedHighlight
     * const SuggestedHighlight = await prisma.suggestedHighlight.create({
     *   data: {
     *     // ... data to create a SuggestedHighlight
     *   }
     * })
     * 
    **/
    create<T extends SuggestedHighlightCreateArgs>(
      args: SelectSubset<T, SuggestedHighlightCreateArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Create many SuggestedHighlights.
     *     @param {SuggestedHighlightCreateManyArgs} args - Arguments to create many SuggestedHighlights.
     *     @example
     *     // Create many SuggestedHighlights
     *     const suggestedHighlight = await prisma.suggestedHighlight.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SuggestedHighlightCreateManyArgs>(
      args?: SelectSubset<T, SuggestedHighlightCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SuggestedHighlight.
     * @param {SuggestedHighlightDeleteArgs} args - Arguments to delete one SuggestedHighlight.
     * @example
     * // Delete one SuggestedHighlight
     * const SuggestedHighlight = await prisma.suggestedHighlight.delete({
     *   where: {
     *     // ... filter to delete one SuggestedHighlight
     *   }
     * })
     * 
    **/
    delete<T extends SuggestedHighlightDeleteArgs>(
      args: SelectSubset<T, SuggestedHighlightDeleteArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Update one SuggestedHighlight.
     * @param {SuggestedHighlightUpdateArgs} args - Arguments to update one SuggestedHighlight.
     * @example
     * // Update one SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SuggestedHighlightUpdateArgs>(
      args: SelectSubset<T, SuggestedHighlightUpdateArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Delete zero or more SuggestedHighlights.
     * @param {SuggestedHighlightDeleteManyArgs} args - Arguments to filter SuggestedHighlights to delete.
     * @example
     * // Delete a few SuggestedHighlights
     * const { count } = await prisma.suggestedHighlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SuggestedHighlightDeleteManyArgs>(
      args?: SelectSubset<T, SuggestedHighlightDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuggestedHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuggestedHighlights
     * const suggestedHighlight = await prisma.suggestedHighlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SuggestedHighlightUpdateManyArgs>(
      args: SelectSubset<T, SuggestedHighlightUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SuggestedHighlight.
     * @param {SuggestedHighlightUpsertArgs} args - Arguments to update or create a SuggestedHighlight.
     * @example
     * // Update or create a SuggestedHighlight
     * const suggestedHighlight = await prisma.suggestedHighlight.upsert({
     *   create: {
     *     // ... data to create a SuggestedHighlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuggestedHighlight we want to update
     *   }
     * })
    **/
    upsert<T extends SuggestedHighlightUpsertArgs>(
      args: SelectSubset<T, SuggestedHighlightUpsertArgs>
    ): Prisma__SuggestedHighlightClient<SuggestedHighlightGetPayload<T>>

    /**
     * Count the number of SuggestedHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightCountArgs} args - Arguments to filter SuggestedHighlights to count.
     * @example
     * // Count the number of SuggestedHighlights
     * const count = await prisma.suggestedHighlight.count({
     *   where: {
     *     // ... the filter for the SuggestedHighlights we want to count
     *   }
     * })
    **/
    count<T extends SuggestedHighlightCountArgs>(
      args?: Subset<T, SuggestedHighlightCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestedHighlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuggestedHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestedHighlightAggregateArgs>(args: Subset<T, SuggestedHighlightAggregateArgs>): PrismaPromise<GetSuggestedHighlightAggregateType<T>>

    /**
     * Group by SuggestedHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedHighlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestedHighlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestedHighlightGroupByArgs['orderBy'] }
        : { orderBy?: SuggestedHighlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestedHighlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestedHighlightGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SuggestedHighlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SuggestedHighlightClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    highlightedRange<T extends WordRangeArgs= {}>(args?: Subset<T, WordRangeArgs>): Prisma__WordRangeClient<WordRangeGetPayload<T> | Null>;

    interview<T extends InterviewArgs= {}>(args?: Subset<T, InterviewArgs>): Prisma__InterviewClient<InterviewGetPayload<T> | Null>;

    transcript<T extends TranscriptArgs= {}>(args?: Subset<T, TranscriptArgs>): Prisma__TranscriptClient<TranscriptGetPayload<T> | Null>;

    tags<T extends SuggestedHighlight$tagsArgs= {}>(args?: Subset<T, SuggestedHighlight$tagsArgs>): PrismaPromise<Array<TagGetPayload<T>>| Null>;

    highlight<T extends HighlightArgs= {}>(args?: Subset<T, HighlightArgs>): Prisma__HighlightClient<HighlightGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SuggestedHighlight base type for findUnique actions
   */
  export type SuggestedHighlightFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter, which SuggestedHighlight to fetch.
     */
    where: SuggestedHighlightWhereUniqueInput
  }

  /**
   * SuggestedHighlight findUnique
   */
  export interface SuggestedHighlightFindUniqueArgs extends SuggestedHighlightFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SuggestedHighlight findUniqueOrThrow
   */
  export type SuggestedHighlightFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter, which SuggestedHighlight to fetch.
     */
    where: SuggestedHighlightWhereUniqueInput
  }


  /**
   * SuggestedHighlight base type for findFirst actions
   */
  export type SuggestedHighlightFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter, which SuggestedHighlight to fetch.
     */
    where?: SuggestedHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedHighlights to fetch.
     */
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedHighlights.
     */
    cursor?: SuggestedHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedHighlights.
     */
    distinct?: Enumerable<SuggestedHighlightScalarFieldEnum>
  }

  /**
   * SuggestedHighlight findFirst
   */
  export interface SuggestedHighlightFindFirstArgs extends SuggestedHighlightFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SuggestedHighlight findFirstOrThrow
   */
  export type SuggestedHighlightFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter, which SuggestedHighlight to fetch.
     */
    where?: SuggestedHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedHighlights to fetch.
     */
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedHighlights.
     */
    cursor?: SuggestedHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedHighlights.
     */
    distinct?: Enumerable<SuggestedHighlightScalarFieldEnum>
  }


  /**
   * SuggestedHighlight findMany
   */
  export type SuggestedHighlightFindManyArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter, which SuggestedHighlights to fetch.
     */
    where?: SuggestedHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedHighlights to fetch.
     */
    orderBy?: Enumerable<SuggestedHighlightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuggestedHighlights.
     */
    cursor?: SuggestedHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedHighlights.
     */
    skip?: number
    distinct?: Enumerable<SuggestedHighlightScalarFieldEnum>
  }


  /**
   * SuggestedHighlight create
   */
  export type SuggestedHighlightCreateArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * The data needed to create a SuggestedHighlight.
     */
    data: XOR<SuggestedHighlightCreateInput, SuggestedHighlightUncheckedCreateInput>
  }


  /**
   * SuggestedHighlight createMany
   */
  export type SuggestedHighlightCreateManyArgs = {
    /**
     * The data used to create many SuggestedHighlights.
     */
    data: Enumerable<SuggestedHighlightCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SuggestedHighlight update
   */
  export type SuggestedHighlightUpdateArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * The data needed to update a SuggestedHighlight.
     */
    data: XOR<SuggestedHighlightUpdateInput, SuggestedHighlightUncheckedUpdateInput>
    /**
     * Choose, which SuggestedHighlight to update.
     */
    where: SuggestedHighlightWhereUniqueInput
  }


  /**
   * SuggestedHighlight updateMany
   */
  export type SuggestedHighlightUpdateManyArgs = {
    /**
     * The data used to update SuggestedHighlights.
     */
    data: XOR<SuggestedHighlightUpdateManyMutationInput, SuggestedHighlightUncheckedUpdateManyInput>
    /**
     * Filter which SuggestedHighlights to update
     */
    where?: SuggestedHighlightWhereInput
  }


  /**
   * SuggestedHighlight upsert
   */
  export type SuggestedHighlightUpsertArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * The filter to search for the SuggestedHighlight to update in case it exists.
     */
    where: SuggestedHighlightWhereUniqueInput
    /**
     * In case the SuggestedHighlight found by the `where` argument doesn't exist, create a new SuggestedHighlight with this data.
     */
    create: XOR<SuggestedHighlightCreateInput, SuggestedHighlightUncheckedCreateInput>
    /**
     * In case the SuggestedHighlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestedHighlightUpdateInput, SuggestedHighlightUncheckedUpdateInput>
  }


  /**
   * SuggestedHighlight delete
   */
  export type SuggestedHighlightDeleteArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
    /**
     * Filter which SuggestedHighlight to delete.
     */
    where: SuggestedHighlightWhereUniqueInput
  }


  /**
   * SuggestedHighlight deleteMany
   */
  export type SuggestedHighlightDeleteManyArgs = {
    /**
     * Filter which SuggestedHighlights to delete
     */
    where?: SuggestedHighlightWhereInput
  }


  /**
   * SuggestedHighlight.tags
   */
  export type SuggestedHighlight$tagsArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * SuggestedHighlight without action
   */
  export type SuggestedHighlightArgs = {
    /**
     * Select specific fields to fetch from the SuggestedHighlight
     */
    select?: SuggestedHighlightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuggestedHighlightInclude | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    workspaceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
    by: ProjectScalarFieldEnum[]
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string
    workspaceId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    interviews?: boolean | Project$interviewsArgs
    workspace?: boolean | WorkspaceArgs
    workspaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectTags?: boolean | Project$projectTagsArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }


  export type ProjectInclude = {
    interviews?: boolean | Project$interviewsArgs
    workspace?: boolean | WorkspaceArgs
    projectTags?: boolean | Project$projectTagsArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }

  export type ProjectGetPayload<S extends boolean | null | undefined | ProjectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Project :
    S extends undefined ? never :
    S extends { include: any } & (ProjectArgs | ProjectFindManyArgs)
    ? Project  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interviews' ? Array < InterviewGetPayload<S['include'][P]>>  :
        P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
        P extends 'projectTags' ? Array < ProjectTagsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectArgs | ProjectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interviews' ? Array < InterviewGetPayload<S['select'][P]>>  :
        P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
        P extends 'projectTags' ? Array < ProjectTagsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Project ? Project[P] : never
  } 
      : Project


  type ProjectCountArgs = 
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find one Project that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find the first Project that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): PrismaPromise<Array<ProjectGetPayload<T>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interviews<T extends Project$interviewsArgs= {}>(args?: Subset<T, Project$interviewsArgs>): PrismaPromise<Array<InterviewGetPayload<T>>| Null>;

    workspace<T extends WorkspaceArgs= {}>(args?: Subset<T, WorkspaceArgs>): Prisma__WorkspaceClient<WorkspaceGetPayload<T> | Null>;

    projectTags<T extends Project$projectTagsArgs= {}>(args?: Subset<T, Project$projectTagsArgs>): PrismaPromise<Array<ProjectTagsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Project base type for findUnique actions
   */
  export type ProjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUnique
   */
  export interface ProjectFindUniqueArgs extends ProjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project base type for findFirst actions
   */
  export type ProjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }

  /**
   * Project findFirst
   */
  export interface ProjectFindFirstArgs extends ProjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs = {
    /**
     * The data used to create many Projects.
     */
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }


  /**
   * Project.interviews
   */
  export type Project$interviewsArgs = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InterviewInclude | null
    where?: InterviewWhereInput
    orderBy?: Enumerable<InterviewOrderByWithRelationInput>
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InterviewScalarFieldEnum>
  }


  /**
   * Project.projectTags
   */
  export type Project$projectTagsArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    where?: ProjectTagsWhereInput
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    cursor?: ProjectTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectTagsScalarFieldEnum>
  }


  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
  }



  /**
   * Model ProjectTags
   */


  export type AggregateProjectTags = {
    _count: ProjectTagsCountAggregateOutputType | null
    _avg: ProjectTagsAvgAggregateOutputType | null
    _sum: ProjectTagsSumAggregateOutputType | null
    _min: ProjectTagsMinAggregateOutputType | null
    _max: ProjectTagsMaxAggregateOutputType | null
  }

  export type ProjectTagsAvgAggregateOutputType = {
    position: number | null
  }

  export type ProjectTagsSumAggregateOutputType = {
    position: number | null
  }

  export type ProjectTagsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    tagId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTagsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    tagId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTagsCountAggregateOutputType = {
    id: number
    projectId: number
    tagId: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectTagsAvgAggregateInputType = {
    position?: true
  }

  export type ProjectTagsSumAggregateInputType = {
    position?: true
  }

  export type ProjectTagsMinAggregateInputType = {
    id?: true
    projectId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTagsMaxAggregateInputType = {
    id?: true
    projectId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTagsCountAggregateInputType = {
    id?: true
    projectId?: true
    tagId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectTagsAggregateArgs = {
    /**
     * Filter which ProjectTags to aggregate.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTags
    **/
    _count?: true | ProjectTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTagsMaxAggregateInputType
  }

  export type GetProjectTagsAggregateType<T extends ProjectTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTags[P]>
      : GetScalarType<T[P], AggregateProjectTags[P]>
  }




  export type ProjectTagsGroupByArgs = {
    where?: ProjectTagsWhereInput
    orderBy?: Enumerable<ProjectTagsOrderByWithAggregationInput>
    by: ProjectTagsScalarFieldEnum[]
    having?: ProjectTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTagsCountAggregateInputType | true
    _avg?: ProjectTagsAvgAggregateInputType
    _sum?: ProjectTagsSumAggregateInputType
    _min?: ProjectTagsMinAggregateInputType
    _max?: ProjectTagsMaxAggregateInputType
  }


  export type ProjectTagsGroupByOutputType = {
    id: string
    projectId: string
    tagId: string
    position: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectTagsCountAggregateOutputType | null
    _avg: ProjectTagsAvgAggregateOutputType | null
    _sum: ProjectTagsSumAggregateOutputType | null
    _min: ProjectTagsMinAggregateOutputType | null
    _max: ProjectTagsMaxAggregateOutputType | null
  }

  type GetProjectTagsGroupByPayload<T extends ProjectTagsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProjectTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTagsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTagsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTagsSelect = {
    id?: boolean
    projectId?: boolean
    project?: boolean | ProjectArgs
    tagId?: boolean
    tag?: boolean | TagArgs
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ProjectTagsInclude = {
    project?: boolean | ProjectArgs
    tag?: boolean | TagArgs
  }

  export type ProjectTagsGetPayload<S extends boolean | null | undefined | ProjectTagsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectTags :
    S extends undefined ? never :
    S extends { include: any } & (ProjectTagsArgs | ProjectTagsFindManyArgs)
    ? ProjectTags  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'tag' ? TagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectTagsArgs | ProjectTagsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'tag' ? TagGetPayload<S['select'][P]> :  P extends keyof ProjectTags ? ProjectTags[P] : never
  } 
      : ProjectTags


  type ProjectTagsCountArgs = 
    Omit<ProjectTagsFindManyArgs, 'select' | 'include'> & {
      select?: ProjectTagsCountAggregateInputType | true
    }

  export interface ProjectTagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectTags that matches the filter.
     * @param {ProjectTagsFindUniqueArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectTagsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectTagsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectTags'> extends True ? Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>> : Prisma__ProjectTagsClient<ProjectTagsGetPayload<T> | null, null>

    /**
     * Find one ProjectTags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectTagsFindUniqueOrThrowArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectTagsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectTagsFindUniqueOrThrowArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Find the first ProjectTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindFirstArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectTagsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectTagsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectTags'> extends True ? Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>> : Prisma__ProjectTagsClient<ProjectTagsGetPayload<T> | null, null>

    /**
     * Find the first ProjectTags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindFirstOrThrowArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectTagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectTagsFindFirstOrThrowArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Find zero or more ProjectTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTags
     * const projectTags = await prisma.projectTags.findMany()
     * 
     * // Get first 10 ProjectTags
     * const projectTags = await prisma.projectTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTagsWithIdOnly = await prisma.projectTags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectTagsFindManyArgs>(
      args?: SelectSubset<T, ProjectTagsFindManyArgs>
    ): PrismaPromise<Array<ProjectTagsGetPayload<T>>>

    /**
     * Create a ProjectTags.
     * @param {ProjectTagsCreateArgs} args - Arguments to create a ProjectTags.
     * @example
     * // Create one ProjectTags
     * const ProjectTags = await prisma.projectTags.create({
     *   data: {
     *     // ... data to create a ProjectTags
     *   }
     * })
     * 
    **/
    create<T extends ProjectTagsCreateArgs>(
      args: SelectSubset<T, ProjectTagsCreateArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Create many ProjectTags.
     *     @param {ProjectTagsCreateManyArgs} args - Arguments to create many ProjectTags.
     *     @example
     *     // Create many ProjectTags
     *     const projectTags = await prisma.projectTags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectTagsCreateManyArgs>(
      args?: SelectSubset<T, ProjectTagsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTags.
     * @param {ProjectTagsDeleteArgs} args - Arguments to delete one ProjectTags.
     * @example
     * // Delete one ProjectTags
     * const ProjectTags = await prisma.projectTags.delete({
     *   where: {
     *     // ... filter to delete one ProjectTags
     *   }
     * })
     * 
    **/
    delete<T extends ProjectTagsDeleteArgs>(
      args: SelectSubset<T, ProjectTagsDeleteArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Update one ProjectTags.
     * @param {ProjectTagsUpdateArgs} args - Arguments to update one ProjectTags.
     * @example
     * // Update one ProjectTags
     * const projectTags = await prisma.projectTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectTagsUpdateArgs>(
      args: SelectSubset<T, ProjectTagsUpdateArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Delete zero or more ProjectTags.
     * @param {ProjectTagsDeleteManyArgs} args - Arguments to filter ProjectTags to delete.
     * @example
     * // Delete a few ProjectTags
     * const { count } = await prisma.projectTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectTagsDeleteManyArgs>(
      args?: SelectSubset<T, ProjectTagsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTags
     * const projectTags = await prisma.projectTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectTagsUpdateManyArgs>(
      args: SelectSubset<T, ProjectTagsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTags.
     * @param {ProjectTagsUpsertArgs} args - Arguments to update or create a ProjectTags.
     * @example
     * // Update or create a ProjectTags
     * const projectTags = await prisma.projectTags.upsert({
     *   create: {
     *     // ... data to create a ProjectTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTags we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectTagsUpsertArgs>(
      args: SelectSubset<T, ProjectTagsUpsertArgs>
    ): Prisma__ProjectTagsClient<ProjectTagsGetPayload<T>>

    /**
     * Count the number of ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsCountArgs} args - Arguments to filter ProjectTags to count.
     * @example
     * // Count the number of ProjectTags
     * const count = await prisma.projectTags.count({
     *   where: {
     *     // ... the filter for the ProjectTags we want to count
     *   }
     * })
    **/
    count<T extends ProjectTagsCountArgs>(
      args?: Subset<T, ProjectTagsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTagsAggregateArgs>(args: Subset<T, ProjectTagsAggregateArgs>): PrismaPromise<GetProjectTagsAggregateType<T>>

    /**
     * Group by ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTagsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTagsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectTagsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    tag<T extends TagArgs= {}>(args?: Subset<T, TagArgs>): Prisma__TagClient<TagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectTags base type for findUnique actions
   */
  export type ProjectTagsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where: ProjectTagsWhereUniqueInput
  }

  /**
   * ProjectTags findUnique
   */
  export interface ProjectTagsFindUniqueArgs extends ProjectTagsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectTags findUniqueOrThrow
   */
  export type ProjectTagsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where: ProjectTagsWhereUniqueInput
  }


  /**
   * ProjectTags base type for findFirst actions
   */
  export type ProjectTagsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: Enumerable<ProjectTagsScalarFieldEnum>
  }

  /**
   * ProjectTags findFirst
   */
  export interface ProjectTagsFindFirstArgs extends ProjectTagsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectTags findFirstOrThrow
   */
  export type ProjectTagsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: Enumerable<ProjectTagsScalarFieldEnum>
  }


  /**
   * ProjectTags findMany
   */
  export type ProjectTagsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: Enumerable<ProjectTagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    distinct?: Enumerable<ProjectTagsScalarFieldEnum>
  }


  /**
   * ProjectTags create
   */
  export type ProjectTagsCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * The data needed to create a ProjectTags.
     */
    data: XOR<ProjectTagsCreateInput, ProjectTagsUncheckedCreateInput>
  }


  /**
   * ProjectTags createMany
   */
  export type ProjectTagsCreateManyArgs = {
    /**
     * The data used to create many ProjectTags.
     */
    data: Enumerable<ProjectTagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectTags update
   */
  export type ProjectTagsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * The data needed to update a ProjectTags.
     */
    data: XOR<ProjectTagsUpdateInput, ProjectTagsUncheckedUpdateInput>
    /**
     * Choose, which ProjectTags to update.
     */
    where: ProjectTagsWhereUniqueInput
  }


  /**
   * ProjectTags updateMany
   */
  export type ProjectTagsUpdateManyArgs = {
    /**
     * The data used to update ProjectTags.
     */
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTags to update
     */
    where?: ProjectTagsWhereInput
  }


  /**
   * ProjectTags upsert
   */
  export type ProjectTagsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * The filter to search for the ProjectTags to update in case it exists.
     */
    where: ProjectTagsWhereUniqueInput
    /**
     * In case the ProjectTags found by the `where` argument doesn't exist, create a new ProjectTags with this data.
     */
    create: XOR<ProjectTagsCreateInput, ProjectTagsUncheckedCreateInput>
    /**
     * In case the ProjectTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTagsUpdateInput, ProjectTagsUncheckedUpdateInput>
  }


  /**
   * ProjectTags delete
   */
  export type ProjectTagsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
    /**
     * Filter which ProjectTags to delete.
     */
    where: ProjectTagsWhereUniqueInput
  }


  /**
   * ProjectTags deleteMany
   */
  export type ProjectTagsDeleteManyArgs = {
    /**
     * Filter which ProjectTags to delete
     */
    where?: ProjectTagsWhereInput
  }


  /**
   * ProjectTags without action
   */
  export type ProjectTagsArgs = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectTagsInclude | null
  }



  /**
   * Model Recorder
   */


  export type AggregateRecorder = {
    _count: RecorderCountAggregateOutputType | null
    _min: RecorderMinAggregateOutputType | null
    _max: RecorderMaxAggregateOutputType | null
  }

  export type RecorderMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    error: string | null
    type: RecorderType | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: RecorderStatus | null
  }

  export type RecorderMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    error: string | null
    type: RecorderType | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: RecorderStatus | null
  }

  export type RecorderCountAggregateOutputType = {
    id: number
    externalId: number
    error: number
    type: number
    targetId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type RecorderMinAggregateInputType = {
    id?: true
    externalId?: true
    error?: true
    type?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RecorderMaxAggregateInputType = {
    id?: true
    externalId?: true
    error?: true
    type?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RecorderCountAggregateInputType = {
    id?: true
    externalId?: true
    error?: true
    type?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type RecorderAggregateArgs = {
    /**
     * Filter which Recorder to aggregate.
     */
    where?: RecorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recorders to fetch.
     */
    orderBy?: Enumerable<RecorderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recorders
    **/
    _count?: true | RecorderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecorderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecorderMaxAggregateInputType
  }

  export type GetRecorderAggregateType<T extends RecorderAggregateArgs> = {
        [P in keyof T & keyof AggregateRecorder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecorder[P]>
      : GetScalarType<T[P], AggregateRecorder[P]>
  }




  export type RecorderGroupByArgs = {
    where?: RecorderWhereInput
    orderBy?: Enumerable<RecorderOrderByWithAggregationInput>
    by: RecorderScalarFieldEnum[]
    having?: RecorderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecorderCountAggregateInputType | true
    _min?: RecorderMinAggregateInputType
    _max?: RecorderMaxAggregateInputType
  }


  export type RecorderGroupByOutputType = {
    id: string
    externalId: string | null
    error: string | null
    type: RecorderType
    targetId: string
    createdAt: Date
    updatedAt: Date
    status: RecorderStatus
    _count: RecorderCountAggregateOutputType | null
    _min: RecorderMinAggregateOutputType | null
    _max: RecorderMaxAggregateOutputType | null
  }

  type GetRecorderGroupByPayload<T extends RecorderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecorderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecorderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecorderGroupByOutputType[P]>
            : GetScalarType<T[P], RecorderGroupByOutputType[P]>
        }
      >
    >


  export type RecorderSelect = {
    id?: boolean
    externalId?: boolean
    error?: boolean
    type?: boolean
    target?: boolean | RecordingTargetArgs
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Video?: boolean | Recorder$VideoArgs
    status?: boolean
    _count?: boolean | RecorderCountOutputTypeArgs
  }


  export type RecorderInclude = {
    target?: boolean | RecordingTargetArgs
    Video?: boolean | Recorder$VideoArgs
    _count?: boolean | RecorderCountOutputTypeArgs
  }

  export type RecorderGetPayload<S extends boolean | null | undefined | RecorderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Recorder :
    S extends undefined ? never :
    S extends { include: any } & (RecorderArgs | RecorderFindManyArgs)
    ? Recorder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'target' ? RecordingTargetGetPayload<S['include'][P]> :
        P extends 'Video' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends '_count' ? RecorderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RecorderArgs | RecorderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'target' ? RecordingTargetGetPayload<S['select'][P]> :
        P extends 'Video' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends '_count' ? RecorderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Recorder ? Recorder[P] : never
  } 
      : Recorder


  type RecorderCountArgs = 
    Omit<RecorderFindManyArgs, 'select' | 'include'> & {
      select?: RecorderCountAggregateInputType | true
    }

  export interface RecorderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Recorder that matches the filter.
     * @param {RecorderFindUniqueArgs} args - Arguments to find a Recorder
     * @example
     * // Get one Recorder
     * const recorder = await prisma.recorder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecorderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecorderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recorder'> extends True ? Prisma__RecorderClient<RecorderGetPayload<T>> : Prisma__RecorderClient<RecorderGetPayload<T> | null, null>

    /**
     * Find one Recorder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecorderFindUniqueOrThrowArgs} args - Arguments to find a Recorder
     * @example
     * // Get one Recorder
     * const recorder = await prisma.recorder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecorderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecorderFindUniqueOrThrowArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Find the first Recorder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderFindFirstArgs} args - Arguments to find a Recorder
     * @example
     * // Get one Recorder
     * const recorder = await prisma.recorder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecorderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecorderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recorder'> extends True ? Prisma__RecorderClient<RecorderGetPayload<T>> : Prisma__RecorderClient<RecorderGetPayload<T> | null, null>

    /**
     * Find the first Recorder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderFindFirstOrThrowArgs} args - Arguments to find a Recorder
     * @example
     * // Get one Recorder
     * const recorder = await prisma.recorder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecorderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecorderFindFirstOrThrowArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Find zero or more Recorders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recorders
     * const recorders = await prisma.recorder.findMany()
     * 
     * // Get first 10 Recorders
     * const recorders = await prisma.recorder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recorderWithIdOnly = await prisma.recorder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecorderFindManyArgs>(
      args?: SelectSubset<T, RecorderFindManyArgs>
    ): PrismaPromise<Array<RecorderGetPayload<T>>>

    /**
     * Create a Recorder.
     * @param {RecorderCreateArgs} args - Arguments to create a Recorder.
     * @example
     * // Create one Recorder
     * const Recorder = await prisma.recorder.create({
     *   data: {
     *     // ... data to create a Recorder
     *   }
     * })
     * 
    **/
    create<T extends RecorderCreateArgs>(
      args: SelectSubset<T, RecorderCreateArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Create many Recorders.
     *     @param {RecorderCreateManyArgs} args - Arguments to create many Recorders.
     *     @example
     *     // Create many Recorders
     *     const recorder = await prisma.recorder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecorderCreateManyArgs>(
      args?: SelectSubset<T, RecorderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Recorder.
     * @param {RecorderDeleteArgs} args - Arguments to delete one Recorder.
     * @example
     * // Delete one Recorder
     * const Recorder = await prisma.recorder.delete({
     *   where: {
     *     // ... filter to delete one Recorder
     *   }
     * })
     * 
    **/
    delete<T extends RecorderDeleteArgs>(
      args: SelectSubset<T, RecorderDeleteArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Update one Recorder.
     * @param {RecorderUpdateArgs} args - Arguments to update one Recorder.
     * @example
     * // Update one Recorder
     * const recorder = await prisma.recorder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecorderUpdateArgs>(
      args: SelectSubset<T, RecorderUpdateArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Delete zero or more Recorders.
     * @param {RecorderDeleteManyArgs} args - Arguments to filter Recorders to delete.
     * @example
     * // Delete a few Recorders
     * const { count } = await prisma.recorder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecorderDeleteManyArgs>(
      args?: SelectSubset<T, RecorderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recorders
     * const recorder = await prisma.recorder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecorderUpdateManyArgs>(
      args: SelectSubset<T, RecorderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Recorder.
     * @param {RecorderUpsertArgs} args - Arguments to update or create a Recorder.
     * @example
     * // Update or create a Recorder
     * const recorder = await prisma.recorder.upsert({
     *   create: {
     *     // ... data to create a Recorder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recorder we want to update
     *   }
     * })
    **/
    upsert<T extends RecorderUpsertArgs>(
      args: SelectSubset<T, RecorderUpsertArgs>
    ): Prisma__RecorderClient<RecorderGetPayload<T>>

    /**
     * Count the number of Recorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderCountArgs} args - Arguments to filter Recorders to count.
     * @example
     * // Count the number of Recorders
     * const count = await prisma.recorder.count({
     *   where: {
     *     // ... the filter for the Recorders we want to count
     *   }
     * })
    **/
    count<T extends RecorderCountArgs>(
      args?: Subset<T, RecorderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecorderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecorderAggregateArgs>(args: Subset<T, RecorderAggregateArgs>): PrismaPromise<GetRecorderAggregateType<T>>

    /**
     * Group by Recorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecorderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecorderGroupByArgs['orderBy'] }
        : { orderBy?: RecorderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecorderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecorderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recorder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecorderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    target<T extends RecordingTargetArgs= {}>(args?: Subset<T, RecordingTargetArgs>): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T> | Null>;

    Video<T extends Recorder$VideoArgs= {}>(args?: Subset<T, Recorder$VideoArgs>): PrismaPromise<Array<VideoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recorder base type for findUnique actions
   */
  export type RecorderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter, which Recorder to fetch.
     */
    where: RecorderWhereUniqueInput
  }

  /**
   * Recorder findUnique
   */
  export interface RecorderFindUniqueArgs extends RecorderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recorder findUniqueOrThrow
   */
  export type RecorderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter, which Recorder to fetch.
     */
    where: RecorderWhereUniqueInput
  }


  /**
   * Recorder base type for findFirst actions
   */
  export type RecorderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter, which Recorder to fetch.
     */
    where?: RecorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recorders to fetch.
     */
    orderBy?: Enumerable<RecorderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recorders.
     */
    cursor?: RecorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recorders.
     */
    distinct?: Enumerable<RecorderScalarFieldEnum>
  }

  /**
   * Recorder findFirst
   */
  export interface RecorderFindFirstArgs extends RecorderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recorder findFirstOrThrow
   */
  export type RecorderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter, which Recorder to fetch.
     */
    where?: RecorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recorders to fetch.
     */
    orderBy?: Enumerable<RecorderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recorders.
     */
    cursor?: RecorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recorders.
     */
    distinct?: Enumerable<RecorderScalarFieldEnum>
  }


  /**
   * Recorder findMany
   */
  export type RecorderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter, which Recorders to fetch.
     */
    where?: RecorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recorders to fetch.
     */
    orderBy?: Enumerable<RecorderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recorders.
     */
    cursor?: RecorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recorders.
     */
    skip?: number
    distinct?: Enumerable<RecorderScalarFieldEnum>
  }


  /**
   * Recorder create
   */
  export type RecorderCreateArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * The data needed to create a Recorder.
     */
    data: XOR<RecorderCreateInput, RecorderUncheckedCreateInput>
  }


  /**
   * Recorder createMany
   */
  export type RecorderCreateManyArgs = {
    /**
     * The data used to create many Recorders.
     */
    data: Enumerable<RecorderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recorder update
   */
  export type RecorderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * The data needed to update a Recorder.
     */
    data: XOR<RecorderUpdateInput, RecorderUncheckedUpdateInput>
    /**
     * Choose, which Recorder to update.
     */
    where: RecorderWhereUniqueInput
  }


  /**
   * Recorder updateMany
   */
  export type RecorderUpdateManyArgs = {
    /**
     * The data used to update Recorders.
     */
    data: XOR<RecorderUpdateManyMutationInput, RecorderUncheckedUpdateManyInput>
    /**
     * Filter which Recorders to update
     */
    where?: RecorderWhereInput
  }


  /**
   * Recorder upsert
   */
  export type RecorderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * The filter to search for the Recorder to update in case it exists.
     */
    where: RecorderWhereUniqueInput
    /**
     * In case the Recorder found by the `where` argument doesn't exist, create a new Recorder with this data.
     */
    create: XOR<RecorderCreateInput, RecorderUncheckedCreateInput>
    /**
     * In case the Recorder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecorderUpdateInput, RecorderUncheckedUpdateInput>
  }


  /**
   * Recorder delete
   */
  export type RecorderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
    /**
     * Filter which Recorder to delete.
     */
    where: RecorderWhereUniqueInput
  }


  /**
   * Recorder deleteMany
   */
  export type RecorderDeleteManyArgs = {
    /**
     * Filter which Recorders to delete
     */
    where?: RecorderWhereInput
  }


  /**
   * Recorder.Video
   */
  export type Recorder$VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Recorder without action
   */
  export type RecorderArgs = {
    /**
     * Select specific fields to fetch from the Recorder
     */
    select?: RecorderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecorderInclude | null
  }



  /**
   * Model RecordingTarget
   */


  export type AggregateRecordingTarget = {
    _count: RecordingTargetCountAggregateOutputType | null
    _min: RecordingTargetMinAggregateOutputType | null
    _max: RecordingTargetMaxAggregateOutputType | null
  }

  export type RecordingTargetMinAggregateOutputType = {
    id: string | null
    type: RecordingTargetType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecordingTargetMaxAggregateOutputType = {
    id: string | null
    type: RecordingTargetType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecordingTargetCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecordingTargetMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecordingTargetMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecordingTargetCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecordingTargetAggregateArgs = {
    /**
     * Filter which RecordingTarget to aggregate.
     */
    where?: RecordingTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingTargets to fetch.
     */
    orderBy?: Enumerable<RecordingTargetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecordingTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecordingTargets
    **/
    _count?: true | RecordingTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecordingTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecordingTargetMaxAggregateInputType
  }

  export type GetRecordingTargetAggregateType<T extends RecordingTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateRecordingTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecordingTarget[P]>
      : GetScalarType<T[P], AggregateRecordingTarget[P]>
  }




  export type RecordingTargetGroupByArgs = {
    where?: RecordingTargetWhereInput
    orderBy?: Enumerable<RecordingTargetOrderByWithAggregationInput>
    by: RecordingTargetScalarFieldEnum[]
    having?: RecordingTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecordingTargetCountAggregateInputType | true
    _min?: RecordingTargetMinAggregateInputType
    _max?: RecordingTargetMaxAggregateInputType
  }


  export type RecordingTargetGroupByOutputType = {
    id: string
    type: RecordingTargetType
    createdAt: Date
    updatedAt: Date
    _count: RecordingTargetCountAggregateOutputType | null
    _min: RecordingTargetMinAggregateOutputType | null
    _max: RecordingTargetMaxAggregateOutputType | null
  }

  type GetRecordingTargetGroupByPayload<T extends RecordingTargetGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecordingTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecordingTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecordingTargetGroupByOutputType[P]>
            : GetScalarType<T[P], RecordingTargetGroupByOutputType[P]>
        }
      >
    >


  export type RecordingTargetSelect = {
    id?: boolean
    type?: boolean
    recorder?: boolean | RecorderArgs
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type RecordingTargetInclude = {
    recorder?: boolean | RecorderArgs
  }

  export type RecordingTargetGetPayload<S extends boolean | null | undefined | RecordingTargetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RecordingTarget :
    S extends undefined ? never :
    S extends { include: any } & (RecordingTargetArgs | RecordingTargetFindManyArgs)
    ? RecordingTarget  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recorder' ? RecorderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (RecordingTargetArgs | RecordingTargetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recorder' ? RecorderGetPayload<S['select'][P]> | null :  P extends keyof RecordingTarget ? RecordingTarget[P] : never
  } 
      : RecordingTarget


  type RecordingTargetCountArgs = 
    Omit<RecordingTargetFindManyArgs, 'select' | 'include'> & {
      select?: RecordingTargetCountAggregateInputType | true
    }

  export interface RecordingTargetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RecordingTarget that matches the filter.
     * @param {RecordingTargetFindUniqueArgs} args - Arguments to find a RecordingTarget
     * @example
     * // Get one RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecordingTargetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecordingTargetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecordingTarget'> extends True ? Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>> : Prisma__RecordingTargetClient<RecordingTargetGetPayload<T> | null, null>

    /**
     * Find one RecordingTarget that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecordingTargetFindUniqueOrThrowArgs} args - Arguments to find a RecordingTarget
     * @example
     * // Get one RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecordingTargetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecordingTargetFindUniqueOrThrowArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Find the first RecordingTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetFindFirstArgs} args - Arguments to find a RecordingTarget
     * @example
     * // Get one RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecordingTargetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecordingTargetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecordingTarget'> extends True ? Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>> : Prisma__RecordingTargetClient<RecordingTargetGetPayload<T> | null, null>

    /**
     * Find the first RecordingTarget that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetFindFirstOrThrowArgs} args - Arguments to find a RecordingTarget
     * @example
     * // Get one RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecordingTargetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecordingTargetFindFirstOrThrowArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Find zero or more RecordingTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecordingTargets
     * const recordingTargets = await prisma.recordingTarget.findMany()
     * 
     * // Get first 10 RecordingTargets
     * const recordingTargets = await prisma.recordingTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recordingTargetWithIdOnly = await prisma.recordingTarget.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecordingTargetFindManyArgs>(
      args?: SelectSubset<T, RecordingTargetFindManyArgs>
    ): PrismaPromise<Array<RecordingTargetGetPayload<T>>>

    /**
     * Create a RecordingTarget.
     * @param {RecordingTargetCreateArgs} args - Arguments to create a RecordingTarget.
     * @example
     * // Create one RecordingTarget
     * const RecordingTarget = await prisma.recordingTarget.create({
     *   data: {
     *     // ... data to create a RecordingTarget
     *   }
     * })
     * 
    **/
    create<T extends RecordingTargetCreateArgs>(
      args: SelectSubset<T, RecordingTargetCreateArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Create many RecordingTargets.
     *     @param {RecordingTargetCreateManyArgs} args - Arguments to create many RecordingTargets.
     *     @example
     *     // Create many RecordingTargets
     *     const recordingTarget = await prisma.recordingTarget.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecordingTargetCreateManyArgs>(
      args?: SelectSubset<T, RecordingTargetCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecordingTarget.
     * @param {RecordingTargetDeleteArgs} args - Arguments to delete one RecordingTarget.
     * @example
     * // Delete one RecordingTarget
     * const RecordingTarget = await prisma.recordingTarget.delete({
     *   where: {
     *     // ... filter to delete one RecordingTarget
     *   }
     * })
     * 
    **/
    delete<T extends RecordingTargetDeleteArgs>(
      args: SelectSubset<T, RecordingTargetDeleteArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Update one RecordingTarget.
     * @param {RecordingTargetUpdateArgs} args - Arguments to update one RecordingTarget.
     * @example
     * // Update one RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecordingTargetUpdateArgs>(
      args: SelectSubset<T, RecordingTargetUpdateArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Delete zero or more RecordingTargets.
     * @param {RecordingTargetDeleteManyArgs} args - Arguments to filter RecordingTargets to delete.
     * @example
     * // Delete a few RecordingTargets
     * const { count } = await prisma.recordingTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecordingTargetDeleteManyArgs>(
      args?: SelectSubset<T, RecordingTargetDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecordingTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecordingTargets
     * const recordingTarget = await prisma.recordingTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecordingTargetUpdateManyArgs>(
      args: SelectSubset<T, RecordingTargetUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecordingTarget.
     * @param {RecordingTargetUpsertArgs} args - Arguments to update or create a RecordingTarget.
     * @example
     * // Update or create a RecordingTarget
     * const recordingTarget = await prisma.recordingTarget.upsert({
     *   create: {
     *     // ... data to create a RecordingTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecordingTarget we want to update
     *   }
     * })
    **/
    upsert<T extends RecordingTargetUpsertArgs>(
      args: SelectSubset<T, RecordingTargetUpsertArgs>
    ): Prisma__RecordingTargetClient<RecordingTargetGetPayload<T>>

    /**
     * Count the number of RecordingTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetCountArgs} args - Arguments to filter RecordingTargets to count.
     * @example
     * // Count the number of RecordingTargets
     * const count = await prisma.recordingTarget.count({
     *   where: {
     *     // ... the filter for the RecordingTargets we want to count
     *   }
     * })
    **/
    count<T extends RecordingTargetCountArgs>(
      args?: Subset<T, RecordingTargetCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecordingTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecordingTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecordingTargetAggregateArgs>(args: Subset<T, RecordingTargetAggregateArgs>): PrismaPromise<GetRecordingTargetAggregateType<T>>

    /**
     * Group by RecordingTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordingTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecordingTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecordingTargetGroupByArgs['orderBy'] }
        : { orderBy?: RecordingTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecordingTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecordingTargetGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecordingTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecordingTargetClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends RecorderArgs= {}>(args?: Subset<T, RecorderArgs>): Prisma__RecorderClient<RecorderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecordingTarget base type for findUnique actions
   */
  export type RecordingTargetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter, which RecordingTarget to fetch.
     */
    where: RecordingTargetWhereUniqueInput
  }

  /**
   * RecordingTarget findUnique
   */
  export interface RecordingTargetFindUniqueArgs extends RecordingTargetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecordingTarget findUniqueOrThrow
   */
  export type RecordingTargetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter, which RecordingTarget to fetch.
     */
    where: RecordingTargetWhereUniqueInput
  }


  /**
   * RecordingTarget base type for findFirst actions
   */
  export type RecordingTargetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter, which RecordingTarget to fetch.
     */
    where?: RecordingTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingTargets to fetch.
     */
    orderBy?: Enumerable<RecordingTargetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecordingTargets.
     */
    cursor?: RecordingTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecordingTargets.
     */
    distinct?: Enumerable<RecordingTargetScalarFieldEnum>
  }

  /**
   * RecordingTarget findFirst
   */
  export interface RecordingTargetFindFirstArgs extends RecordingTargetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecordingTarget findFirstOrThrow
   */
  export type RecordingTargetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter, which RecordingTarget to fetch.
     */
    where?: RecordingTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingTargets to fetch.
     */
    orderBy?: Enumerable<RecordingTargetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecordingTargets.
     */
    cursor?: RecordingTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecordingTargets.
     */
    distinct?: Enumerable<RecordingTargetScalarFieldEnum>
  }


  /**
   * RecordingTarget findMany
   */
  export type RecordingTargetFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter, which RecordingTargets to fetch.
     */
    where?: RecordingTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecordingTargets to fetch.
     */
    orderBy?: Enumerable<RecordingTargetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecordingTargets.
     */
    cursor?: RecordingTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecordingTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecordingTargets.
     */
    skip?: number
    distinct?: Enumerable<RecordingTargetScalarFieldEnum>
  }


  /**
   * RecordingTarget create
   */
  export type RecordingTargetCreateArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * The data needed to create a RecordingTarget.
     */
    data: XOR<RecordingTargetCreateInput, RecordingTargetUncheckedCreateInput>
  }


  /**
   * RecordingTarget createMany
   */
  export type RecordingTargetCreateManyArgs = {
    /**
     * The data used to create many RecordingTargets.
     */
    data: Enumerable<RecordingTargetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecordingTarget update
   */
  export type RecordingTargetUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * The data needed to update a RecordingTarget.
     */
    data: XOR<RecordingTargetUpdateInput, RecordingTargetUncheckedUpdateInput>
    /**
     * Choose, which RecordingTarget to update.
     */
    where: RecordingTargetWhereUniqueInput
  }


  /**
   * RecordingTarget updateMany
   */
  export type RecordingTargetUpdateManyArgs = {
    /**
     * The data used to update RecordingTargets.
     */
    data: XOR<RecordingTargetUpdateManyMutationInput, RecordingTargetUncheckedUpdateManyInput>
    /**
     * Filter which RecordingTargets to update
     */
    where?: RecordingTargetWhereInput
  }


  /**
   * RecordingTarget upsert
   */
  export type RecordingTargetUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * The filter to search for the RecordingTarget to update in case it exists.
     */
    where: RecordingTargetWhereUniqueInput
    /**
     * In case the RecordingTarget found by the `where` argument doesn't exist, create a new RecordingTarget with this data.
     */
    create: XOR<RecordingTargetCreateInput, RecordingTargetUncheckedCreateInput>
    /**
     * In case the RecordingTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecordingTargetUpdateInput, RecordingTargetUncheckedUpdateInput>
  }


  /**
   * RecordingTarget delete
   */
  export type RecordingTargetDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
    /**
     * Filter which RecordingTarget to delete.
     */
    where: RecordingTargetWhereUniqueInput
  }


  /**
   * RecordingTarget deleteMany
   */
  export type RecordingTargetDeleteManyArgs = {
    /**
     * Filter which RecordingTargets to delete
     */
    where?: RecordingTargetWhereInput
  }


  /**
   * RecordingTarget without action
   */
  export type RecordingTargetArgs = {
    /**
     * Select specific fields to fetch from the RecordingTarget
     */
    select?: RecordingTargetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecordingTargetInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const EditableAssetScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    status: 'status',
    playbackId: 'playbackId',
    isSigned: 'isSigned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EditableAssetScalarFieldEnum = (typeof EditableAssetScalarFieldEnum)[keyof typeof EditableAssetScalarFieldEnum]


  export const ExternalAuthScalarFieldEnum: {
    userId: 'userId',
    type: 'type',
    authToken: 'authToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalAuthScalarFieldEnum = (typeof ExternalAuthScalarFieldEnum)[keyof typeof ExternalAuthScalarFieldEnum]


  export const HighlightScalarFieldEnum: {
    id: 'id',
    highlightedRangeId: 'highlightedRangeId',
    timestamp: 'timestamp',
    interviewId: 'interviewId',
    videoId: 'videoId',
    transcriptId: 'transcriptId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    originSuggestionId: 'originSuggestionId'
  };

  export type HighlightScalarFieldEnum = (typeof HighlightScalarFieldEnum)[keyof typeof HighlightScalarFieldEnum]


  export const IdentityScalarFieldEnum: {
    token: 'token',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdentityScalarFieldEnum = (typeof IdentityScalarFieldEnum)[keyof typeof IdentityScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    recordingId: 'recordingId',
    workspaceId: 'workspaceId',
    creatorId: 'creatorId',
    archived: 'archived',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    recordingError: 'recordingError',
    projectId: 'projectId'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const InterviewSourceScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    platform: 'platform',
    interviewId: 'interviewId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewSourceScalarFieldEnum = (typeof InterviewSourceScalarFieldEnum)[keyof typeof InterviewSourceScalarFieldEnum]


  export const InterviewSummaryScalarFieldEnum: {
    id: 'id',
    text: 'text',
    generatedText: 'generatedText',
    touched: 'touched',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    interviewId: 'interviewId'
  };

  export type InterviewSummaryScalarFieldEnum = (typeof InterviewSummaryScalarFieldEnum)[keyof typeof InterviewSummaryScalarFieldEnum]


  export const NotificationPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationEmails: 'notificationEmails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferencesScalarFieldEnum = (typeof NotificationPreferencesScalarFieldEnum)[keyof typeof NotificationPreferencesScalarFieldEnum]


  export const ParticipantScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


  export const PlayableAssetScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    platform: 'platform',
    isSigned: 'isSigned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayableAssetScalarFieldEnum = (typeof PlayableAssetScalarFieldEnum)[keyof typeof PlayableAssetScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    workspaceId: 'workspaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectTagsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    tagId: 'tagId',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectTagsScalarFieldEnum = (typeof ProjectTagsScalarFieldEnum)[keyof typeof ProjectTagsScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RecorderScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    error: 'error',
    type: 'type',
    targetId: 'targetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type RecorderScalarFieldEnum = (typeof RecorderScalarFieldEnum)[keyof typeof RecorderScalarFieldEnum]


  export const RecordingTargetScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecordingTargetScalarFieldEnum = (typeof RecordingTargetScalarFieldEnum)[keyof typeof RecordingTargetScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    session: 'session',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SuggestedHighlightScalarFieldEnum: {
    id: 'id',
    highlightedRangeId: 'highlightedRangeId',
    interviewId: 'interviewId',
    transcriptId: 'transcriptId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuggestedHighlightScalarFieldEnum = (typeof SuggestedHighlightScalarFieldEnum)[keyof typeof SuggestedHighlightScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    workspaceId: 'workspaceId',
    autoExtract: 'autoExtract',
    description: 'description',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emoji: 'emoji'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TranscriptGroupScalarFieldEnum: {
    text: 'text',
    transcriptId: 'transcriptId',
    groupNumber: 'groupNumber',
    speakerId: 'speakerId'
  };

  export type TranscriptGroupScalarFieldEnum = (typeof TranscriptGroupScalarFieldEnum)[keyof typeof TranscriptGroupScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    version: 'version',
    interviewId: 'interviewId',
    isPending: 'isPending',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const TranscriptWordScalarFieldEnum: {
    transcriptId: 'transcriptId',
    groupNumber: 'groupNumber',
    wordNumber: 'wordNumber',
    start: 'start',
    end: 'end',
    text: 'text'
  };

  export type TranscriptWordScalarFieldEnum = (typeof TranscriptWordScalarFieldEnum)[keyof typeof TranscriptWordScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailHash: 'emailHash',
    fullName: 'fullName',
    confirmed: 'confirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTagOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tagId: 'tagId',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTagOrderScalarFieldEnum = (typeof UserTagOrderScalarFieldEnum)[keyof typeof UserTagOrderScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    recorderId: 'recorderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const WordRangeScalarFieldEnum: {
    id: 'id',
    transcriptId: 'transcriptId',
    startWordNumber: 'startWordNumber',
    startGroupNumber: 'startGroupNumber',
    endWordNumber: 'endWordNumber',
    endGroupNumber: 'endGroupNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WordRangeScalarFieldEnum = (typeof WordRangeScalarFieldEnum)[keyof typeof WordRangeScalarFieldEnum]


  export const WorkspaceInviteScalarFieldEnum: {
    token: 'token',
    workspaceId: 'workspaceId',
    inviterId: 'inviterId',
    isExpired: 'isExpired',
    inviteeEmail: 'inviteeEmail',
    isAccepted: 'isAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceInviteScalarFieldEnum = (typeof WorkspaceInviteScalarFieldEnum)[keyof typeof WorkspaceInviteScalarFieldEnum]


  export const WorkspaceRoleScalarFieldEnum: {
    userId: 'userId',
    workspaceId: 'workspaceId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceRoleScalarFieldEnum = (typeof WorkspaceRoleScalarFieldEnum)[keyof typeof WorkspaceRoleScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    publicInterviewLinks: 'publicInterviewLinks',
    ownedDomain: 'ownedDomain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type InterviewSummaryWhereInput = {
    AND?: Enumerable<InterviewSummaryWhereInput>
    OR?: Enumerable<InterviewSummaryWhereInput>
    NOT?: Enumerable<InterviewSummaryWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
    generatedText?: StringFilter | string
    touched?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput>
    interviewId?: StringFilter | string
  }

  export type InterviewSummaryOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    generatedText?: SortOrder
    touched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    interviewId?: SortOrder
  }

  export type InterviewSummaryWhereUniqueInput = {
    id?: string
    interviewId?: string
  }

  export type InterviewSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    generatedText?: SortOrder
    touched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interviewId?: SortOrder
    _count?: InterviewSummaryCountOrderByAggregateInput
    _max?: InterviewSummaryMaxOrderByAggregateInput
    _min?: InterviewSummaryMinOrderByAggregateInput
  }

  export type InterviewSummaryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InterviewSummaryScalarWhereWithAggregatesInput>
    OR?: Enumerable<InterviewSummaryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InterviewSummaryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    generatedText?: StringWithAggregatesFilter | string
    touched?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    interviewId?: StringWithAggregatesFilter | string
  }

  export type InterviewSourceWhereInput = {
    AND?: Enumerable<InterviewSourceWhereInput>
    OR?: Enumerable<InterviewSourceWhereInput>
    NOT?: Enumerable<InterviewSourceWhereInput>
    id?: IntFilter | number
    sourceId?: StringFilter | string
    platform?: EnumInterviewSourcePlatformsFilter | InterviewSourcePlatforms
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput>
    interviewId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InterviewSourceOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    platform?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    interviewId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSourceWhereUniqueInput = {
    id?: number
    interviewId?: string
  }

  export type InterviewSourceOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    platform?: SortOrder
    interviewId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterviewSourceCountOrderByAggregateInput
    _avg?: InterviewSourceAvgOrderByAggregateInput
    _max?: InterviewSourceMaxOrderByAggregateInput
    _min?: InterviewSourceMinOrderByAggregateInput
    _sum?: InterviewSourceSumOrderByAggregateInput
  }

  export type InterviewSourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InterviewSourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InterviewSourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InterviewSourceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sourceId?: StringWithAggregatesFilter | string
    platform?: EnumInterviewSourcePlatformsWithAggregatesFilter | InterviewSourcePlatforms
    interviewId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InterviewWhereInput = {
    AND?: Enumerable<InterviewWhereInput>
    OR?: Enumerable<InterviewWhereInput>
    NOT?: Enumerable<InterviewWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    recording?: XOR<VideoRelationFilter, VideoWhereInput> | null
    recordingId?: StringNullableFilter | string | null
    transcript?: XOR<TranscriptRelationFilter, TranscriptWhereInput> | null
    highlights?: HighlightListRelationFilter
    workspaceId?: StringFilter | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    source?: XOR<InterviewSourceRelationFilter, InterviewSourceWhereInput> | null
    summary?: XOR<InterviewSummaryRelationFilter, InterviewSummaryWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    creatorId?: StringFilter | string
    archived?: BoolFilter | boolean
    date?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    recordingError?: StringNullableFilter | string | null
    suggestedHighlights?: SuggestedHighlightListRelationFilter
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
    projectId?: StringNullableFilter | string | null
  }

  export type InterviewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    recording?: VideoOrderByWithRelationInput
    recordingId?: SortOrder
    transcript?: TranscriptOrderByWithRelationInput
    highlights?: HighlightOrderByRelationAggregateInput
    workspaceId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    source?: InterviewSourceOrderByWithRelationInput
    summary?: InterviewSummaryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    creatorId?: SortOrder
    archived?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordingError?: SortOrder
    suggestedHighlights?: SuggestedHighlightOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    projectId?: SortOrder
  }

  export type InterviewWhereUniqueInput = {
    id?: string
    recordingId?: string
  }

  export type InterviewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    recordingId?: SortOrder
    workspaceId?: SortOrder
    creatorId?: SortOrder
    archived?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordingError?: SortOrder
    projectId?: SortOrder
    _count?: InterviewCountOrderByAggregateInput
    _max?: InterviewMaxOrderByAggregateInput
    _min?: InterviewMinOrderByAggregateInput
  }

  export type InterviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InterviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<InterviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InterviewScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    recordingId?: StringNullableWithAggregatesFilter | string | null
    workspaceId?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    archived?: BoolWithAggregatesFilter | boolean
    date?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    recordingError?: StringNullableWithAggregatesFilter | string | null
    projectId?: StringNullableWithAggregatesFilter | string | null
  }

  export type VideoWhereInput = {
    AND?: Enumerable<VideoWhereInput>
    OR?: Enumerable<VideoWhereInput>
    NOT?: Enumerable<VideoWhereInput>
    id?: StringFilter | string
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput> | null
    highlight?: XOR<HighlightRelationFilter, HighlightWhereInput> | null
    startTime?: DateTimeFilter | Date | string
    editableAsset?: XOR<EditableAssetRelationFilter, EditableAssetWhereInput> | null
    playableAsset?: XOR<PlayableAssetRelationFilter, PlayableAssetWhereInput> | null
    recorder?: XOR<RecorderRelationFilter, RecorderWhereInput> | null
    recorderId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    highlight?: HighlightOrderByWithRelationInput
    startTime?: SortOrder
    editableAsset?: EditableAssetOrderByWithRelationInput
    playableAsset?: PlayableAssetOrderByWithRelationInput
    recorder?: RecorderOrderByWithRelationInput
    recorderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoWhereUniqueInput = {
    id?: string
  }

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    recorderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startTime?: DateTimeWithAggregatesFilter | Date | string
    recorderId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EditableAssetWhereInput = {
    AND?: Enumerable<EditableAssetWhereInput>
    OR?: Enumerable<EditableAssetWhereInput>
    NOT?: Enumerable<EditableAssetWhereInput>
    id?: StringFilter | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: StringFilter | string
    status?: EnumEditableAssetStatusFilter | EditableAssetStatus
    playbackId?: StringNullableFilter | string | null
    isSigned?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EditableAssetOrderByWithRelationInput = {
    id?: SortOrder
    video?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    status?: SortOrder
    playbackId?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditableAssetWhereUniqueInput = {
    id?: string
    videoId?: string
  }

  export type EditableAssetOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    playbackId?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EditableAssetCountOrderByAggregateInput
    _max?: EditableAssetMaxOrderByAggregateInput
    _min?: EditableAssetMinOrderByAggregateInput
  }

  export type EditableAssetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EditableAssetScalarWhereWithAggregatesInput>
    OR?: Enumerable<EditableAssetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EditableAssetScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    videoId?: StringWithAggregatesFilter | string
    status?: EnumEditableAssetStatusWithAggregatesFilter | EditableAssetStatus
    playbackId?: StringNullableWithAggregatesFilter | string | null
    isSigned?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PlayableAssetWhereInput = {
    AND?: Enumerable<PlayableAssetWhereInput>
    OR?: Enumerable<PlayableAssetWhereInput>
    NOT?: Enumerable<PlayableAssetWhereInput>
    id?: StringFilter | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: StringFilter | string
    platform?: EnumStoragePlatformsFilter | StoragePlatforms
    isSigned?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PlayableAssetOrderByWithRelationInput = {
    id?: SortOrder
    video?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    platform?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayableAssetWhereUniqueInput = {
    id?: string
    videoId?: string
  }

  export type PlayableAssetOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    platform?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayableAssetCountOrderByAggregateInput
    _max?: PlayableAssetMaxOrderByAggregateInput
    _min?: PlayableAssetMinOrderByAggregateInput
  }

  export type PlayableAssetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayableAssetScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayableAssetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayableAssetScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    videoId?: StringWithAggregatesFilter | string
    platform?: EnumStoragePlatformsWithAggregatesFilter | StoragePlatforms
    isSigned?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TranscriptWhereInput = {
    AND?: Enumerable<TranscriptWhereInput>
    OR?: Enumerable<TranscriptWhereInput>
    NOT?: Enumerable<TranscriptWhereInput>
    id?: StringFilter | string
    version?: IntFilter | number
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput> | null
    interviewId?: StringNullableFilter | string | null
    highlight?: XOR<HighlightRelationFilter, HighlightWhereInput> | null
    suggestedHighlight?: XOR<SuggestedHighlightRelationFilter, SuggestedHighlightWhereInput> | null
    isPending?: BoolFilter | boolean
    words?: TranscriptWordListRelationFilter
    groups?: TranscriptGroupListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    interviewId?: SortOrder
    highlight?: HighlightOrderByWithRelationInput
    suggestedHighlight?: SuggestedHighlightOrderByWithRelationInput
    isPending?: SortOrder
    words?: TranscriptWordOrderByRelationAggregateInput
    groups?: TranscriptGroupOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptWhereUniqueInput = {
    id?: string
    interviewId?: string
  }

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    interviewId?: SortOrder
    isPending?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _avg?: TranscriptAvgOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
    _sum?: TranscriptSumOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TranscriptScalarWhereWithAggregatesInput>
    OR?: Enumerable<TranscriptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TranscriptScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    version?: IntWithAggregatesFilter | number
    interviewId?: StringNullableWithAggregatesFilter | string | null
    isPending?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TranscriptGroupWhereInput = {
    AND?: Enumerable<TranscriptGroupWhereInput>
    OR?: Enumerable<TranscriptGroupWhereInput>
    NOT?: Enumerable<TranscriptGroupWhereInput>
    transcript?: XOR<TranscriptRelationFilter, TranscriptWhereInput>
    words?: TranscriptWordListRelationFilter
    text?: StringFilter | string
    transcriptId?: StringFilter | string
    groupNumber?: IntFilter | number
    speakerId?: StringFilter | string
    speaker?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
  }

  export type TranscriptGroupOrderByWithRelationInput = {
    transcript?: TranscriptOrderByWithRelationInput
    words?: TranscriptWordOrderByRelationAggregateInput
    text?: SortOrder
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    speakerId?: SortOrder
    speaker?: ParticipantOrderByWithRelationInput
  }

  export type TranscriptGroupWhereUniqueInput = {
    transcriptId_groupNumber?: TranscriptGroupTranscriptIdGroupNumberCompoundUniqueInput
  }

  export type TranscriptGroupOrderByWithAggregationInput = {
    text?: SortOrder
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    speakerId?: SortOrder
    _count?: TranscriptGroupCountOrderByAggregateInput
    _avg?: TranscriptGroupAvgOrderByAggregateInput
    _max?: TranscriptGroupMaxOrderByAggregateInput
    _min?: TranscriptGroupMinOrderByAggregateInput
    _sum?: TranscriptGroupSumOrderByAggregateInput
  }

  export type TranscriptGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TranscriptGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<TranscriptGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TranscriptGroupScalarWhereWithAggregatesInput>
    text?: StringWithAggregatesFilter | string
    transcriptId?: StringWithAggregatesFilter | string
    groupNumber?: IntWithAggregatesFilter | number
    speakerId?: StringWithAggregatesFilter | string
  }

  export type TranscriptWordWhereInput = {
    AND?: Enumerable<TranscriptWordWhereInput>
    OR?: Enumerable<TranscriptWordWhereInput>
    NOT?: Enumerable<TranscriptWordWhereInput>
    transcript?: XOR<TranscriptRelationFilter, TranscriptWhereInput>
    group?: XOR<TranscriptGroupRelationFilter, TranscriptGroupWhereInput>
    transcriptId?: StringFilter | string
    groupNumber?: IntFilter | number
    wordNumber?: IntFilter | number
    start?: FloatFilter | number
    end?: FloatFilter | number
    text?: StringFilter | string
    startWordRanges?: WordRangeListRelationFilter
    endWordRanges?: WordRangeListRelationFilter
  }

  export type TranscriptWordOrderByWithRelationInput = {
    transcript?: TranscriptOrderByWithRelationInput
    group?: TranscriptGroupOrderByWithRelationInput
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
    text?: SortOrder
    startWordRanges?: WordRangeOrderByRelationAggregateInput
    endWordRanges?: WordRangeOrderByRelationAggregateInput
  }

  export type TranscriptWordWhereUniqueInput = {
    transcriptId_groupNumber_wordNumber?: TranscriptWordTranscriptIdGroupNumberWordNumberCompoundUniqueInput
  }

  export type TranscriptWordOrderByWithAggregationInput = {
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
    text?: SortOrder
    _count?: TranscriptWordCountOrderByAggregateInput
    _avg?: TranscriptWordAvgOrderByAggregateInput
    _max?: TranscriptWordMaxOrderByAggregateInput
    _min?: TranscriptWordMinOrderByAggregateInput
    _sum?: TranscriptWordSumOrderByAggregateInput
  }

  export type TranscriptWordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TranscriptWordScalarWhereWithAggregatesInput>
    OR?: Enumerable<TranscriptWordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TranscriptWordScalarWhereWithAggregatesInput>
    transcriptId?: StringWithAggregatesFilter | string
    groupNumber?: IntWithAggregatesFilter | number
    wordNumber?: IntWithAggregatesFilter | number
    start?: FloatWithAggregatesFilter | number
    end?: FloatWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
  }

  export type WordRangeWhereInput = {
    AND?: Enumerable<WordRangeWhereInput>
    OR?: Enumerable<WordRangeWhereInput>
    NOT?: Enumerable<WordRangeWhereInput>
    id?: StringFilter | string
    startWord?: XOR<TranscriptWordRelationFilter, TranscriptWordWhereInput>
    transcriptId?: StringFilter | string
    startWordNumber?: IntFilter | number
    startGroupNumber?: IntFilter | number
    endWord?: XOR<TranscriptWordRelationFilter, TranscriptWordWhereInput>
    endWordNumber?: IntFilter | number
    endGroupNumber?: IntFilter | number
    highlight?: XOR<HighlightRelationFilter, HighlightWhereInput> | null
    suggestedHighlight?: XOR<SuggestedHighlightRelationFilter, SuggestedHighlightWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WordRangeOrderByWithRelationInput = {
    id?: SortOrder
    startWord?: TranscriptWordOrderByWithRelationInput
    transcriptId?: SortOrder
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWord?: TranscriptWordOrderByWithRelationInput
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
    highlight?: HighlightOrderByWithRelationInput
    suggestedHighlight?: SuggestedHighlightOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WordRangeWhereUniqueInput = {
    id?: string
  }

  export type WordRangeOrderByWithAggregationInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WordRangeCountOrderByAggregateInput
    _avg?: WordRangeAvgOrderByAggregateInput
    _max?: WordRangeMaxOrderByAggregateInput
    _min?: WordRangeMinOrderByAggregateInput
    _sum?: WordRangeSumOrderByAggregateInput
  }

  export type WordRangeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WordRangeScalarWhereWithAggregatesInput>
    OR?: Enumerable<WordRangeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WordRangeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    transcriptId?: StringWithAggregatesFilter | string
    startWordNumber?: IntWithAggregatesFilter | number
    startGroupNumber?: IntWithAggregatesFilter | number
    endWordNumber?: IntWithAggregatesFilter | number
    endGroupNumber?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HighlightWhereInput = {
    AND?: Enumerable<HighlightWhereInput>
    OR?: Enumerable<HighlightWhereInput>
    NOT?: Enumerable<HighlightWhereInput>
    id?: StringFilter | string
    highlightedRange?: XOR<WordRangeRelationFilter, WordRangeWhereInput> | null
    highlightedRangeId?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput>
    interviewId?: StringFilter | string
    videoId?: StringNullableFilter | string | null
    video?: XOR<VideoRelationFilter, VideoWhereInput> | null
    transcriptId?: StringNullableFilter | string | null
    transcript?: XOR<TranscriptRelationFilter, TranscriptWhereInput> | null
    tags?: TagListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    originSuggestion?: XOR<SuggestedHighlightRelationFilter, SuggestedHighlightWhereInput> | null
    originSuggestionId?: StringNullableFilter | string | null
  }

  export type HighlightOrderByWithRelationInput = {
    id?: SortOrder
    highlightedRange?: WordRangeOrderByWithRelationInput
    highlightedRangeId?: SortOrder
    timestamp?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    interviewId?: SortOrder
    videoId?: SortOrder
    video?: VideoOrderByWithRelationInput
    transcriptId?: SortOrder
    transcript?: TranscriptOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originSuggestion?: SuggestedHighlightOrderByWithRelationInput
    originSuggestionId?: SortOrder
  }

  export type HighlightWhereUniqueInput = {
    id?: string
    highlightedRangeId?: string
    videoId?: string
    transcriptId?: string
    originSuggestionId?: string
  }

  export type HighlightOrderByWithAggregationInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    timestamp?: SortOrder
    interviewId?: SortOrder
    videoId?: SortOrder
    transcriptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originSuggestionId?: SortOrder
    _count?: HighlightCountOrderByAggregateInput
    _max?: HighlightMaxOrderByAggregateInput
    _min?: HighlightMinOrderByAggregateInput
  }

  export type HighlightScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HighlightScalarWhereWithAggregatesInput>
    OR?: Enumerable<HighlightScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HighlightScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    highlightedRangeId?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    interviewId?: StringWithAggregatesFilter | string
    videoId?: StringNullableWithAggregatesFilter | string | null
    transcriptId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    originSuggestionId?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    session?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    session?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    session?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    session?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    emailHash?: StringNullableFilter | string | null
    fullName?: StringFilter | string
    confirmed?: BoolFilter | boolean
    interviews?: InterviewListRelationFilter
    roles?: WorkspaceRoleListRelationFilter
    sourceAuths?: ExternalAuthListRelationFilter
    identities?: IdentityListRelationFilter
    inviteTokens?: WorkspaceInviteListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    notificationPreferences?: XOR<NotificationPreferencesRelationFilter, NotificationPreferencesWhereInput> | null
    tagOrder?: UserTagOrderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailHash?: SortOrder
    fullName?: SortOrder
    confirmed?: SortOrder
    interviews?: InterviewOrderByRelationAggregateInput
    roles?: WorkspaceRoleOrderByRelationAggregateInput
    sourceAuths?: ExternalAuthOrderByRelationAggregateInput
    identities?: IdentityOrderByRelationAggregateInput
    inviteTokens?: WorkspaceInviteOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notificationPreferences?: NotificationPreferencesOrderByWithRelationInput
    tagOrder?: UserTagOrderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    emailHash?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailHash?: SortOrder
    fullName?: SortOrder
    confirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    emailHash?: StringNullableWithAggregatesFilter | string | null
    fullName?: StringWithAggregatesFilter | string
    confirmed?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IdentityWhereInput = {
    AND?: Enumerable<IdentityWhereInput>
    OR?: Enumerable<IdentityWhereInput>
    NOT?: Enumerable<IdentityWhereInput>
    token?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    type?: EnumIdentityTypeFilter | IdentityType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IdentityOrderByWithRelationInput = {
    token?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentityWhereUniqueInput = {
    type_token?: IdentityTypeTokenCompoundUniqueInput
    userId_type?: IdentityUserIdTypeCompoundUniqueInput
  }

  export type IdentityOrderByWithAggregationInput = {
    token?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdentityCountOrderByAggregateInput
    _max?: IdentityMaxOrderByAggregateInput
    _min?: IdentityMinOrderByAggregateInput
  }

  export type IdentityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IdentityScalarWhereWithAggregatesInput>
    OR?: Enumerable<IdentityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IdentityScalarWhereWithAggregatesInput>
    token?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: EnumIdentityTypeWithAggregatesFilter | IdentityType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ExternalAuthWhereInput = {
    AND?: Enumerable<ExternalAuthWhereInput>
    OR?: Enumerable<ExternalAuthWhereInput>
    NOT?: Enumerable<ExternalAuthWhereInput>
    userId?: StringFilter | string
    type?: EnumExternalAuthTypesFilter | ExternalAuthTypes
    user?: XOR<UserRelationFilter, UserWhereInput>
    authToken?: StringFilter | string
    refreshToken?: StringFilter | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ExternalAuthOrderByWithRelationInput = {
    userId?: SortOrder
    type?: SortOrder
    user?: UserOrderByWithRelationInput
    authToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuthWhereUniqueInput = {
    userId_type?: ExternalAuthUserIdTypeCompoundUniqueInput
  }

  export type ExternalAuthOrderByWithAggregationInput = {
    userId?: SortOrder
    type?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalAuthCountOrderByAggregateInput
    _max?: ExternalAuthMaxOrderByAggregateInput
    _min?: ExternalAuthMinOrderByAggregateInput
  }

  export type ExternalAuthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExternalAuthScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExternalAuthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExternalAuthScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    type?: EnumExternalAuthTypesWithAggregatesFilter | ExternalAuthTypes
    authToken?: StringWithAggregatesFilter | string
    refreshToken?: StringWithAggregatesFilter | string
    expiresAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WorkspaceWhereInput = {
    AND?: Enumerable<WorkspaceWhereInput>
    OR?: Enumerable<WorkspaceWhereInput>
    NOT?: Enumerable<WorkspaceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    roles?: WorkspaceRoleListRelationFilter
    interviews?: InterviewListRelationFilter
    inviteTokens?: WorkspaceInviteListRelationFilter
    publicInterviewLinks?: BoolFilter | boolean
    ownedDomain?: StringNullableFilter | string | null
    tags?: TagListRelationFilter
    projects?: ProjectListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    roles?: WorkspaceRoleOrderByRelationAggregateInput
    interviews?: InterviewOrderByRelationAggregateInput
    inviteTokens?: WorkspaceInviteOrderByRelationAggregateInput
    publicInterviewLinks?: SortOrder
    ownedDomain?: SortOrder
    tags?: TagOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceWhereUniqueInput = {
    id?: string
    ownedDomain?: string
  }

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    publicInterviewLinks?: SortOrder
    ownedDomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    publicInterviewLinks?: BoolWithAggregatesFilter | boolean
    ownedDomain?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WorkspaceInviteWhereInput = {
    AND?: Enumerable<WorkspaceInviteWhereInput>
    OR?: Enumerable<WorkspaceInviteWhereInput>
    NOT?: Enumerable<WorkspaceInviteWhereInput>
    token?: StringFilter | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    workspaceId?: StringFilter | string
    inviterId?: StringFilter | string
    isExpired?: BoolFilter | boolean
    inviteeEmail?: StringNullableFilter | string | null
    isAccepted?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WorkspaceInviteOrderByWithRelationInput = {
    token?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    workspaceId?: SortOrder
    inviterId?: SortOrder
    isExpired?: SortOrder
    inviteeEmail?: SortOrder
    isAccepted?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceInviteWhereUniqueInput = {
    token?: string
  }

  export type WorkspaceInviteOrderByWithAggregationInput = {
    token?: SortOrder
    workspaceId?: SortOrder
    inviterId?: SortOrder
    isExpired?: SortOrder
    inviteeEmail?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceInviteCountOrderByAggregateInput
    _max?: WorkspaceInviteMaxOrderByAggregateInput
    _min?: WorkspaceInviteMinOrderByAggregateInput
  }

  export type WorkspaceInviteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkspaceInviteScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkspaceInviteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkspaceInviteScalarWhereWithAggregatesInput>
    token?: StringWithAggregatesFilter | string
    workspaceId?: StringWithAggregatesFilter | string
    inviterId?: StringWithAggregatesFilter | string
    isExpired?: BoolWithAggregatesFilter | boolean
    inviteeEmail?: StringNullableWithAggregatesFilter | string | null
    isAccepted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WorkspaceRoleWhereInput = {
    AND?: Enumerable<WorkspaceRoleWhereInput>
    OR?: Enumerable<WorkspaceRoleWhereInput>
    NOT?: Enumerable<WorkspaceRoleWhereInput>
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspaceId?: StringFilter | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    type?: EnumRoleTypeFilter | RoleType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WorkspaceRoleOrderByWithRelationInput = {
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    workspaceId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceRoleWhereUniqueInput = {
    userId_workspaceId?: WorkspaceRoleUserIdWorkspaceIdCompoundUniqueInput
  }

  export type WorkspaceRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceRoleCountOrderByAggregateInput
    _max?: WorkspaceRoleMaxOrderByAggregateInput
    _min?: WorkspaceRoleMinOrderByAggregateInput
  }

  export type WorkspaceRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkspaceRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkspaceRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkspaceRoleScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    workspaceId?: StringWithAggregatesFilter | string
    type?: EnumRoleTypeWithAggregatesFilter | RoleType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ParticipantWhereInput = {
    AND?: Enumerable<ParticipantWhereInput>
    OR?: Enumerable<ParticipantWhereInput>
    NOT?: Enumerable<ParticipantWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    groups?: TranscriptGroupListRelationFilter
  }

  export type ParticipantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    groups?: TranscriptGroupOrderByRelationAggregateInput
  }

  export type ParticipantWhereUniqueInput = {
    id?: string
  }

  export type ParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ParticipantCountOrderByAggregateInput
    _max?: ParticipantMaxOrderByAggregateInput
    _min?: ParticipantMinOrderByAggregateInput
  }

  export type ParticipantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParticipantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParticipantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParticipantScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    color?: EnumTagColorFilter | TagColor
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    workspaceId?: StringFilter | string
    highlights?: HighlightListRelationFilter
    suggestedHighlights?: SuggestedHighlightListRelationFilter
    userOrders?: UserTagOrderListRelationFilter
    autoExtract?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    isDefault?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    projectTags?: ProjectTagsListRelationFilter
    emoji?: StringFilter | string
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    workspaceId?: SortOrder
    highlights?: HighlightOrderByRelationAggregateInput
    suggestedHighlights?: SuggestedHighlightOrderByRelationAggregateInput
    userOrders?: UserTagOrderOrderByRelationAggregateInput
    autoExtract?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectTags?: ProjectTagsOrderByRelationAggregateInput
    emoji?: SortOrder
  }

  export type TagWhereUniqueInput = {
    id?: string
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    workspaceId?: SortOrder
    autoExtract?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emoji?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    color?: EnumTagColorWithAggregatesFilter | TagColor
    workspaceId?: StringWithAggregatesFilter | string
    autoExtract?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
    isDefault?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    emoji?: StringWithAggregatesFilter | string
  }

  export type NotificationPreferencesWhereInput = {
    AND?: Enumerable<NotificationPreferencesWhereInput>
    OR?: Enumerable<NotificationPreferencesWhereInput>
    NOT?: Enumerable<NotificationPreferencesWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    notificationEmails?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    notificationEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferencesWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type NotificationPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferencesCountOrderByAggregateInput
    _max?: NotificationPreferencesMaxOrderByAggregateInput
    _min?: NotificationPreferencesMinOrderByAggregateInput
  }

  export type NotificationPreferencesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationPreferencesScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationPreferencesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationPreferencesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    notificationEmails?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserTagOrderWhereInput = {
    AND?: Enumerable<UserTagOrderWhereInput>
    OR?: Enumerable<UserTagOrderWhereInput>
    NOT?: Enumerable<UserTagOrderWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tagId?: StringFilter | string
    tag?: XOR<TagRelationFilter, TagWhereInput>
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserTagOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    tagId?: SortOrder
    tag?: TagOrderByWithRelationInput
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagOrderWhereUniqueInput = {
    id?: string
    userId_tagId?: UserTagOrderUserIdTagIdCompoundUniqueInput
  }

  export type UserTagOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTagOrderCountOrderByAggregateInput
    _avg?: UserTagOrderAvgOrderByAggregateInput
    _max?: UserTagOrderMaxOrderByAggregateInput
    _min?: UserTagOrderMinOrderByAggregateInput
    _sum?: UserTagOrderSumOrderByAggregateInput
  }

  export type UserTagOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserTagOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserTagOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserTagOrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    tagId?: StringWithAggregatesFilter | string
    position?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SuggestedHighlightWhereInput = {
    AND?: Enumerable<SuggestedHighlightWhereInput>
    OR?: Enumerable<SuggestedHighlightWhereInput>
    NOT?: Enumerable<SuggestedHighlightWhereInput>
    id?: StringFilter | string
    highlightedRange?: XOR<WordRangeRelationFilter, WordRangeWhereInput>
    highlightedRangeId?: StringFilter | string
    interview?: XOR<InterviewRelationFilter, InterviewWhereInput>
    interviewId?: StringFilter | string
    transcriptId?: StringFilter | string
    transcript?: XOR<TranscriptRelationFilter, TranscriptWhereInput>
    tags?: TagListRelationFilter
    status?: EnumSuggestedHighlightStatusFilter | SuggestedHighlightStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    highlight?: XOR<HighlightRelationFilter, HighlightWhereInput> | null
  }

  export type SuggestedHighlightOrderByWithRelationInput = {
    id?: SortOrder
    highlightedRange?: WordRangeOrderByWithRelationInput
    highlightedRangeId?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    interviewId?: SortOrder
    transcriptId?: SortOrder
    transcript?: TranscriptOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highlight?: HighlightOrderByWithRelationInput
  }

  export type SuggestedHighlightWhereUniqueInput = {
    id?: string
    highlightedRangeId?: string
    transcriptId?: string
  }

  export type SuggestedHighlightOrderByWithAggregationInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    interviewId?: SortOrder
    transcriptId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuggestedHighlightCountOrderByAggregateInput
    _max?: SuggestedHighlightMaxOrderByAggregateInput
    _min?: SuggestedHighlightMinOrderByAggregateInput
  }

  export type SuggestedHighlightScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SuggestedHighlightScalarWhereWithAggregatesInput>
    OR?: Enumerable<SuggestedHighlightScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SuggestedHighlightScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    highlightedRangeId?: StringWithAggregatesFilter | string
    interviewId?: StringWithAggregatesFilter | string
    transcriptId?: StringWithAggregatesFilter | string
    status?: EnumSuggestedHighlightStatusWithAggregatesFilter | SuggestedHighlightStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    interviews?: InterviewListRelationFilter
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    workspaceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    projectTags?: ProjectTagsListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    interviews?: InterviewOrderByRelationAggregateInput
    workspace?: WorkspaceOrderByWithRelationInput
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectTags?: ProjectTagsOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = {
    id?: string
  }

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    workspaceId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectTagsWhereInput = {
    AND?: Enumerable<ProjectTagsWhereInput>
    OR?: Enumerable<ProjectTagsWhereInput>
    NOT?: Enumerable<ProjectTagsWhereInput>
    id?: StringFilter | string
    projectId?: StringFilter | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    tagId?: StringFilter | string
    tag?: XOR<TagRelationFilter, TagWhereInput>
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProjectTagsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tagId?: SortOrder
    tag?: TagOrderByWithRelationInput
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTagsWhereUniqueInput = {
    id?: string
    projectId_tagId?: ProjectTagsProjectIdTagIdCompoundUniqueInput
  }

  export type ProjectTagsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectTagsCountOrderByAggregateInput
    _avg?: ProjectTagsAvgOrderByAggregateInput
    _max?: ProjectTagsMaxOrderByAggregateInput
    _min?: ProjectTagsMinOrderByAggregateInput
    _sum?: ProjectTagsSumOrderByAggregateInput
  }

  export type ProjectTagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectTagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectTagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectTagsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    projectId?: StringWithAggregatesFilter | string
    tagId?: StringWithAggregatesFilter | string
    position?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RecorderWhereInput = {
    AND?: Enumerable<RecorderWhereInput>
    OR?: Enumerable<RecorderWhereInput>
    NOT?: Enumerable<RecorderWhereInput>
    id?: StringFilter | string
    externalId?: StringNullableFilter | string | null
    error?: StringNullableFilter | string | null
    type?: EnumRecorderTypeFilter | RecorderType
    target?: XOR<RecordingTargetRelationFilter, RecordingTargetWhereInput>
    targetId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Video?: VideoListRelationFilter
    status?: EnumRecorderStatusFilter | RecorderStatus
  }

  export type RecorderOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    error?: SortOrder
    type?: SortOrder
    target?: RecordingTargetOrderByWithRelationInput
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Video?: VideoOrderByRelationAggregateInput
    status?: SortOrder
  }

  export type RecorderWhereUniqueInput = {
    id?: string
    externalId?: string
    targetId?: string
  }

  export type RecorderOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    error?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: RecorderCountOrderByAggregateInput
    _max?: RecorderMaxOrderByAggregateInput
    _min?: RecorderMinOrderByAggregateInput
  }

  export type RecorderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecorderScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecorderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecorderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    externalId?: StringNullableWithAggregatesFilter | string | null
    error?: StringNullableWithAggregatesFilter | string | null
    type?: EnumRecorderTypeWithAggregatesFilter | RecorderType
    targetId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumRecorderStatusWithAggregatesFilter | RecorderStatus
  }

  export type RecordingTargetWhereInput = {
    AND?: Enumerable<RecordingTargetWhereInput>
    OR?: Enumerable<RecordingTargetWhereInput>
    NOT?: Enumerable<RecordingTargetWhereInput>
    id?: StringFilter | string
    type?: EnumRecordingTargetTypeFilter | RecordingTargetType
    recorder?: XOR<RecorderRelationFilter, RecorderWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RecordingTargetOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    recorder?: RecorderOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecordingTargetWhereUniqueInput = {
    id?: string
  }

  export type RecordingTargetOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecordingTargetCountOrderByAggregateInput
    _max?: RecordingTargetMaxOrderByAggregateInput
    _min?: RecordingTargetMinOrderByAggregateInput
  }

  export type RecordingTargetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecordingTargetScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecordingTargetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecordingTargetScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumRecordingTargetTypeWithAggregatesFilter | RecordingTargetType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InterviewSummaryCreateInput = {
    id?: string
    text: string
    generatedText?: string
    touched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interview: InterviewCreateNestedOneWithoutSummaryInput
  }

  export type InterviewSummaryUncheckedCreateInput = {
    id?: string
    text: string
    generatedText?: string
    touched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interviewId: string
  }

  export type InterviewSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: InterviewUpdateOneRequiredWithoutSummaryNestedInput
  }

  export type InterviewSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSummaryCreateManyInput = {
    id?: string
    text: string
    generatedText?: string
    touched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interviewId: string
  }

  export type InterviewSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewId?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewSourceCreateInput = {
    sourceId: string
    platform: InterviewSourcePlatforms
    interview: InterviewCreateNestedOneWithoutSourceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSourceUncheckedCreateInput = {
    id?: number
    sourceId: string
    platform: InterviewSourcePlatforms
    interviewId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSourceUpdateInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    interview?: InterviewUpdateOneRequiredWithoutSourceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    interviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSourceCreateManyInput = {
    id?: number
    sourceId: string
    platform: InterviewSourcePlatforms
    interviewId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSourceUpdateManyMutationInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    interviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewCreateManyInput = {
    id?: string
    name?: string
    recordingId?: string | null
    workspaceId: string
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    projectId?: string | null
  }

  export type InterviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCreateInput = {
    id?: string
    interview?: InterviewCreateNestedOneWithoutRecordingInput
    highlight?: HighlightCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetCreateNestedOneWithoutVideoInput
    recorder?: RecorderCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    interview?: InterviewUncheckedCreateNestedOneWithoutRecordingInput
    highlight?: HighlightUncheckedCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetUncheckedCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetUncheckedCreateNestedOneWithoutVideoInput
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUpdateOneWithoutVideoNestedInput
    recorder?: RecorderUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUncheckedUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUncheckedUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUncheckedUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: string
    startTime?: Date | string
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditableAssetCreateInput = {
    id?: string
    video: VideoCreateNestedOneWithoutEditableAssetInput
    status: EditableAssetStatus
    playbackId?: string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditableAssetUncheckedCreateInput = {
    id?: string
    videoId: string
    status: EditableAssetStatus
    playbackId?: string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditableAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    video?: VideoUpdateOneRequiredWithoutEditableAssetNestedInput
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditableAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditableAssetCreateManyInput = {
    id?: string
    videoId: string
    status: EditableAssetStatus
    playbackId?: string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditableAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditableAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetCreateInput = {
    id?: string
    video: VideoCreateNestedOneWithoutPlayableAssetInput
    platform: StoragePlatforms
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayableAssetUncheckedCreateInput = {
    id?: string
    videoId: string
    platform: StoragePlatforms
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayableAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    video?: VideoUpdateOneRequiredWithoutPlayableAssetNestedInput
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetCreateManyInput = {
    id?: string
    videoId: string
    platform: StoragePlatforms
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayableAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateInput = {
    id?: string
    version?: number
    interview?: InterviewCreateNestedOneWithoutTranscriptInput
    highlight?: HighlightCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    version?: number
    interviewId?: string | null
    highlight?: HighlightUncheckedCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneWithoutTranscriptNestedInput
    highlight?: HighlightUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    highlight?: HighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateManyInput = {
    id?: string
    version?: number
    interviewId?: string | null
    isPending: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isPending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    isPending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptGroupCreateInput = {
    transcript: TranscriptCreateNestedOneWithoutGroupsInput
    words?: TranscriptWordCreateNestedManyWithoutGroupInput
    text: string
    groupNumber: number
    speaker: ParticipantCreateNestedOneWithoutGroupsInput
  }

  export type TranscriptGroupUncheckedCreateInput = {
    words?: TranscriptWordUncheckedCreateNestedManyWithoutGroupInput
    text: string
    transcriptId: string
    groupNumber: number
    speakerId: string
  }

  export type TranscriptGroupUpdateInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutGroupsNestedInput
    words?: TranscriptWordUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speaker?: ParticipantUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type TranscriptGroupUncheckedUpdateInput = {
    words?: TranscriptWordUncheckedUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptGroupCreateManyInput = {
    text: string
    transcriptId: string
    groupNumber: number
    speakerId: string
  }

  export type TranscriptGroupUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
  }

  export type TranscriptGroupUncheckedUpdateManyInput = {
    text?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptWordCreateInput = {
    transcript: TranscriptCreateNestedOneWithoutWordsInput
    group: TranscriptGroupCreateNestedOneWithoutWordsInput
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordUncheckedCreateInput = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeUncheckedCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeUncheckedCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordUpdateInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutWordsNestedInput
    group?: TranscriptGroupUpdateOneRequiredWithoutWordsNestedInput
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateInput = {
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUncheckedUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUncheckedUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordCreateManyInput = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
  }

  export type TranscriptWordUpdateManyMutationInput = {
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptWordUncheckedUpdateManyInput = {
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type WordRangeCreateInput = {
    id?: string
    startWord: TranscriptWordCreateNestedOneWithoutStartWordRangesInput
    endWord: TranscriptWordCreateNestedOneWithoutEndWordRangesInput
    highlight?: HighlightCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUncheckedCreateInput = {
    id?: string
    transcriptId: string
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    highlight?: HighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWord?: TranscriptWordUpdateOneRequiredWithoutStartWordRangesNestedInput
    endWord?: TranscriptWordUpdateOneRequiredWithoutEndWordRangesNestedInput
    highlight?: HighlightUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeCreateManyInput = {
    id?: string
    transcriptId: string
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HighlightCreateInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    video?: VideoCreateNestedOneWithoutHighlightInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    transcriptId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    video?: VideoUpdateOneWithoutHighlightNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HighlightCreateManyInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    transcriptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HighlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    session: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id: string
    session: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    session: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityCreateInput = {
    token: string
    user: UserCreateNestedOneWithoutIdentitiesInput
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityUncheckedCreateInput = {
    token: string
    userId: string
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIdentitiesNestedInput
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityCreateManyInput = {
    token: string
    userId: string
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthCreateInput = {
    type: ExternalAuthTypes
    user: UserCreateNestedOneWithoutSourceAuthsInput
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthUncheckedCreateInput = {
    userId: string
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthUpdateInput = {
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    user?: UserUpdateOneRequiredWithoutSourceAuthsNestedInput
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthCreateManyInput = {
    userId: string
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthUpdateManyMutationInput = {
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteCreateInput = {
    token: string
    workspace: WorkspaceCreateNestedOneWithoutInviteTokensInput
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    user: UserCreateNestedOneWithoutInviteTokensInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteUncheckedCreateInput = {
    token: string
    workspaceId: string
    inviterId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInviteTokensNestedInput
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutInviteTokensNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteCreateManyInput = {
    token: string
    workspaceId: string
    inviterId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    workspace: WorkspaceCreateNestedOneWithoutRolesInput
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUncheckedCreateInput = {
    userId: string
    workspaceId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutRolesNestedInput
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleCreateManyInput = {
    userId: string
    workspaceId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUpdateManyMutationInput = {
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantCreateInput = {
    id?: string
    name: string
    groups?: TranscriptGroupCreateNestedManyWithoutSpeakerInput
  }

  export type ParticipantUncheckedCreateInput = {
    id?: string
    name: string
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type ParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groups?: TranscriptGroupUpdateManyWithoutSpeakerNestedInput
  }

  export type ParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groups?: TranscriptGroupUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type ParticipantCreateManyInput = {
    id?: string
    name: string
  }

  export type ParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: TagColor
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
    highlights?: HighlightCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    highlights?: HighlightUncheckedCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderUncheckedCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
    highlights?: HighlightUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    highlights?: HighlightUncheckedUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUncheckedUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emoji?: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationPreferencesCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
    notificationEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    notificationEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferencesCreateManyInput = {
    id?: string
    userId: string
    notificationEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutTagOrderInput
    tag: TagCreateNestedOneWithoutUserOrdersInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderUncheckedCreateInput = {
    id?: string
    userId: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTagOrderNestedInput
    tag?: TagUpdateOneRequiredWithoutUserOrdersNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderCreateManyInput = {
    id?: string
    userId: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedHighlightCreateInput = {
    id?: string
    highlightedRange: WordRangeCreateNestedOneWithoutSuggestedHighlightInput
    interview: InterviewCreateNestedOneWithoutSuggestedHighlightsInput
    transcript: TranscriptCreateNestedOneWithoutSuggestedHighlightInput
    tags?: TagCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUncheckedCreateInput = {
    id?: string
    highlightedRangeId: string
    interviewId: string
    transcriptId: string
    tags?: TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    interview?: InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    tags?: TagUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightCreateManyInput = {
    id?: string
    highlightedRangeId: string
    interviewId: string
    transcriptId: string
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuggestedHighlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedHighlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewCreateNestedManyWithoutProjectInput
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewUncheckedCreateNestedManyWithoutProjectInput
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUpdateManyWithoutProjectNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUncheckedUpdateManyWithoutProjectNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsCreateInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutProjectTagsInput
    tag: TagCreateNestedOneWithoutProjectTagsInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsUncheckedCreateInput = {
    id?: string
    projectId: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutProjectTagsNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsCreateManyInput = {
    id?: string
    projectId: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecorderCreateInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    target: RecordingTargetCreateNestedOneWithoutRecorderInput
    createdAt?: Date | string
    updatedAt?: Date | string
    Video?: VideoCreateNestedManyWithoutRecorderInput
    status: RecorderStatus
  }

  export type RecorderUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Video?: VideoUncheckedCreateNestedManyWithoutRecorderInput
    status: RecorderStatus
  }

  export type RecorderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    target?: RecordingTargetUpdateOneRequiredWithoutRecorderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: VideoUpdateManyWithoutRecorderNestedInput
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecorderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: VideoUncheckedUpdateManyWithoutRecorderNestedInput
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecorderCreateManyInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: RecorderStatus
  }

  export type RecorderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecorderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecordingTargetCreateInput = {
    id?: string
    type: RecordingTargetType
    recorder?: RecorderCreateNestedOneWithoutTargetInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordingTargetUncheckedCreateInput = {
    id?: string
    type: RecordingTargetType
    recorder?: RecorderUncheckedCreateNestedOneWithoutTargetInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordingTargetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    recorder?: RecorderUpdateOneWithoutTargetNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingTargetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    recorder?: RecorderUncheckedUpdateOneWithoutTargetNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingTargetCreateManyInput = {
    id?: string
    type: RecordingTargetType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordingTargetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingTargetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type InterviewRelationFilter = {
    is?: InterviewWhereInput | null
    isNot?: InterviewWhereInput | null
  }

  export type InterviewSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    generatedText?: SortOrder
    touched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interviewId?: SortOrder
  }

  export type InterviewSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    generatedText?: SortOrder
    touched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interviewId?: SortOrder
  }

  export type InterviewSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    generatedText?: SortOrder
    touched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interviewId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EnumInterviewSourcePlatformsFilter = {
    equals?: InterviewSourcePlatforms
    in?: Enumerable<InterviewSourcePlatforms>
    notIn?: Enumerable<InterviewSourcePlatforms>
    not?: NestedEnumInterviewSourcePlatformsFilter | InterviewSourcePlatforms
  }

  export type InterviewSourceCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    platform?: SortOrder
    interviewId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterviewSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    platform?: SortOrder
    interviewId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSourceMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    platform?: SortOrder
    interviewId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumInterviewSourcePlatformsWithAggregatesFilter = {
    equals?: InterviewSourcePlatforms
    in?: Enumerable<InterviewSourcePlatforms>
    notIn?: Enumerable<InterviewSourcePlatforms>
    not?: NestedEnumInterviewSourcePlatformsWithAggregatesFilter | InterviewSourcePlatforms
    _count?: NestedIntFilter
    _min?: NestedEnumInterviewSourcePlatformsFilter
    _max?: NestedEnumInterviewSourcePlatformsFilter
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type TranscriptRelationFilter = {
    is?: TranscriptWhereInput | null
    isNot?: TranscriptWhereInput | null
  }

  export type HighlightListRelationFilter = {
    every?: HighlightWhereInput
    some?: HighlightWhereInput
    none?: HighlightWhereInput
  }

  export type WorkspaceRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type InterviewSourceRelationFilter = {
    is?: InterviewSourceWhereInput | null
    isNot?: InterviewSourceWhereInput | null
  }

  export type InterviewSummaryRelationFilter = {
    is?: InterviewSummaryWhereInput | null
    isNot?: InterviewSummaryWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SuggestedHighlightListRelationFilter = {
    every?: SuggestedHighlightWhereInput
    some?: SuggestedHighlightWhereInput
    none?: SuggestedHighlightWhereInput
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type HighlightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuggestedHighlightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    recordingId?: SortOrder
    workspaceId?: SortOrder
    creatorId?: SortOrder
    archived?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordingError?: SortOrder
    projectId?: SortOrder
  }

  export type InterviewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    recordingId?: SortOrder
    workspaceId?: SortOrder
    creatorId?: SortOrder
    archived?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordingError?: SortOrder
    projectId?: SortOrder
  }

  export type InterviewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    recordingId?: SortOrder
    workspaceId?: SortOrder
    creatorId?: SortOrder
    archived?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordingError?: SortOrder
    projectId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type HighlightRelationFilter = {
    is?: HighlightWhereInput | null
    isNot?: HighlightWhereInput | null
  }

  export type EditableAssetRelationFilter = {
    is?: EditableAssetWhereInput | null
    isNot?: EditableAssetWhereInput | null
  }

  export type PlayableAssetRelationFilter = {
    is?: PlayableAssetWhereInput | null
    isNot?: PlayableAssetWhereInput | null
  }

  export type RecorderRelationFilter = {
    is?: RecorderWhereInput | null
    isNot?: RecorderWhereInput | null
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    recorderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    recorderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    recorderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEditableAssetStatusFilter = {
    equals?: EditableAssetStatus
    in?: Enumerable<EditableAssetStatus>
    notIn?: Enumerable<EditableAssetStatus>
    not?: NestedEnumEditableAssetStatusFilter | EditableAssetStatus
  }

  export type EditableAssetCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    playbackId?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditableAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    playbackId?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditableAssetMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    playbackId?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEditableAssetStatusWithAggregatesFilter = {
    equals?: EditableAssetStatus
    in?: Enumerable<EditableAssetStatus>
    notIn?: Enumerable<EditableAssetStatus>
    not?: NestedEnumEditableAssetStatusWithAggregatesFilter | EditableAssetStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEditableAssetStatusFilter
    _max?: NestedEnumEditableAssetStatusFilter
  }

  export type EnumStoragePlatformsFilter = {
    equals?: StoragePlatforms
    in?: Enumerable<StoragePlatforms>
    notIn?: Enumerable<StoragePlatforms>
    not?: NestedEnumStoragePlatformsFilter | StoragePlatforms
  }

  export type PlayableAssetCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    platform?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayableAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    platform?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayableAssetMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    platform?: SortOrder
    isSigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoragePlatformsWithAggregatesFilter = {
    equals?: StoragePlatforms
    in?: Enumerable<StoragePlatforms>
    notIn?: Enumerable<StoragePlatforms>
    not?: NestedEnumStoragePlatformsWithAggregatesFilter | StoragePlatforms
    _count?: NestedIntFilter
    _min?: NestedEnumStoragePlatformsFilter
    _max?: NestedEnumStoragePlatformsFilter
  }

  export type SuggestedHighlightRelationFilter = {
    is?: SuggestedHighlightWhereInput | null
    isNot?: SuggestedHighlightWhereInput | null
  }

  export type TranscriptWordListRelationFilter = {
    every?: TranscriptWordWhereInput
    some?: TranscriptWordWhereInput
    none?: TranscriptWordWhereInput
  }

  export type TranscriptGroupListRelationFilter = {
    every?: TranscriptGroupWhereInput
    some?: TranscriptGroupWhereInput
    none?: TranscriptGroupWhereInput
  }

  export type TranscriptWordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    interviewId?: SortOrder
    isPending?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    interviewId?: SortOrder
    isPending?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    interviewId?: SortOrder
    isPending?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranscriptSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ParticipantRelationFilter = {
    is?: ParticipantWhereInput
    isNot?: ParticipantWhereInput
  }

  export type TranscriptGroupTranscriptIdGroupNumberCompoundUniqueInput = {
    transcriptId: string
    groupNumber: number
  }

  export type TranscriptGroupCountOrderByAggregateInput = {
    text?: SortOrder
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    speakerId?: SortOrder
  }

  export type TranscriptGroupAvgOrderByAggregateInput = {
    groupNumber?: SortOrder
  }

  export type TranscriptGroupMaxOrderByAggregateInput = {
    text?: SortOrder
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    speakerId?: SortOrder
  }

  export type TranscriptGroupMinOrderByAggregateInput = {
    text?: SortOrder
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    speakerId?: SortOrder
  }

  export type TranscriptGroupSumOrderByAggregateInput = {
    groupNumber?: SortOrder
  }

  export type TranscriptGroupRelationFilter = {
    is?: TranscriptGroupWhereInput
    isNot?: TranscriptGroupWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type WordRangeListRelationFilter = {
    every?: WordRangeWhereInput
    some?: WordRangeWhereInput
    none?: WordRangeWhereInput
  }

  export type WordRangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptWordTranscriptIdGroupNumberWordNumberCompoundUniqueInput = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
  }

  export type TranscriptWordCountOrderByAggregateInput = {
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
    text?: SortOrder
  }

  export type TranscriptWordAvgOrderByAggregateInput = {
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type TranscriptWordMaxOrderByAggregateInput = {
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
    text?: SortOrder
  }

  export type TranscriptWordMinOrderByAggregateInput = {
    transcriptId?: SortOrder
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
    text?: SortOrder
  }

  export type TranscriptWordSumOrderByAggregateInput = {
    groupNumber?: SortOrder
    wordNumber?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type TranscriptWordRelationFilter = {
    is?: TranscriptWordWhereInput
    isNot?: TranscriptWordWhereInput
  }

  export type WordRangeCountOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WordRangeAvgOrderByAggregateInput = {
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
  }

  export type WordRangeMaxOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WordRangeMinOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WordRangeSumOrderByAggregateInput = {
    startWordNumber?: SortOrder
    startGroupNumber?: SortOrder
    endWordNumber?: SortOrder
    endGroupNumber?: SortOrder
  }

  export type WordRangeRelationFilter = {
    is?: WordRangeWhereInput
    isNot?: WordRangeWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HighlightCountOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    timestamp?: SortOrder
    interviewId?: SortOrder
    videoId?: SortOrder
    transcriptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originSuggestionId?: SortOrder
  }

  export type HighlightMaxOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    timestamp?: SortOrder
    interviewId?: SortOrder
    videoId?: SortOrder
    transcriptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originSuggestionId?: SortOrder
  }

  export type HighlightMinOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    timestamp?: SortOrder
    interviewId?: SortOrder
    videoId?: SortOrder
    transcriptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originSuggestionId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    session?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    session?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    session?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewListRelationFilter = {
    every?: InterviewWhereInput
    some?: InterviewWhereInput
    none?: InterviewWhereInput
  }

  export type WorkspaceRoleListRelationFilter = {
    every?: WorkspaceRoleWhereInput
    some?: WorkspaceRoleWhereInput
    none?: WorkspaceRoleWhereInput
  }

  export type ExternalAuthListRelationFilter = {
    every?: ExternalAuthWhereInput
    some?: ExternalAuthWhereInput
    none?: ExternalAuthWhereInput
  }

  export type IdentityListRelationFilter = {
    every?: IdentityWhereInput
    some?: IdentityWhereInput
    none?: IdentityWhereInput
  }

  export type WorkspaceInviteListRelationFilter = {
    every?: WorkspaceInviteWhereInput
    some?: WorkspaceInviteWhereInput
    none?: WorkspaceInviteWhereInput
  }

  export type NotificationPreferencesRelationFilter = {
    is?: NotificationPreferencesWhereInput | null
    isNot?: NotificationPreferencesWhereInput | null
  }

  export type UserTagOrderListRelationFilter = {
    every?: UserTagOrderWhereInput
    some?: UserTagOrderWhereInput
    none?: UserTagOrderWhereInput
  }

  export type InterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdentityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailHash?: SortOrder
    fullName?: SortOrder
    confirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailHash?: SortOrder
    fullName?: SortOrder
    confirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailHash?: SortOrder
    fullName?: SortOrder
    confirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIdentityTypeFilter = {
    equals?: IdentityType
    in?: Enumerable<IdentityType>
    notIn?: Enumerable<IdentityType>
    not?: NestedEnumIdentityTypeFilter | IdentityType
  }

  export type IdentityTypeTokenCompoundUniqueInput = {
    type: IdentityType
    token: string
  }

  export type IdentityUserIdTypeCompoundUniqueInput = {
    userId: string
    type: IdentityType
  }

  export type IdentityCountOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentityMaxOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentityMinOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIdentityTypeWithAggregatesFilter = {
    equals?: IdentityType
    in?: Enumerable<IdentityType>
    notIn?: Enumerable<IdentityType>
    not?: NestedEnumIdentityTypeWithAggregatesFilter | IdentityType
    _count?: NestedIntFilter
    _min?: NestedEnumIdentityTypeFilter
    _max?: NestedEnumIdentityTypeFilter
  }

  export type EnumExternalAuthTypesFilter = {
    equals?: ExternalAuthTypes
    in?: Enumerable<ExternalAuthTypes>
    notIn?: Enumerable<ExternalAuthTypes>
    not?: NestedEnumExternalAuthTypesFilter | ExternalAuthTypes
  }

  export type ExternalAuthUserIdTypeCompoundUniqueInput = {
    userId: string
    type: ExternalAuthTypes
  }

  export type ExternalAuthCountOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuthMaxOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuthMinOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExternalAuthTypesWithAggregatesFilter = {
    equals?: ExternalAuthTypes
    in?: Enumerable<ExternalAuthTypes>
    notIn?: Enumerable<ExternalAuthTypes>
    not?: NestedEnumExternalAuthTypesWithAggregatesFilter | ExternalAuthTypes
    _count?: NestedIntFilter
    _min?: NestedEnumExternalAuthTypesFilter
    _max?: NestedEnumExternalAuthTypesFilter
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicInterviewLinks?: SortOrder
    ownedDomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicInterviewLinks?: SortOrder
    ownedDomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicInterviewLinks?: SortOrder
    ownedDomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceInviteCountOrderByAggregateInput = {
    token?: SortOrder
    workspaceId?: SortOrder
    inviterId?: SortOrder
    isExpired?: SortOrder
    inviteeEmail?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceInviteMaxOrderByAggregateInput = {
    token?: SortOrder
    workspaceId?: SortOrder
    inviterId?: SortOrder
    isExpired?: SortOrder
    inviteeEmail?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceInviteMinOrderByAggregateInput = {
    token?: SortOrder
    workspaceId?: SortOrder
    inviterId?: SortOrder
    isExpired?: SortOrder
    inviteeEmail?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleTypeFilter = {
    equals?: RoleType
    in?: Enumerable<RoleType>
    notIn?: Enumerable<RoleType>
    not?: NestedEnumRoleTypeFilter | RoleType
  }

  export type WorkspaceRoleUserIdWorkspaceIdCompoundUniqueInput = {
    userId: string
    workspaceId: string
  }

  export type WorkspaceRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleTypeWithAggregatesFilter = {
    equals?: RoleType
    in?: Enumerable<RoleType>
    notIn?: Enumerable<RoleType>
    not?: NestedEnumRoleTypeWithAggregatesFilter | RoleType
    _count?: NestedIntFilter
    _min?: NestedEnumRoleTypeFilter
    _max?: NestedEnumRoleTypeFilter
  }

  export type ParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumTagColorFilter = {
    equals?: TagColor
    in?: Enumerable<TagColor>
    notIn?: Enumerable<TagColor>
    not?: NestedEnumTagColorFilter | TagColor
  }

  export type ProjectTagsListRelationFilter = {
    every?: ProjectTagsWhereInput
    some?: ProjectTagsWhereInput
    none?: ProjectTagsWhereInput
  }

  export type ProjectTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    workspaceId?: SortOrder
    autoExtract?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emoji?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    workspaceId?: SortOrder
    autoExtract?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emoji?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    workspaceId?: SortOrder
    autoExtract?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emoji?: SortOrder
  }

  export type EnumTagColorWithAggregatesFilter = {
    equals?: TagColor
    in?: Enumerable<TagColor>
    notIn?: Enumerable<TagColor>
    not?: NestedEnumTagColorWithAggregatesFilter | TagColor
    _count?: NestedIntFilter
    _min?: NestedEnumTagColorFilter
    _max?: NestedEnumTagColorFilter
  }

  export type NotificationPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type UserTagOrderUserIdTagIdCompoundUniqueInput = {
    userId: string
    tagId: string
  }

  export type UserTagOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagOrderAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type UserTagOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagOrderSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumSuggestedHighlightStatusFilter = {
    equals?: SuggestedHighlightStatus
    in?: Enumerable<SuggestedHighlightStatus>
    notIn?: Enumerable<SuggestedHighlightStatus>
    not?: NestedEnumSuggestedHighlightStatusFilter | SuggestedHighlightStatus
  }

  export type SuggestedHighlightCountOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    interviewId?: SortOrder
    transcriptId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuggestedHighlightMaxOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    interviewId?: SortOrder
    transcriptId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuggestedHighlightMinOrderByAggregateInput = {
    id?: SortOrder
    highlightedRangeId?: SortOrder
    interviewId?: SortOrder
    transcriptId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSuggestedHighlightStatusWithAggregatesFilter = {
    equals?: SuggestedHighlightStatus
    in?: Enumerable<SuggestedHighlightStatus>
    notIn?: Enumerable<SuggestedHighlightStatus>
    not?: NestedEnumSuggestedHighlightStatusWithAggregatesFilter | SuggestedHighlightStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSuggestedHighlightStatusFilter
    _max?: NestedEnumSuggestedHighlightStatusFilter
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTagsProjectIdTagIdCompoundUniqueInput = {
    projectId: string
    tagId: string
  }

  export type ProjectTagsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTagsAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ProjectTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTagsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTagsSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumRecorderTypeFilter = {
    equals?: RecorderType
    in?: Enumerable<RecorderType>
    notIn?: Enumerable<RecorderType>
    not?: NestedEnumRecorderTypeFilter | RecorderType
  }

  export type RecordingTargetRelationFilter = {
    is?: RecordingTargetWhereInput
    isNot?: RecordingTargetWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type EnumRecorderStatusFilter = {
    equals?: RecorderStatus
    in?: Enumerable<RecorderStatus>
    notIn?: Enumerable<RecorderStatus>
    not?: NestedEnumRecorderStatusFilter | RecorderStatus
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecorderCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    error?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RecorderMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    error?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RecorderMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    error?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type EnumRecorderTypeWithAggregatesFilter = {
    equals?: RecorderType
    in?: Enumerable<RecorderType>
    notIn?: Enumerable<RecorderType>
    not?: NestedEnumRecorderTypeWithAggregatesFilter | RecorderType
    _count?: NestedIntFilter
    _min?: NestedEnumRecorderTypeFilter
    _max?: NestedEnumRecorderTypeFilter
  }

  export type EnumRecorderStatusWithAggregatesFilter = {
    equals?: RecorderStatus
    in?: Enumerable<RecorderStatus>
    notIn?: Enumerable<RecorderStatus>
    not?: NestedEnumRecorderStatusWithAggregatesFilter | RecorderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRecorderStatusFilter
    _max?: NestedEnumRecorderStatusFilter
  }

  export type EnumRecordingTargetTypeFilter = {
    equals?: RecordingTargetType
    in?: Enumerable<RecordingTargetType>
    notIn?: Enumerable<RecordingTargetType>
    not?: NestedEnumRecordingTargetTypeFilter | RecordingTargetType
  }

  export type RecordingTargetCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecordingTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecordingTargetMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRecordingTargetTypeWithAggregatesFilter = {
    equals?: RecordingTargetType
    in?: Enumerable<RecordingTargetType>
    notIn?: Enumerable<RecordingTargetType>
    not?: NestedEnumRecordingTargetTypeWithAggregatesFilter | RecordingTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumRecordingTargetTypeFilter
    _max?: NestedEnumRecordingTargetTypeFilter
  }

  export type InterviewCreateNestedOneWithoutSummaryInput = {
    create?: XOR<InterviewCreateWithoutSummaryInput, InterviewUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSummaryInput
    connect?: InterviewWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type InterviewUpdateOneRequiredWithoutSummaryNestedInput = {
    create?: XOR<InterviewCreateWithoutSummaryInput, InterviewUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSummaryInput
    upsert?: InterviewUpsertWithoutSummaryInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutSummaryInput, InterviewUncheckedUpdateWithoutSummaryInput>
  }

  export type InterviewCreateNestedOneWithoutSourceInput = {
    create?: XOR<InterviewCreateWithoutSourceInput, InterviewUncheckedCreateWithoutSourceInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSourceInput
    connect?: InterviewWhereUniqueInput
  }

  export type EnumInterviewSourcePlatformsFieldUpdateOperationsInput = {
    set?: InterviewSourcePlatforms
  }

  export type InterviewUpdateOneRequiredWithoutSourceNestedInput = {
    create?: XOR<InterviewCreateWithoutSourceInput, InterviewUncheckedCreateWithoutSourceInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSourceInput
    upsert?: InterviewUpsertWithoutSourceInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutSourceInput, InterviewUncheckedUpdateWithoutSourceInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VideoCreateNestedOneWithoutInterviewInput = {
    create?: XOR<VideoCreateWithoutInterviewInput, VideoUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: VideoCreateOrConnectWithoutInterviewInput
    connect?: VideoWhereUniqueInput
  }

  export type TranscriptCreateNestedOneWithoutInterviewInput = {
    create?: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutInterviewInput
    connect?: TranscriptWhereUniqueInput
  }

  export type HighlightCreateNestedManyWithoutInterviewInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutInterviewInput>, Enumerable<HighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutInterviewInput>
    createMany?: HighlightCreateManyInterviewInputEnvelope
    connect?: Enumerable<HighlightWhereUniqueInput>
  }

  export type WorkspaceCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<WorkspaceCreateWithoutInterviewsInput, WorkspaceUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInterviewsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type InterviewSourceCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSourceCreateOrConnectWithoutInterviewInput
    connect?: InterviewSourceWhereUniqueInput
  }

  export type InterviewSummaryCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSummaryCreateOrConnectWithoutInterviewInput
    connect?: InterviewSummaryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    connect?: UserWhereUniqueInput
  }

  export type SuggestedHighlightCreateNestedManyWithoutInterviewInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutInterviewInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutInterviewInput>
    createMany?: SuggestedHighlightCreateManyInterviewInputEnvelope
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
  }

  export type ProjectCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<ProjectCreateWithoutInterviewsInput, ProjectUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInterviewsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TranscriptUncheckedCreateNestedOneWithoutInterviewInput = {
    create?: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutInterviewInput
    connect?: TranscriptWhereUniqueInput
  }

  export type HighlightUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutInterviewInput>, Enumerable<HighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutInterviewInput>
    createMany?: HighlightCreateManyInterviewInputEnvelope
    connect?: Enumerable<HighlightWhereUniqueInput>
  }

  export type InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSourceCreateOrConnectWithoutInterviewInput
    connect?: InterviewSourceWhereUniqueInput
  }

  export type InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSummaryCreateOrConnectWithoutInterviewInput
    connect?: InterviewSummaryWhereUniqueInput
  }

  export type SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutInterviewInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutInterviewInput>
    createMany?: SuggestedHighlightCreateManyInterviewInputEnvelope
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
  }

  export type VideoUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<VideoCreateWithoutInterviewInput, VideoUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: VideoCreateOrConnectWithoutInterviewInput
    upsert?: VideoUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutInterviewInput, VideoUncheckedUpdateWithoutInterviewInput>
  }

  export type TranscriptUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutInterviewInput
    upsert?: TranscriptUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutInterviewInput, TranscriptUncheckedUpdateWithoutInterviewInput>
  }

  export type HighlightUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutInterviewInput>, Enumerable<HighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutInterviewInput>
    upsert?: Enumerable<HighlightUpsertWithWhereUniqueWithoutInterviewInput>
    createMany?: HighlightCreateManyInterviewInputEnvelope
    set?: Enumerable<HighlightWhereUniqueInput>
    disconnect?: Enumerable<HighlightWhereUniqueInput>
    delete?: Enumerable<HighlightWhereUniqueInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
    update?: Enumerable<HighlightUpdateWithWhereUniqueWithoutInterviewInput>
    updateMany?: Enumerable<HighlightUpdateManyWithWhereWithoutInterviewInput>
    deleteMany?: Enumerable<HighlightScalarWhereInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInterviewsInput, WorkspaceUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInterviewsInput
    upsert?: WorkspaceUpsertWithoutInterviewsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<WorkspaceUpdateWithoutInterviewsInput, WorkspaceUncheckedUpdateWithoutInterviewsInput>
  }

  export type InterviewSourceUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSourceCreateOrConnectWithoutInterviewInput
    upsert?: InterviewSourceUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewSourceWhereUniqueInput
    update?: XOR<InterviewSourceUpdateWithoutInterviewInput, InterviewSourceUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewSummaryUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSummaryCreateOrConnectWithoutInterviewInput
    upsert?: InterviewSummaryUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewSummaryWhereUniqueInput
    update?: XOR<InterviewSummaryUpdateWithoutInterviewInput, InterviewSummaryUncheckedUpdateWithoutInterviewInput>
  }

  export type UserUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    upsert?: UserUpsertWithoutInterviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SuggestedHighlightUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutInterviewInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutInterviewInput>
    upsert?: Enumerable<SuggestedHighlightUpsertWithWhereUniqueWithoutInterviewInput>
    createMany?: SuggestedHighlightCreateManyInterviewInputEnvelope
    set?: Enumerable<SuggestedHighlightWhereUniqueInput>
    disconnect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    delete?: Enumerable<SuggestedHighlightWhereUniqueInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    update?: Enumerable<SuggestedHighlightUpdateWithWhereUniqueWithoutInterviewInput>
    updateMany?: Enumerable<SuggestedHighlightUpdateManyWithWhereWithoutInterviewInput>
    deleteMany?: Enumerable<SuggestedHighlightScalarWhereInput>
  }

  export type ProjectUpdateOneWithoutInterviewsNestedInput = {
    create?: XOR<ProjectCreateWithoutInterviewsInput, ProjectUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInterviewsInput
    upsert?: ProjectUpsertWithoutInterviewsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutInterviewsInput, ProjectUncheckedUpdateWithoutInterviewsInput>
  }

  export type TranscriptUncheckedUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutInterviewInput
    upsert?: TranscriptUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutInterviewInput, TranscriptUncheckedUpdateWithoutInterviewInput>
  }

  export type HighlightUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutInterviewInput>, Enumerable<HighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutInterviewInput>
    upsert?: Enumerable<HighlightUpsertWithWhereUniqueWithoutInterviewInput>
    createMany?: HighlightCreateManyInterviewInputEnvelope
    set?: Enumerable<HighlightWhereUniqueInput>
    disconnect?: Enumerable<HighlightWhereUniqueInput>
    delete?: Enumerable<HighlightWhereUniqueInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
    update?: Enumerable<HighlightUpdateWithWhereUniqueWithoutInterviewInput>
    updateMany?: Enumerable<HighlightUpdateManyWithWhereWithoutInterviewInput>
    deleteMany?: Enumerable<HighlightScalarWhereInput>
  }

  export type InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSourceCreateOrConnectWithoutInterviewInput
    upsert?: InterviewSourceUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewSourceWhereUniqueInput
    update?: XOR<InterviewSourceUpdateWithoutInterviewInput, InterviewSourceUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewSummaryCreateOrConnectWithoutInterviewInput
    upsert?: InterviewSummaryUpsertWithoutInterviewInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewSummaryWhereUniqueInput
    update?: XOR<InterviewSummaryUpdateWithoutInterviewInput, InterviewSummaryUncheckedUpdateWithoutInterviewInput>
  }

  export type SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutInterviewInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutInterviewInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutInterviewInput>
    upsert?: Enumerable<SuggestedHighlightUpsertWithWhereUniqueWithoutInterviewInput>
    createMany?: SuggestedHighlightCreateManyInterviewInputEnvelope
    set?: Enumerable<SuggestedHighlightWhereUniqueInput>
    disconnect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    delete?: Enumerable<SuggestedHighlightWhereUniqueInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    update?: Enumerable<SuggestedHighlightUpdateWithWhereUniqueWithoutInterviewInput>
    updateMany?: Enumerable<SuggestedHighlightUpdateManyWithWhereWithoutInterviewInput>
    deleteMany?: Enumerable<SuggestedHighlightScalarWhereInput>
  }

  export type InterviewCreateNestedOneWithoutRecordingInput = {
    create?: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutRecordingInput
    connect?: InterviewWhereUniqueInput
  }

  export type HighlightCreateNestedOneWithoutVideoInput = {
    create?: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutVideoInput
    connect?: HighlightWhereUniqueInput
  }

  export type EditableAssetCreateNestedOneWithoutVideoInput = {
    create?: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: EditableAssetCreateOrConnectWithoutVideoInput
    connect?: EditableAssetWhereUniqueInput
  }

  export type PlayableAssetCreateNestedOneWithoutVideoInput = {
    create?: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: PlayableAssetCreateOrConnectWithoutVideoInput
    connect?: PlayableAssetWhereUniqueInput
  }

  export type RecorderCreateNestedOneWithoutVideoInput = {
    create?: XOR<RecorderCreateWithoutVideoInput, RecorderUncheckedCreateWithoutVideoInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutVideoInput
    connect?: RecorderWhereUniqueInput
  }

  export type InterviewUncheckedCreateNestedOneWithoutRecordingInput = {
    create?: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutRecordingInput
    connect?: InterviewWhereUniqueInput
  }

  export type HighlightUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutVideoInput
    connect?: HighlightWhereUniqueInput
  }

  export type EditableAssetUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: EditableAssetCreateOrConnectWithoutVideoInput
    connect?: EditableAssetWhereUniqueInput
  }

  export type PlayableAssetUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: PlayableAssetCreateOrConnectWithoutVideoInput
    connect?: PlayableAssetWhereUniqueInput
  }

  export type InterviewUpdateOneWithoutRecordingNestedInput = {
    create?: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutRecordingInput
    upsert?: InterviewUpsertWithoutRecordingInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutRecordingInput, InterviewUncheckedUpdateWithoutRecordingInput>
  }

  export type HighlightUpdateOneWithoutVideoNestedInput = {
    create?: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutVideoInput
    upsert?: HighlightUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutVideoInput, HighlightUncheckedUpdateWithoutVideoInput>
  }

  export type EditableAssetUpdateOneWithoutVideoNestedInput = {
    create?: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: EditableAssetCreateOrConnectWithoutVideoInput
    upsert?: EditableAssetUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: EditableAssetWhereUniqueInput
    update?: XOR<EditableAssetUpdateWithoutVideoInput, EditableAssetUncheckedUpdateWithoutVideoInput>
  }

  export type PlayableAssetUpdateOneWithoutVideoNestedInput = {
    create?: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: PlayableAssetCreateOrConnectWithoutVideoInput
    upsert?: PlayableAssetUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayableAssetWhereUniqueInput
    update?: XOR<PlayableAssetUpdateWithoutVideoInput, PlayableAssetUncheckedUpdateWithoutVideoInput>
  }

  export type RecorderUpdateOneWithoutVideoNestedInput = {
    create?: XOR<RecorderCreateWithoutVideoInput, RecorderUncheckedCreateWithoutVideoInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutVideoInput
    upsert?: RecorderUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecorderWhereUniqueInput
    update?: XOR<RecorderUpdateWithoutVideoInput, RecorderUncheckedUpdateWithoutVideoInput>
  }

  export type InterviewUncheckedUpdateOneWithoutRecordingNestedInput = {
    create?: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutRecordingInput
    upsert?: InterviewUpsertWithoutRecordingInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutRecordingInput, InterviewUncheckedUpdateWithoutRecordingInput>
  }

  export type HighlightUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutVideoInput
    upsert?: HighlightUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutVideoInput, HighlightUncheckedUpdateWithoutVideoInput>
  }

  export type EditableAssetUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: EditableAssetCreateOrConnectWithoutVideoInput
    upsert?: EditableAssetUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: EditableAssetWhereUniqueInput
    update?: XOR<EditableAssetUpdateWithoutVideoInput, EditableAssetUncheckedUpdateWithoutVideoInput>
  }

  export type PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
    connectOrCreate?: PlayableAssetCreateOrConnectWithoutVideoInput
    upsert?: PlayableAssetUpsertWithoutVideoInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayableAssetWhereUniqueInput
    update?: XOR<PlayableAssetUpdateWithoutVideoInput, PlayableAssetUncheckedUpdateWithoutVideoInput>
  }

  export type VideoCreateNestedOneWithoutEditableAssetInput = {
    create?: XOR<VideoCreateWithoutEditableAssetInput, VideoUncheckedCreateWithoutEditableAssetInput>
    connectOrCreate?: VideoCreateOrConnectWithoutEditableAssetInput
    connect?: VideoWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutEditableAssetNestedInput = {
    create?: XOR<VideoCreateWithoutEditableAssetInput, VideoUncheckedCreateWithoutEditableAssetInput>
    connectOrCreate?: VideoCreateOrConnectWithoutEditableAssetInput
    upsert?: VideoUpsertWithoutEditableAssetInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutEditableAssetInput, VideoUncheckedUpdateWithoutEditableAssetInput>
  }

  export type EnumEditableAssetStatusFieldUpdateOperationsInput = {
    set?: EditableAssetStatus
  }

  export type VideoCreateNestedOneWithoutPlayableAssetInput = {
    create?: XOR<VideoCreateWithoutPlayableAssetInput, VideoUncheckedCreateWithoutPlayableAssetInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPlayableAssetInput
    connect?: VideoWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutPlayableAssetNestedInput = {
    create?: XOR<VideoCreateWithoutPlayableAssetInput, VideoUncheckedCreateWithoutPlayableAssetInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPlayableAssetInput
    upsert?: VideoUpsertWithoutPlayableAssetInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutPlayableAssetInput, VideoUncheckedUpdateWithoutPlayableAssetInput>
  }

  export type EnumStoragePlatformsFieldUpdateOperationsInput = {
    set?: StoragePlatforms
  }

  export type InterviewCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<InterviewCreateWithoutTranscriptInput, InterviewUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutTranscriptInput
    connect?: InterviewWhereUniqueInput
  }

  export type HighlightCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutTranscriptInput
    connect?: HighlightWhereUniqueInput
  }

  export type SuggestedHighlightCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutTranscriptInput
    connect?: SuggestedHighlightWhereUniqueInput
  }

  export type TranscriptWordCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutTranscriptInput>, Enumerable<TranscriptWordUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutTranscriptInput>
    createMany?: TranscriptWordCreateManyTranscriptInputEnvelope
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
  }

  export type TranscriptGroupCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutTranscriptInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutTranscriptInput>
    createMany?: TranscriptGroupCreateManyTranscriptInputEnvelope
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
  }

  export type HighlightUncheckedCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutTranscriptInput
    connect?: HighlightWhereUniqueInput
  }

  export type SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutTranscriptInput
    connect?: SuggestedHighlightWhereUniqueInput
  }

  export type TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutTranscriptInput>, Enumerable<TranscriptWordUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutTranscriptInput>
    createMany?: TranscriptWordCreateManyTranscriptInputEnvelope
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
  }

  export type TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutTranscriptInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutTranscriptInput>
    createMany?: TranscriptGroupCreateManyTranscriptInputEnvelope
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
  }

  export type InterviewUpdateOneWithoutTranscriptNestedInput = {
    create?: XOR<InterviewCreateWithoutTranscriptInput, InterviewUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutTranscriptInput
    upsert?: InterviewUpsertWithoutTranscriptInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutTranscriptInput, InterviewUncheckedUpdateWithoutTranscriptInput>
  }

  export type HighlightUpdateOneWithoutTranscriptNestedInput = {
    create?: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutTranscriptInput
    upsert?: HighlightUpsertWithoutTranscriptInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutTranscriptInput, HighlightUncheckedUpdateWithoutTranscriptInput>
  }

  export type SuggestedHighlightUpdateOneWithoutTranscriptNestedInput = {
    create?: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutTranscriptInput
    upsert?: SuggestedHighlightUpsertWithoutTranscriptInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuggestedHighlightWhereUniqueInput
    update?: XOR<SuggestedHighlightUpdateWithoutTranscriptInput, SuggestedHighlightUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptWordUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutTranscriptInput>, Enumerable<TranscriptWordUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutTranscriptInput>
    upsert?: Enumerable<TranscriptWordUpsertWithWhereUniqueWithoutTranscriptInput>
    createMany?: TranscriptWordCreateManyTranscriptInputEnvelope
    set?: Enumerable<TranscriptWordWhereUniqueInput>
    disconnect?: Enumerable<TranscriptWordWhereUniqueInput>
    delete?: Enumerable<TranscriptWordWhereUniqueInput>
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
    update?: Enumerable<TranscriptWordUpdateWithWhereUniqueWithoutTranscriptInput>
    updateMany?: Enumerable<TranscriptWordUpdateManyWithWhereWithoutTranscriptInput>
    deleteMany?: Enumerable<TranscriptWordScalarWhereInput>
  }

  export type TranscriptGroupUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutTranscriptInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutTranscriptInput>
    upsert?: Enumerable<TranscriptGroupUpsertWithWhereUniqueWithoutTranscriptInput>
    createMany?: TranscriptGroupCreateManyTranscriptInputEnvelope
    set?: Enumerable<TranscriptGroupWhereUniqueInput>
    disconnect?: Enumerable<TranscriptGroupWhereUniqueInput>
    delete?: Enumerable<TranscriptGroupWhereUniqueInput>
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
    update?: Enumerable<TranscriptGroupUpdateWithWhereUniqueWithoutTranscriptInput>
    updateMany?: Enumerable<TranscriptGroupUpdateManyWithWhereWithoutTranscriptInput>
    deleteMany?: Enumerable<TranscriptGroupScalarWhereInput>
  }

  export type HighlightUncheckedUpdateOneWithoutTranscriptNestedInput = {
    create?: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutTranscriptInput
    upsert?: HighlightUpsertWithoutTranscriptInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutTranscriptInput, HighlightUncheckedUpdateWithoutTranscriptInput>
  }

  export type SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput = {
    create?: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutTranscriptInput
    upsert?: SuggestedHighlightUpsertWithoutTranscriptInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuggestedHighlightWhereUniqueInput
    update?: XOR<SuggestedHighlightUpdateWithoutTranscriptInput, SuggestedHighlightUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutTranscriptInput>, Enumerable<TranscriptWordUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutTranscriptInput>
    upsert?: Enumerable<TranscriptWordUpsertWithWhereUniqueWithoutTranscriptInput>
    createMany?: TranscriptWordCreateManyTranscriptInputEnvelope
    set?: Enumerable<TranscriptWordWhereUniqueInput>
    disconnect?: Enumerable<TranscriptWordWhereUniqueInput>
    delete?: Enumerable<TranscriptWordWhereUniqueInput>
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
    update?: Enumerable<TranscriptWordUpdateWithWhereUniqueWithoutTranscriptInput>
    updateMany?: Enumerable<TranscriptWordUpdateManyWithWhereWithoutTranscriptInput>
    deleteMany?: Enumerable<TranscriptWordScalarWhereInput>
  }

  export type TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutTranscriptInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutTranscriptInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutTranscriptInput>
    upsert?: Enumerable<TranscriptGroupUpsertWithWhereUniqueWithoutTranscriptInput>
    createMany?: TranscriptGroupCreateManyTranscriptInputEnvelope
    set?: Enumerable<TranscriptGroupWhereUniqueInput>
    disconnect?: Enumerable<TranscriptGroupWhereUniqueInput>
    delete?: Enumerable<TranscriptGroupWhereUniqueInput>
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
    update?: Enumerable<TranscriptGroupUpdateWithWhereUniqueWithoutTranscriptInput>
    updateMany?: Enumerable<TranscriptGroupUpdateManyWithWhereWithoutTranscriptInput>
    deleteMany?: Enumerable<TranscriptGroupScalarWhereInput>
  }

  export type TranscriptCreateNestedOneWithoutGroupsInput = {
    create?: XOR<TranscriptCreateWithoutGroupsInput, TranscriptUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutGroupsInput
    connect?: TranscriptWhereUniqueInput
  }

  export type TranscriptWordCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutGroupInput>, Enumerable<TranscriptWordUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutGroupInput>
    createMany?: TranscriptWordCreateManyGroupInputEnvelope
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
  }

  export type ParticipantCreateNestedOneWithoutGroupsInput = {
    create?: XOR<ParticipantCreateWithoutGroupsInput, ParticipantUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutGroupsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type TranscriptWordUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutGroupInput>, Enumerable<TranscriptWordUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutGroupInput>
    createMany?: TranscriptWordCreateManyGroupInputEnvelope
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
  }

  export type TranscriptUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<TranscriptCreateWithoutGroupsInput, TranscriptUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutGroupsInput
    upsert?: TranscriptUpsertWithoutGroupsInput
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutGroupsInput, TranscriptUncheckedUpdateWithoutGroupsInput>
  }

  export type TranscriptWordUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutGroupInput>, Enumerable<TranscriptWordUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<TranscriptWordUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: TranscriptWordCreateManyGroupInputEnvelope
    set?: Enumerable<TranscriptWordWhereUniqueInput>
    disconnect?: Enumerable<TranscriptWordWhereUniqueInput>
    delete?: Enumerable<TranscriptWordWhereUniqueInput>
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
    update?: Enumerable<TranscriptWordUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<TranscriptWordUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<TranscriptWordScalarWhereInput>
  }

  export type ParticipantUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<ParticipantCreateWithoutGroupsInput, ParticipantUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutGroupsInput
    upsert?: ParticipantUpsertWithoutGroupsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<ParticipantUpdateWithoutGroupsInput, ParticipantUncheckedUpdateWithoutGroupsInput>
  }

  export type TranscriptWordUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<TranscriptWordCreateWithoutGroupInput>, Enumerable<TranscriptWordUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<TranscriptWordCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<TranscriptWordUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: TranscriptWordCreateManyGroupInputEnvelope
    set?: Enumerable<TranscriptWordWhereUniqueInput>
    disconnect?: Enumerable<TranscriptWordWhereUniqueInput>
    delete?: Enumerable<TranscriptWordWhereUniqueInput>
    connect?: Enumerable<TranscriptWordWhereUniqueInput>
    update?: Enumerable<TranscriptWordUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<TranscriptWordUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<TranscriptWordScalarWhereInput>
  }

  export type TranscriptCreateNestedOneWithoutWordsInput = {
    create?: XOR<TranscriptCreateWithoutWordsInput, TranscriptUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutWordsInput
    connect?: TranscriptWhereUniqueInput
  }

  export type TranscriptGroupCreateNestedOneWithoutWordsInput = {
    create?: XOR<TranscriptGroupCreateWithoutWordsInput, TranscriptGroupUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptGroupCreateOrConnectWithoutWordsInput
    connect?: TranscriptGroupWhereUniqueInput
  }

  export type WordRangeCreateNestedManyWithoutStartWordInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutStartWordInput>, Enumerable<WordRangeUncheckedCreateWithoutStartWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutStartWordInput>
    createMany?: WordRangeCreateManyStartWordInputEnvelope
    connect?: Enumerable<WordRangeWhereUniqueInput>
  }

  export type WordRangeCreateNestedManyWithoutEndWordInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutEndWordInput>, Enumerable<WordRangeUncheckedCreateWithoutEndWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutEndWordInput>
    createMany?: WordRangeCreateManyEndWordInputEnvelope
    connect?: Enumerable<WordRangeWhereUniqueInput>
  }

  export type WordRangeUncheckedCreateNestedManyWithoutStartWordInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutStartWordInput>, Enumerable<WordRangeUncheckedCreateWithoutStartWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutStartWordInput>
    createMany?: WordRangeCreateManyStartWordInputEnvelope
    connect?: Enumerable<WordRangeWhereUniqueInput>
  }

  export type WordRangeUncheckedCreateNestedManyWithoutEndWordInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutEndWordInput>, Enumerable<WordRangeUncheckedCreateWithoutEndWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutEndWordInput>
    createMany?: WordRangeCreateManyEndWordInputEnvelope
    connect?: Enumerable<WordRangeWhereUniqueInput>
  }

  export type TranscriptUpdateOneRequiredWithoutWordsNestedInput = {
    create?: XOR<TranscriptCreateWithoutWordsInput, TranscriptUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutWordsInput
    upsert?: TranscriptUpsertWithoutWordsInput
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutWordsInput, TranscriptUncheckedUpdateWithoutWordsInput>
  }

  export type TranscriptGroupUpdateOneRequiredWithoutWordsNestedInput = {
    create?: XOR<TranscriptGroupCreateWithoutWordsInput, TranscriptGroupUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptGroupCreateOrConnectWithoutWordsInput
    upsert?: TranscriptGroupUpsertWithoutWordsInput
    connect?: TranscriptGroupWhereUniqueInput
    update?: XOR<TranscriptGroupUpdateWithoutWordsInput, TranscriptGroupUncheckedUpdateWithoutWordsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WordRangeUpdateManyWithoutStartWordNestedInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutStartWordInput>, Enumerable<WordRangeUncheckedCreateWithoutStartWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutStartWordInput>
    upsert?: Enumerable<WordRangeUpsertWithWhereUniqueWithoutStartWordInput>
    createMany?: WordRangeCreateManyStartWordInputEnvelope
    set?: Enumerable<WordRangeWhereUniqueInput>
    disconnect?: Enumerable<WordRangeWhereUniqueInput>
    delete?: Enumerable<WordRangeWhereUniqueInput>
    connect?: Enumerable<WordRangeWhereUniqueInput>
    update?: Enumerable<WordRangeUpdateWithWhereUniqueWithoutStartWordInput>
    updateMany?: Enumerable<WordRangeUpdateManyWithWhereWithoutStartWordInput>
    deleteMany?: Enumerable<WordRangeScalarWhereInput>
  }

  export type WordRangeUpdateManyWithoutEndWordNestedInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutEndWordInput>, Enumerable<WordRangeUncheckedCreateWithoutEndWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutEndWordInput>
    upsert?: Enumerable<WordRangeUpsertWithWhereUniqueWithoutEndWordInput>
    createMany?: WordRangeCreateManyEndWordInputEnvelope
    set?: Enumerable<WordRangeWhereUniqueInput>
    disconnect?: Enumerable<WordRangeWhereUniqueInput>
    delete?: Enumerable<WordRangeWhereUniqueInput>
    connect?: Enumerable<WordRangeWhereUniqueInput>
    update?: Enumerable<WordRangeUpdateWithWhereUniqueWithoutEndWordInput>
    updateMany?: Enumerable<WordRangeUpdateManyWithWhereWithoutEndWordInput>
    deleteMany?: Enumerable<WordRangeScalarWhereInput>
  }

  export type WordRangeUncheckedUpdateManyWithoutStartWordNestedInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutStartWordInput>, Enumerable<WordRangeUncheckedCreateWithoutStartWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutStartWordInput>
    upsert?: Enumerable<WordRangeUpsertWithWhereUniqueWithoutStartWordInput>
    createMany?: WordRangeCreateManyStartWordInputEnvelope
    set?: Enumerable<WordRangeWhereUniqueInput>
    disconnect?: Enumerable<WordRangeWhereUniqueInput>
    delete?: Enumerable<WordRangeWhereUniqueInput>
    connect?: Enumerable<WordRangeWhereUniqueInput>
    update?: Enumerable<WordRangeUpdateWithWhereUniqueWithoutStartWordInput>
    updateMany?: Enumerable<WordRangeUpdateManyWithWhereWithoutStartWordInput>
    deleteMany?: Enumerable<WordRangeScalarWhereInput>
  }

  export type WordRangeUncheckedUpdateManyWithoutEndWordNestedInput = {
    create?: XOR<Enumerable<WordRangeCreateWithoutEndWordInput>, Enumerable<WordRangeUncheckedCreateWithoutEndWordInput>>
    connectOrCreate?: Enumerable<WordRangeCreateOrConnectWithoutEndWordInput>
    upsert?: Enumerable<WordRangeUpsertWithWhereUniqueWithoutEndWordInput>
    createMany?: WordRangeCreateManyEndWordInputEnvelope
    set?: Enumerable<WordRangeWhereUniqueInput>
    disconnect?: Enumerable<WordRangeWhereUniqueInput>
    delete?: Enumerable<WordRangeWhereUniqueInput>
    connect?: Enumerable<WordRangeWhereUniqueInput>
    update?: Enumerable<WordRangeUpdateWithWhereUniqueWithoutEndWordInput>
    updateMany?: Enumerable<WordRangeUpdateManyWithWhereWithoutEndWordInput>
    deleteMany?: Enumerable<WordRangeScalarWhereInput>
  }

  export type TranscriptWordCreateNestedOneWithoutStartWordRangesInput = {
    create?: XOR<TranscriptWordCreateWithoutStartWordRangesInput, TranscriptWordUncheckedCreateWithoutStartWordRangesInput>
    connectOrCreate?: TranscriptWordCreateOrConnectWithoutStartWordRangesInput
    connect?: TranscriptWordWhereUniqueInput
  }

  export type TranscriptWordCreateNestedOneWithoutEndWordRangesInput = {
    create?: XOR<TranscriptWordCreateWithoutEndWordRangesInput, TranscriptWordUncheckedCreateWithoutEndWordRangesInput>
    connectOrCreate?: TranscriptWordCreateOrConnectWithoutEndWordRangesInput
    connect?: TranscriptWordWhereUniqueInput
  }

  export type HighlightCreateNestedOneWithoutHighlightedRangeInput = {
    create?: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutHighlightedRangeInput
    connect?: HighlightWhereUniqueInput
  }

  export type SuggestedHighlightCreateNestedOneWithoutHighlightedRangeInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightedRangeInput
    connect?: SuggestedHighlightWhereUniqueInput
  }

  export type HighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput = {
    create?: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutHighlightedRangeInput
    connect?: HighlightWhereUniqueInput
  }

  export type SuggestedHighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightedRangeInput
    connect?: SuggestedHighlightWhereUniqueInput
  }

  export type TranscriptWordUpdateOneRequiredWithoutStartWordRangesNestedInput = {
    create?: XOR<TranscriptWordCreateWithoutStartWordRangesInput, TranscriptWordUncheckedCreateWithoutStartWordRangesInput>
    connectOrCreate?: TranscriptWordCreateOrConnectWithoutStartWordRangesInput
    upsert?: TranscriptWordUpsertWithoutStartWordRangesInput
    connect?: TranscriptWordWhereUniqueInput
    update?: XOR<TranscriptWordUpdateWithoutStartWordRangesInput, TranscriptWordUncheckedUpdateWithoutStartWordRangesInput>
  }

  export type TranscriptWordUpdateOneRequiredWithoutEndWordRangesNestedInput = {
    create?: XOR<TranscriptWordCreateWithoutEndWordRangesInput, TranscriptWordUncheckedCreateWithoutEndWordRangesInput>
    connectOrCreate?: TranscriptWordCreateOrConnectWithoutEndWordRangesInput
    upsert?: TranscriptWordUpsertWithoutEndWordRangesInput
    connect?: TranscriptWordWhereUniqueInput
    update?: XOR<TranscriptWordUpdateWithoutEndWordRangesInput, TranscriptWordUncheckedUpdateWithoutEndWordRangesInput>
  }

  export type HighlightUpdateOneWithoutHighlightedRangeNestedInput = {
    create?: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutHighlightedRangeInput
    upsert?: HighlightUpsertWithoutHighlightedRangeInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutHighlightedRangeInput, HighlightUncheckedUpdateWithoutHighlightedRangeInput>
  }

  export type SuggestedHighlightUpdateOneWithoutHighlightedRangeNestedInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightedRangeInput
    upsert?: SuggestedHighlightUpsertWithoutHighlightedRangeInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuggestedHighlightWhereUniqueInput
    update?: XOR<SuggestedHighlightUpdateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedUpdateWithoutHighlightedRangeInput>
  }

  export type HighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput = {
    create?: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutHighlightedRangeInput
    upsert?: HighlightUpsertWithoutHighlightedRangeInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutHighlightedRangeInput, HighlightUncheckedUpdateWithoutHighlightedRangeInput>
  }

  export type SuggestedHighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightedRangeInput
    upsert?: SuggestedHighlightUpsertWithoutHighlightedRangeInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuggestedHighlightWhereUniqueInput
    update?: XOR<SuggestedHighlightUpdateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedUpdateWithoutHighlightedRangeInput>
  }

  export type WordRangeCreateNestedOneWithoutHighlightInput = {
    create?: XOR<WordRangeCreateWithoutHighlightInput, WordRangeUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: WordRangeCreateOrConnectWithoutHighlightInput
    connect?: WordRangeWhereUniqueInput
  }

  export type InterviewCreateNestedOneWithoutHighlightsInput = {
    create?: XOR<InterviewCreateWithoutHighlightsInput, InterviewUncheckedCreateWithoutHighlightsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutHighlightsInput
    connect?: InterviewWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutHighlightInput = {
    create?: XOR<VideoCreateWithoutHighlightInput, VideoUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: VideoCreateOrConnectWithoutHighlightInput
    connect?: VideoWhereUniqueInput
  }

  export type TranscriptCreateNestedOneWithoutHighlightInput = {
    create?: XOR<TranscriptCreateWithoutHighlightInput, TranscriptUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutHighlightInput
    connect?: TranscriptWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutHighlightsInput = {
    create?: XOR<Enumerable<TagCreateWithoutHighlightsInput>, Enumerable<TagUncheckedCreateWithoutHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutHighlightsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type SuggestedHighlightCreateNestedOneWithoutHighlightInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightInput, SuggestedHighlightUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightInput
    connect?: SuggestedHighlightWhereUniqueInput
  }

  export type TagUncheckedCreateNestedManyWithoutHighlightsInput = {
    create?: XOR<Enumerable<TagCreateWithoutHighlightsInput>, Enumerable<TagUncheckedCreateWithoutHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutHighlightsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type WordRangeUpdateOneWithoutHighlightNestedInput = {
    create?: XOR<WordRangeCreateWithoutHighlightInput, WordRangeUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: WordRangeCreateOrConnectWithoutHighlightInput
    upsert?: WordRangeUpsertWithoutHighlightInput
    disconnect?: boolean
    delete?: boolean
    connect?: WordRangeWhereUniqueInput
    update?: XOR<WordRangeUpdateWithoutHighlightInput, WordRangeUncheckedUpdateWithoutHighlightInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InterviewUpdateOneRequiredWithoutHighlightsNestedInput = {
    create?: XOR<InterviewCreateWithoutHighlightsInput, InterviewUncheckedCreateWithoutHighlightsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutHighlightsInput
    upsert?: InterviewUpsertWithoutHighlightsInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutHighlightsInput, InterviewUncheckedUpdateWithoutHighlightsInput>
  }

  export type VideoUpdateOneWithoutHighlightNestedInput = {
    create?: XOR<VideoCreateWithoutHighlightInput, VideoUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: VideoCreateOrConnectWithoutHighlightInput
    upsert?: VideoUpsertWithoutHighlightInput
    disconnect?: boolean
    delete?: boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutHighlightInput, VideoUncheckedUpdateWithoutHighlightInput>
  }

  export type TranscriptUpdateOneWithoutHighlightNestedInput = {
    create?: XOR<TranscriptCreateWithoutHighlightInput, TranscriptUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutHighlightInput
    upsert?: TranscriptUpsertWithoutHighlightInput
    disconnect?: boolean
    delete?: boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutHighlightInput, TranscriptUncheckedUpdateWithoutHighlightInput>
  }

  export type TagUpdateManyWithoutHighlightsNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutHighlightsInput>, Enumerable<TagUncheckedCreateWithoutHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutHighlightsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutHighlightsInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutHighlightsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutHighlightsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type SuggestedHighlightUpdateOneWithoutHighlightNestedInput = {
    create?: XOR<SuggestedHighlightCreateWithoutHighlightInput, SuggestedHighlightUncheckedCreateWithoutHighlightInput>
    connectOrCreate?: SuggestedHighlightCreateOrConnectWithoutHighlightInput
    upsert?: SuggestedHighlightUpsertWithoutHighlightInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuggestedHighlightWhereUniqueInput
    update?: XOR<SuggestedHighlightUpdateWithoutHighlightInput, SuggestedHighlightUncheckedUpdateWithoutHighlightInput>
  }

  export type TagUncheckedUpdateManyWithoutHighlightsNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutHighlightsInput>, Enumerable<TagUncheckedCreateWithoutHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutHighlightsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutHighlightsInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutHighlightsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutHighlightsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type InterviewCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutCreatorInput>, Enumerable<InterviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutCreatorInput>
    createMany?: InterviewCreateManyCreatorInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type WorkspaceRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutUserInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutUserInput>
    createMany?: WorkspaceRoleCreateManyUserInputEnvelope
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
  }

  export type ExternalAuthCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExternalAuthCreateWithoutUserInput>, Enumerable<ExternalAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExternalAuthCreateOrConnectWithoutUserInput>
    createMany?: ExternalAuthCreateManyUserInputEnvelope
    connect?: Enumerable<ExternalAuthWhereUniqueInput>
  }

  export type IdentityCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IdentityCreateWithoutUserInput>, Enumerable<IdentityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IdentityCreateOrConnectWithoutUserInput>
    createMany?: IdentityCreateManyUserInputEnvelope
    connect?: Enumerable<IdentityWhereUniqueInput>
  }

  export type WorkspaceInviteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutUserInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutUserInput>
    createMany?: WorkspaceInviteCreateManyUserInputEnvelope
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
  }

  export type NotificationPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferencesCreateOrConnectWithoutUserInput
    connect?: NotificationPreferencesWhereUniqueInput
  }

  export type UserTagOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutUserInput>, Enumerable<UserTagOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutUserInput>
    createMany?: UserTagOrderCreateManyUserInputEnvelope
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
  }

  export type InterviewUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutCreatorInput>, Enumerable<InterviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutCreatorInput>
    createMany?: InterviewCreateManyCreatorInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutUserInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutUserInput>
    createMany?: WorkspaceRoleCreateManyUserInputEnvelope
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
  }

  export type ExternalAuthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExternalAuthCreateWithoutUserInput>, Enumerable<ExternalAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExternalAuthCreateOrConnectWithoutUserInput>
    createMany?: ExternalAuthCreateManyUserInputEnvelope
    connect?: Enumerable<ExternalAuthWhereUniqueInput>
  }

  export type IdentityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IdentityCreateWithoutUserInput>, Enumerable<IdentityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IdentityCreateOrConnectWithoutUserInput>
    createMany?: IdentityCreateManyUserInputEnvelope
    connect?: Enumerable<IdentityWhereUniqueInput>
  }

  export type WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutUserInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutUserInput>
    createMany?: WorkspaceInviteCreateManyUserInputEnvelope
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
  }

  export type NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferencesCreateOrConnectWithoutUserInput
    connect?: NotificationPreferencesWhereUniqueInput
  }

  export type UserTagOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutUserInput>, Enumerable<UserTagOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutUserInput>
    createMany?: UserTagOrderCreateManyUserInputEnvelope
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
  }

  export type InterviewUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutCreatorInput>, Enumerable<InterviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: InterviewCreateManyCreatorInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type WorkspaceRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutUserInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkspaceRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkspaceRoleCreateManyUserInputEnvelope
    set?: Enumerable<WorkspaceRoleWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    delete?: Enumerable<WorkspaceRoleWhereUniqueInput>
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    update?: Enumerable<WorkspaceRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkspaceRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkspaceRoleScalarWhereInput>
  }

  export type ExternalAuthUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ExternalAuthCreateWithoutUserInput>, Enumerable<ExternalAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExternalAuthCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExternalAuthUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExternalAuthCreateManyUserInputEnvelope
    set?: Enumerable<ExternalAuthWhereUniqueInput>
    disconnect?: Enumerable<ExternalAuthWhereUniqueInput>
    delete?: Enumerable<ExternalAuthWhereUniqueInput>
    connect?: Enumerable<ExternalAuthWhereUniqueInput>
    update?: Enumerable<ExternalAuthUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExternalAuthUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExternalAuthScalarWhereInput>
  }

  export type IdentityUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IdentityCreateWithoutUserInput>, Enumerable<IdentityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IdentityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IdentityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IdentityCreateManyUserInputEnvelope
    set?: Enumerable<IdentityWhereUniqueInput>
    disconnect?: Enumerable<IdentityWhereUniqueInput>
    delete?: Enumerable<IdentityWhereUniqueInput>
    connect?: Enumerable<IdentityWhereUniqueInput>
    update?: Enumerable<IdentityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IdentityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IdentityScalarWhereInput>
  }

  export type WorkspaceInviteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutUserInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkspaceInviteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkspaceInviteCreateManyUserInputEnvelope
    set?: Enumerable<WorkspaceInviteWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    delete?: Enumerable<WorkspaceInviteWhereUniqueInput>
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    update?: Enumerable<WorkspaceInviteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkspaceInviteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkspaceInviteScalarWhereInput>
  }

  export type NotificationPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferencesCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferencesUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationPreferencesWhereUniqueInput
    update?: XOR<NotificationPreferencesUpdateWithoutUserInput, NotificationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserTagOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutUserInput>, Enumerable<UserTagOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTagOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTagOrderCreateManyUserInputEnvelope
    set?: Enumerable<UserTagOrderWhereUniqueInput>
    disconnect?: Enumerable<UserTagOrderWhereUniqueInput>
    delete?: Enumerable<UserTagOrderWhereUniqueInput>
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
    update?: Enumerable<UserTagOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTagOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTagOrderScalarWhereInput>
  }

  export type InterviewUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutCreatorInput>, Enumerable<InterviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: InterviewCreateManyCreatorInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutUserInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkspaceRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkspaceRoleCreateManyUserInputEnvelope
    set?: Enumerable<WorkspaceRoleWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    delete?: Enumerable<WorkspaceRoleWhereUniqueInput>
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    update?: Enumerable<WorkspaceRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkspaceRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkspaceRoleScalarWhereInput>
  }

  export type ExternalAuthUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ExternalAuthCreateWithoutUserInput>, Enumerable<ExternalAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExternalAuthCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExternalAuthUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExternalAuthCreateManyUserInputEnvelope
    set?: Enumerable<ExternalAuthWhereUniqueInput>
    disconnect?: Enumerable<ExternalAuthWhereUniqueInput>
    delete?: Enumerable<ExternalAuthWhereUniqueInput>
    connect?: Enumerable<ExternalAuthWhereUniqueInput>
    update?: Enumerable<ExternalAuthUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExternalAuthUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExternalAuthScalarWhereInput>
  }

  export type IdentityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IdentityCreateWithoutUserInput>, Enumerable<IdentityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IdentityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IdentityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IdentityCreateManyUserInputEnvelope
    set?: Enumerable<IdentityWhereUniqueInput>
    disconnect?: Enumerable<IdentityWhereUniqueInput>
    delete?: Enumerable<IdentityWhereUniqueInput>
    connect?: Enumerable<IdentityWhereUniqueInput>
    update?: Enumerable<IdentityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IdentityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IdentityScalarWhereInput>
  }

  export type WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutUserInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkspaceInviteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkspaceInviteCreateManyUserInputEnvelope
    set?: Enumerable<WorkspaceInviteWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    delete?: Enumerable<WorkspaceInviteWhereUniqueInput>
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    update?: Enumerable<WorkspaceInviteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkspaceInviteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkspaceInviteScalarWhereInput>
  }

  export type NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferencesCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferencesUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationPreferencesWhereUniqueInput
    update?: XOR<NotificationPreferencesUpdateWithoutUserInput, NotificationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserTagOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutUserInput>, Enumerable<UserTagOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTagOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTagOrderCreateManyUserInputEnvelope
    set?: Enumerable<UserTagOrderWhereUniqueInput>
    disconnect?: Enumerable<UserTagOrderWhereUniqueInput>
    delete?: Enumerable<UserTagOrderWhereUniqueInput>
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
    update?: Enumerable<UserTagOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTagOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTagOrderScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutIdentitiesInput = {
    create?: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIdentitiesNestedInput = {
    create?: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentitiesInput
    upsert?: UserUpsertWithoutIdentitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIdentitiesInput, UserUncheckedUpdateWithoutIdentitiesInput>
  }

  export type EnumIdentityTypeFieldUpdateOperationsInput = {
    set?: IdentityType
  }

  export type UserCreateNestedOneWithoutSourceAuthsInput = {
    create?: XOR<UserCreateWithoutSourceAuthsInput, UserUncheckedCreateWithoutSourceAuthsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSourceAuthsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumExternalAuthTypesFieldUpdateOperationsInput = {
    set?: ExternalAuthTypes
  }

  export type UserUpdateOneRequiredWithoutSourceAuthsNestedInput = {
    create?: XOR<UserCreateWithoutSourceAuthsInput, UserUncheckedCreateWithoutSourceAuthsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSourceAuthsInput
    upsert?: UserUpsertWithoutSourceAuthsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSourceAuthsInput, UserUncheckedUpdateWithoutSourceAuthsInput>
  }

  export type WorkspaceRoleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutWorkspaceInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutWorkspaceInput>
    createMany?: WorkspaceRoleCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
  }

  export type InterviewCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutWorkspaceInput>, Enumerable<InterviewUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutWorkspaceInput>
    createMany?: InterviewCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type WorkspaceInviteCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutWorkspaceInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutWorkspaceInput>
    createMany?: WorkspaceInviteCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
  }

  export type TagCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<TagCreateWithoutWorkspaceInput>, Enumerable<TagUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
    createMany?: TagCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type ProjectCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutWorkspaceInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutWorkspaceInput>
    createMany?: WorkspaceRoleCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
  }

  export type InterviewUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutWorkspaceInput>, Enumerable<InterviewUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutWorkspaceInput>
    createMany?: InterviewCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutWorkspaceInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutWorkspaceInput>
    createMany?: WorkspaceInviteCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
  }

  export type TagUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<TagCreateWithoutWorkspaceInput>, Enumerable<TagUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
    createMany?: TagCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutWorkspaceInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<WorkspaceRoleUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: WorkspaceRoleCreateManyWorkspaceInputEnvelope
    set?: Enumerable<WorkspaceRoleWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    delete?: Enumerable<WorkspaceRoleWhereUniqueInput>
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    update?: Enumerable<WorkspaceRoleUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<WorkspaceRoleUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<WorkspaceRoleScalarWhereInput>
  }

  export type InterviewUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutWorkspaceInput>, Enumerable<InterviewUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: InterviewCreateManyWorkspaceInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutWorkspaceInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<WorkspaceInviteUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: WorkspaceInviteCreateManyWorkspaceInputEnvelope
    set?: Enumerable<WorkspaceInviteWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    delete?: Enumerable<WorkspaceInviteWhereUniqueInput>
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    update?: Enumerable<WorkspaceInviteUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<WorkspaceInviteUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<WorkspaceInviteScalarWhereInput>
  }

  export type TagUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutWorkspaceInput>, Enumerable<TagUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: TagCreateManyWorkspaceInputEnvelope
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type ProjectUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<WorkspaceRoleCreateWithoutWorkspaceInput>, Enumerable<WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceRoleCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<WorkspaceRoleUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: WorkspaceRoleCreateManyWorkspaceInputEnvelope
    set?: Enumerable<WorkspaceRoleWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    delete?: Enumerable<WorkspaceRoleWhereUniqueInput>
    connect?: Enumerable<WorkspaceRoleWhereUniqueInput>
    update?: Enumerable<WorkspaceRoleUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<WorkspaceRoleUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<WorkspaceRoleScalarWhereInput>
  }

  export type InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutWorkspaceInput>, Enumerable<InterviewUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: InterviewCreateManyWorkspaceInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<WorkspaceInviteCreateWithoutWorkspaceInput>, Enumerable<WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<WorkspaceInviteCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<WorkspaceInviteUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: WorkspaceInviteCreateManyWorkspaceInputEnvelope
    set?: Enumerable<WorkspaceInviteWhereUniqueInput>
    disconnect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    delete?: Enumerable<WorkspaceInviteWhereUniqueInput>
    connect?: Enumerable<WorkspaceInviteWhereUniqueInput>
    update?: Enumerable<WorkspaceInviteUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<WorkspaceInviteUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<WorkspaceInviteScalarWhereInput>
  }

  export type TagUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutWorkspaceInput>, Enumerable<TagUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: TagCreateManyWorkspaceInputEnvelope
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutWorkspaceInput>
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutWorkspaceInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutWorkspaceInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type WorkspaceCreateNestedOneWithoutInviteTokensInput = {
    create?: XOR<WorkspaceCreateWithoutInviteTokensInput, WorkspaceUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInviteTokensInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInviteTokensInput = {
    create?: XOR<UserCreateWithoutInviteTokensInput, UserUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteTokensInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInviteTokensNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInviteTokensInput, WorkspaceUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInviteTokensInput
    upsert?: WorkspaceUpsertWithoutInviteTokensInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<WorkspaceUpdateWithoutInviteTokensInput, WorkspaceUncheckedUpdateWithoutInviteTokensInput>
  }

  export type UserUpdateOneRequiredWithoutInviteTokensNestedInput = {
    create?: XOR<UserCreateWithoutInviteTokensInput, UserUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteTokensInput
    upsert?: UserUpsertWithoutInviteTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInviteTokensInput, UserUncheckedUpdateWithoutInviteTokensInput>
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutRolesInput = {
    create?: XOR<WorkspaceCreateWithoutRolesInput, WorkspaceUncheckedCreateWithoutRolesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutRolesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutRolesInput, WorkspaceUncheckedCreateWithoutRolesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutRolesInput
    upsert?: WorkspaceUpsertWithoutRolesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<WorkspaceUpdateWithoutRolesInput, WorkspaceUncheckedUpdateWithoutRolesInput>
  }

  export type EnumRoleTypeFieldUpdateOperationsInput = {
    set?: RoleType
  }

  export type TranscriptGroupCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutSpeakerInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutSpeakerInput>
    createMany?: TranscriptGroupCreateManySpeakerInputEnvelope
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
  }

  export type TranscriptGroupUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutSpeakerInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutSpeakerInput>
    createMany?: TranscriptGroupCreateManySpeakerInputEnvelope
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
  }

  export type TranscriptGroupUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutSpeakerInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutSpeakerInput>
    upsert?: Enumerable<TranscriptGroupUpsertWithWhereUniqueWithoutSpeakerInput>
    createMany?: TranscriptGroupCreateManySpeakerInputEnvelope
    set?: Enumerable<TranscriptGroupWhereUniqueInput>
    disconnect?: Enumerable<TranscriptGroupWhereUniqueInput>
    delete?: Enumerable<TranscriptGroupWhereUniqueInput>
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
    update?: Enumerable<TranscriptGroupUpdateWithWhereUniqueWithoutSpeakerInput>
    updateMany?: Enumerable<TranscriptGroupUpdateManyWithWhereWithoutSpeakerInput>
    deleteMany?: Enumerable<TranscriptGroupScalarWhereInput>
  }

  export type TranscriptGroupUncheckedUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<Enumerable<TranscriptGroupCreateWithoutSpeakerInput>, Enumerable<TranscriptGroupUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<TranscriptGroupCreateOrConnectWithoutSpeakerInput>
    upsert?: Enumerable<TranscriptGroupUpsertWithWhereUniqueWithoutSpeakerInput>
    createMany?: TranscriptGroupCreateManySpeakerInputEnvelope
    set?: Enumerable<TranscriptGroupWhereUniqueInput>
    disconnect?: Enumerable<TranscriptGroupWhereUniqueInput>
    delete?: Enumerable<TranscriptGroupWhereUniqueInput>
    connect?: Enumerable<TranscriptGroupWhereUniqueInput>
    update?: Enumerable<TranscriptGroupUpdateWithWhereUniqueWithoutSpeakerInput>
    updateMany?: Enumerable<TranscriptGroupUpdateManyWithWhereWithoutSpeakerInput>
    deleteMany?: Enumerable<TranscriptGroupScalarWhereInput>
  }

  export type WorkspaceCreateNestedOneWithoutTagsInput = {
    create?: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTagsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type HighlightCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutTagsInput>, Enumerable<HighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
  }

  export type SuggestedHighlightCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutTagsInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
  }

  export type UserTagOrderCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutTagInput>, Enumerable<UserTagOrderUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutTagInput>
    createMany?: UserTagOrderCreateManyTagInputEnvelope
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
  }

  export type ProjectTagsCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutTagInput>, Enumerable<ProjectTagsUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutTagInput>
    createMany?: ProjectTagsCreateManyTagInputEnvelope
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
  }

  export type HighlightUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutTagsInput>, Enumerable<HighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
  }

  export type SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutTagsInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
  }

  export type UserTagOrderUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutTagInput>, Enumerable<UserTagOrderUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutTagInput>
    createMany?: UserTagOrderCreateManyTagInputEnvelope
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
  }

  export type ProjectTagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutTagInput>, Enumerable<ProjectTagsUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutTagInput>
    createMany?: ProjectTagsCreateManyTagInputEnvelope
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
  }

  export type EnumTagColorFieldUpdateOperationsInput = {
    set?: TagColor
  }

  export type WorkspaceUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTagsInput
    upsert?: WorkspaceUpsertWithoutTagsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<WorkspaceUpdateWithoutTagsInput, WorkspaceUncheckedUpdateWithoutTagsInput>
  }

  export type HighlightUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutTagsInput>, Enumerable<HighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<HighlightUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<HighlightWhereUniqueInput>
    disconnect?: Enumerable<HighlightWhereUniqueInput>
    delete?: Enumerable<HighlightWhereUniqueInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
    update?: Enumerable<HighlightUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<HighlightUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<HighlightScalarWhereInput>
  }

  export type SuggestedHighlightUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutTagsInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<SuggestedHighlightUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<SuggestedHighlightWhereUniqueInput>
    disconnect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    delete?: Enumerable<SuggestedHighlightWhereUniqueInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    update?: Enumerable<SuggestedHighlightUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<SuggestedHighlightUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<SuggestedHighlightScalarWhereInput>
  }

  export type UserTagOrderUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutTagInput>, Enumerable<UserTagOrderUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<UserTagOrderUpsertWithWhereUniqueWithoutTagInput>
    createMany?: UserTagOrderCreateManyTagInputEnvelope
    set?: Enumerable<UserTagOrderWhereUniqueInput>
    disconnect?: Enumerable<UserTagOrderWhereUniqueInput>
    delete?: Enumerable<UserTagOrderWhereUniqueInput>
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
    update?: Enumerable<UserTagOrderUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<UserTagOrderUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<UserTagOrderScalarWhereInput>
  }

  export type ProjectTagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutTagInput>, Enumerable<ProjectTagsUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ProjectTagsUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ProjectTagsCreateManyTagInputEnvelope
    set?: Enumerable<ProjectTagsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTagsWhereUniqueInput>
    delete?: Enumerable<ProjectTagsWhereUniqueInput>
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
    update?: Enumerable<ProjectTagsUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ProjectTagsUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ProjectTagsScalarWhereInput>
  }

  export type HighlightUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<HighlightCreateWithoutTagsInput>, Enumerable<HighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<HighlightCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<HighlightUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<HighlightWhereUniqueInput>
    disconnect?: Enumerable<HighlightWhereUniqueInput>
    delete?: Enumerable<HighlightWhereUniqueInput>
    connect?: Enumerable<HighlightWhereUniqueInput>
    update?: Enumerable<HighlightUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<HighlightUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<HighlightScalarWhereInput>
  }

  export type SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<SuggestedHighlightCreateWithoutTagsInput>, Enumerable<SuggestedHighlightUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<SuggestedHighlightCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<SuggestedHighlightUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<SuggestedHighlightWhereUniqueInput>
    disconnect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    delete?: Enumerable<SuggestedHighlightWhereUniqueInput>
    connect?: Enumerable<SuggestedHighlightWhereUniqueInput>
    update?: Enumerable<SuggestedHighlightUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<SuggestedHighlightUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<SuggestedHighlightScalarWhereInput>
  }

  export type UserTagOrderUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<UserTagOrderCreateWithoutTagInput>, Enumerable<UserTagOrderUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<UserTagOrderCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<UserTagOrderUpsertWithWhereUniqueWithoutTagInput>
    createMany?: UserTagOrderCreateManyTagInputEnvelope
    set?: Enumerable<UserTagOrderWhereUniqueInput>
    disconnect?: Enumerable<UserTagOrderWhereUniqueInput>
    delete?: Enumerable<UserTagOrderWhereUniqueInput>
    connect?: Enumerable<UserTagOrderWhereUniqueInput>
    update?: Enumerable<UserTagOrderUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<UserTagOrderUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<UserTagOrderScalarWhereInput>
  }

  export type ProjectTagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutTagInput>, Enumerable<ProjectTagsUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ProjectTagsUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ProjectTagsCreateManyTagInputEnvelope
    set?: Enumerable<ProjectTagsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTagsWhereUniqueInput>
    delete?: Enumerable<ProjectTagsWhereUniqueInput>
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
    update?: Enumerable<ProjectTagsUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ProjectTagsUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ProjectTagsScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserCreateNestedOneWithoutTagOrderInput = {
    create?: XOR<UserCreateWithoutTagOrderInput, UserUncheckedCreateWithoutTagOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagOrderInput
    connect?: UserWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutUserOrdersInput = {
    create?: XOR<TagCreateWithoutUserOrdersInput, TagUncheckedCreateWithoutUserOrdersInput>
    connectOrCreate?: TagCreateOrConnectWithoutUserOrdersInput
    connect?: TagWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTagOrderNestedInput = {
    create?: XOR<UserCreateWithoutTagOrderInput, UserUncheckedCreateWithoutTagOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagOrderInput
    upsert?: UserUpsertWithoutTagOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTagOrderInput, UserUncheckedUpdateWithoutTagOrderInput>
  }

  export type TagUpdateOneRequiredWithoutUserOrdersNestedInput = {
    create?: XOR<TagCreateWithoutUserOrdersInput, TagUncheckedCreateWithoutUserOrdersInput>
    connectOrCreate?: TagCreateOrConnectWithoutUserOrdersInput
    upsert?: TagUpsertWithoutUserOrdersInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutUserOrdersInput, TagUncheckedUpdateWithoutUserOrdersInput>
  }

  export type WordRangeCreateNestedOneWithoutSuggestedHighlightInput = {
    create?: XOR<WordRangeCreateWithoutSuggestedHighlightInput, WordRangeUncheckedCreateWithoutSuggestedHighlightInput>
    connectOrCreate?: WordRangeCreateOrConnectWithoutSuggestedHighlightInput
    connect?: WordRangeWhereUniqueInput
  }

  export type InterviewCreateNestedOneWithoutSuggestedHighlightsInput = {
    create?: XOR<InterviewCreateWithoutSuggestedHighlightsInput, InterviewUncheckedCreateWithoutSuggestedHighlightsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSuggestedHighlightsInput
    connect?: InterviewWhereUniqueInput
  }

  export type TranscriptCreateNestedOneWithoutSuggestedHighlightInput = {
    create?: XOR<TranscriptCreateWithoutSuggestedHighlightInput, TranscriptUncheckedCreateWithoutSuggestedHighlightInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutSuggestedHighlightInput
    connect?: TranscriptWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutSuggestedHighlightsInput = {
    create?: XOR<Enumerable<TagCreateWithoutSuggestedHighlightsInput>, Enumerable<TagUncheckedCreateWithoutSuggestedHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutSuggestedHighlightsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type HighlightCreateNestedOneWithoutOriginSuggestionInput = {
    create?: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutOriginSuggestionInput
    connect?: HighlightWhereUniqueInput
  }

  export type TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput = {
    create?: XOR<Enumerable<TagCreateWithoutSuggestedHighlightsInput>, Enumerable<TagUncheckedCreateWithoutSuggestedHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutSuggestedHighlightsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput = {
    create?: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutOriginSuggestionInput
    connect?: HighlightWhereUniqueInput
  }

  export type WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput = {
    create?: XOR<WordRangeCreateWithoutSuggestedHighlightInput, WordRangeUncheckedCreateWithoutSuggestedHighlightInput>
    connectOrCreate?: WordRangeCreateOrConnectWithoutSuggestedHighlightInput
    upsert?: WordRangeUpsertWithoutSuggestedHighlightInput
    connect?: WordRangeWhereUniqueInput
    update?: XOR<WordRangeUpdateWithoutSuggestedHighlightInput, WordRangeUncheckedUpdateWithoutSuggestedHighlightInput>
  }

  export type InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput = {
    create?: XOR<InterviewCreateWithoutSuggestedHighlightsInput, InterviewUncheckedCreateWithoutSuggestedHighlightsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutSuggestedHighlightsInput
    upsert?: InterviewUpsertWithoutSuggestedHighlightsInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<InterviewUpdateWithoutSuggestedHighlightsInput, InterviewUncheckedUpdateWithoutSuggestedHighlightsInput>
  }

  export type TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput = {
    create?: XOR<TranscriptCreateWithoutSuggestedHighlightInput, TranscriptUncheckedCreateWithoutSuggestedHighlightInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutSuggestedHighlightInput
    upsert?: TranscriptUpsertWithoutSuggestedHighlightInput
    connect?: TranscriptWhereUniqueInput
    update?: XOR<TranscriptUpdateWithoutSuggestedHighlightInput, TranscriptUncheckedUpdateWithoutSuggestedHighlightInput>
  }

  export type TagUpdateManyWithoutSuggestedHighlightsNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutSuggestedHighlightsInput>, Enumerable<TagUncheckedCreateWithoutSuggestedHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutSuggestedHighlightsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutSuggestedHighlightsInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutSuggestedHighlightsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutSuggestedHighlightsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type EnumSuggestedHighlightStatusFieldUpdateOperationsInput = {
    set?: SuggestedHighlightStatus
  }

  export type HighlightUpdateOneWithoutOriginSuggestionNestedInput = {
    create?: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutOriginSuggestionInput
    upsert?: HighlightUpsertWithoutOriginSuggestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutOriginSuggestionInput, HighlightUncheckedUpdateWithoutOriginSuggestionInput>
  }

  export type TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutSuggestedHighlightsInput>, Enumerable<TagUncheckedCreateWithoutSuggestedHighlightsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutSuggestedHighlightsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutSuggestedHighlightsInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutSuggestedHighlightsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutSuggestedHighlightsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput = {
    create?: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
    connectOrCreate?: HighlightCreateOrConnectWithoutOriginSuggestionInput
    upsert?: HighlightUpsertWithoutOriginSuggestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: HighlightWhereUniqueInput
    update?: XOR<HighlightUpdateWithoutOriginSuggestionInput, HighlightUncheckedUpdateWithoutOriginSuggestionInput>
  }

  export type InterviewCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutProjectInput>, Enumerable<InterviewUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutProjectInput>
    createMany?: InterviewCreateManyProjectInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type WorkspaceCreateNestedOneWithoutProjectsInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectTagsCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutProjectInput>, Enumerable<ProjectTagsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutProjectInput>
    createMany?: ProjectTagsCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
  }

  export type InterviewUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutProjectInput>, Enumerable<InterviewUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutProjectInput>
    createMany?: InterviewCreateManyProjectInputEnvelope
    connect?: Enumerable<InterviewWhereUniqueInput>
  }

  export type ProjectTagsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutProjectInput>, Enumerable<ProjectTagsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutProjectInput>
    createMany?: ProjectTagsCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
  }

  export type InterviewUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutProjectInput>, Enumerable<InterviewUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: InterviewCreateManyProjectInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    upsert?: WorkspaceUpsertWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTagsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutProjectInput>, Enumerable<ProjectTagsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectTagsUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectTagsCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectTagsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTagsWhereUniqueInput>
    delete?: Enumerable<ProjectTagsWhereUniqueInput>
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
    update?: Enumerable<ProjectTagsUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectTagsUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectTagsScalarWhereInput>
  }

  export type InterviewUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<InterviewCreateWithoutProjectInput>, Enumerable<InterviewUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InterviewCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<InterviewUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: InterviewCreateManyProjectInputEnvelope
    set?: Enumerable<InterviewWhereUniqueInput>
    disconnect?: Enumerable<InterviewWhereUniqueInput>
    delete?: Enumerable<InterviewWhereUniqueInput>
    connect?: Enumerable<InterviewWhereUniqueInput>
    update?: Enumerable<InterviewUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<InterviewUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<InterviewScalarWhereInput>
  }

  export type ProjectTagsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectTagsCreateWithoutProjectInput>, Enumerable<ProjectTagsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectTagsCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectTagsUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectTagsCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectTagsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTagsWhereUniqueInput>
    delete?: Enumerable<ProjectTagsWhereUniqueInput>
    connect?: Enumerable<ProjectTagsWhereUniqueInput>
    update?: Enumerable<ProjectTagsUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectTagsUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectTagsScalarWhereInput>
  }

  export type ProjectCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProjectTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTagsInput
    upsert?: ProjectUpsertWithoutProjectTagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutProjectTagsInput, ProjectUncheckedUpdateWithoutProjectTagsInput>
  }

  export type TagUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProjectTagsInput
    upsert?: TagUpsertWithoutProjectTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutProjectTagsInput, TagUncheckedUpdateWithoutProjectTagsInput>
  }

  export type RecordingTargetCreateNestedOneWithoutRecorderInput = {
    create?: XOR<RecordingTargetCreateWithoutRecorderInput, RecordingTargetUncheckedCreateWithoutRecorderInput>
    connectOrCreate?: RecordingTargetCreateOrConnectWithoutRecorderInput
    connect?: RecordingTargetWhereUniqueInput
  }

  export type VideoCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<VideoCreateWithoutRecorderInput>, Enumerable<VideoUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutRecorderInput>
    createMany?: VideoCreateManyRecorderInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<VideoCreateWithoutRecorderInput>, Enumerable<VideoUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutRecorderInput>
    createMany?: VideoCreateManyRecorderInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type EnumRecorderTypeFieldUpdateOperationsInput = {
    set?: RecorderType
  }

  export type RecordingTargetUpdateOneRequiredWithoutRecorderNestedInput = {
    create?: XOR<RecordingTargetCreateWithoutRecorderInput, RecordingTargetUncheckedCreateWithoutRecorderInput>
    connectOrCreate?: RecordingTargetCreateOrConnectWithoutRecorderInput
    upsert?: RecordingTargetUpsertWithoutRecorderInput
    connect?: RecordingTargetWhereUniqueInput
    update?: XOR<RecordingTargetUpdateWithoutRecorderInput, RecordingTargetUncheckedUpdateWithoutRecorderInput>
  }

  export type VideoUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutRecorderInput>, Enumerable<VideoUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: VideoCreateManyRecorderInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type EnumRecorderStatusFieldUpdateOperationsInput = {
    set?: RecorderStatus
  }

  export type VideoUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutRecorderInput>, Enumerable<VideoUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: VideoCreateManyRecorderInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type RecorderCreateNestedOneWithoutTargetInput = {
    create?: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutTargetInput
    connect?: RecorderWhereUniqueInput
  }

  export type RecorderUncheckedCreateNestedOneWithoutTargetInput = {
    create?: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutTargetInput
    connect?: RecorderWhereUniqueInput
  }

  export type EnumRecordingTargetTypeFieldUpdateOperationsInput = {
    set?: RecordingTargetType
  }

  export type RecorderUpdateOneWithoutTargetNestedInput = {
    create?: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutTargetInput
    upsert?: RecorderUpsertWithoutTargetInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecorderWhereUniqueInput
    update?: XOR<RecorderUpdateWithoutTargetInput, RecorderUncheckedUpdateWithoutTargetInput>
  }

  export type RecorderUncheckedUpdateOneWithoutTargetNestedInput = {
    create?: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
    connectOrCreate?: RecorderCreateOrConnectWithoutTargetInput
    upsert?: RecorderUpsertWithoutTargetInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecorderWhereUniqueInput
    update?: XOR<RecorderUpdateWithoutTargetInput, RecorderUncheckedUpdateWithoutTargetInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumInterviewSourcePlatformsFilter = {
    equals?: InterviewSourcePlatforms
    in?: Enumerable<InterviewSourcePlatforms>
    notIn?: Enumerable<InterviewSourcePlatforms>
    not?: NestedEnumInterviewSourcePlatformsFilter | InterviewSourcePlatforms
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumInterviewSourcePlatformsWithAggregatesFilter = {
    equals?: InterviewSourcePlatforms
    in?: Enumerable<InterviewSourcePlatforms>
    notIn?: Enumerable<InterviewSourcePlatforms>
    not?: NestedEnumInterviewSourcePlatformsWithAggregatesFilter | InterviewSourcePlatforms
    _count?: NestedIntFilter
    _min?: NestedEnumInterviewSourcePlatformsFilter
    _max?: NestedEnumInterviewSourcePlatformsFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumEditableAssetStatusFilter = {
    equals?: EditableAssetStatus
    in?: Enumerable<EditableAssetStatus>
    notIn?: Enumerable<EditableAssetStatus>
    not?: NestedEnumEditableAssetStatusFilter | EditableAssetStatus
  }

  export type NestedEnumEditableAssetStatusWithAggregatesFilter = {
    equals?: EditableAssetStatus
    in?: Enumerable<EditableAssetStatus>
    notIn?: Enumerable<EditableAssetStatus>
    not?: NestedEnumEditableAssetStatusWithAggregatesFilter | EditableAssetStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEditableAssetStatusFilter
    _max?: NestedEnumEditableAssetStatusFilter
  }

  export type NestedEnumStoragePlatformsFilter = {
    equals?: StoragePlatforms
    in?: Enumerable<StoragePlatforms>
    notIn?: Enumerable<StoragePlatforms>
    not?: NestedEnumStoragePlatformsFilter | StoragePlatforms
  }

  export type NestedEnumStoragePlatformsWithAggregatesFilter = {
    equals?: StoragePlatforms
    in?: Enumerable<StoragePlatforms>
    notIn?: Enumerable<StoragePlatforms>
    not?: NestedEnumStoragePlatformsWithAggregatesFilter | StoragePlatforms
    _count?: NestedIntFilter
    _min?: NestedEnumStoragePlatformsFilter
    _max?: NestedEnumStoragePlatformsFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumIdentityTypeFilter = {
    equals?: IdentityType
    in?: Enumerable<IdentityType>
    notIn?: Enumerable<IdentityType>
    not?: NestedEnumIdentityTypeFilter | IdentityType
  }

  export type NestedEnumIdentityTypeWithAggregatesFilter = {
    equals?: IdentityType
    in?: Enumerable<IdentityType>
    notIn?: Enumerable<IdentityType>
    not?: NestedEnumIdentityTypeWithAggregatesFilter | IdentityType
    _count?: NestedIntFilter
    _min?: NestedEnumIdentityTypeFilter
    _max?: NestedEnumIdentityTypeFilter
  }

  export type NestedEnumExternalAuthTypesFilter = {
    equals?: ExternalAuthTypes
    in?: Enumerable<ExternalAuthTypes>
    notIn?: Enumerable<ExternalAuthTypes>
    not?: NestedEnumExternalAuthTypesFilter | ExternalAuthTypes
  }

  export type NestedEnumExternalAuthTypesWithAggregatesFilter = {
    equals?: ExternalAuthTypes
    in?: Enumerable<ExternalAuthTypes>
    notIn?: Enumerable<ExternalAuthTypes>
    not?: NestedEnumExternalAuthTypesWithAggregatesFilter | ExternalAuthTypes
    _count?: NestedIntFilter
    _min?: NestedEnumExternalAuthTypesFilter
    _max?: NestedEnumExternalAuthTypesFilter
  }

  export type NestedEnumRoleTypeFilter = {
    equals?: RoleType
    in?: Enumerable<RoleType>
    notIn?: Enumerable<RoleType>
    not?: NestedEnumRoleTypeFilter | RoleType
  }

  export type NestedEnumRoleTypeWithAggregatesFilter = {
    equals?: RoleType
    in?: Enumerable<RoleType>
    notIn?: Enumerable<RoleType>
    not?: NestedEnumRoleTypeWithAggregatesFilter | RoleType
    _count?: NestedIntFilter
    _min?: NestedEnumRoleTypeFilter
    _max?: NestedEnumRoleTypeFilter
  }

  export type NestedEnumTagColorFilter = {
    equals?: TagColor
    in?: Enumerable<TagColor>
    notIn?: Enumerable<TagColor>
    not?: NestedEnumTagColorFilter | TagColor
  }

  export type NestedEnumTagColorWithAggregatesFilter = {
    equals?: TagColor
    in?: Enumerable<TagColor>
    notIn?: Enumerable<TagColor>
    not?: NestedEnumTagColorWithAggregatesFilter | TagColor
    _count?: NestedIntFilter
    _min?: NestedEnumTagColorFilter
    _max?: NestedEnumTagColorFilter
  }

  export type NestedEnumSuggestedHighlightStatusFilter = {
    equals?: SuggestedHighlightStatus
    in?: Enumerable<SuggestedHighlightStatus>
    notIn?: Enumerable<SuggestedHighlightStatus>
    not?: NestedEnumSuggestedHighlightStatusFilter | SuggestedHighlightStatus
  }

  export type NestedEnumSuggestedHighlightStatusWithAggregatesFilter = {
    equals?: SuggestedHighlightStatus
    in?: Enumerable<SuggestedHighlightStatus>
    notIn?: Enumerable<SuggestedHighlightStatus>
    not?: NestedEnumSuggestedHighlightStatusWithAggregatesFilter | SuggestedHighlightStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSuggestedHighlightStatusFilter
    _max?: NestedEnumSuggestedHighlightStatusFilter
  }

  export type NestedEnumRecorderTypeFilter = {
    equals?: RecorderType
    in?: Enumerable<RecorderType>
    notIn?: Enumerable<RecorderType>
    not?: NestedEnumRecorderTypeFilter | RecorderType
  }

  export type NestedEnumRecorderStatusFilter = {
    equals?: RecorderStatus
    in?: Enumerable<RecorderStatus>
    notIn?: Enumerable<RecorderStatus>
    not?: NestedEnumRecorderStatusFilter | RecorderStatus
  }

  export type NestedEnumRecorderTypeWithAggregatesFilter = {
    equals?: RecorderType
    in?: Enumerable<RecorderType>
    notIn?: Enumerable<RecorderType>
    not?: NestedEnumRecorderTypeWithAggregatesFilter | RecorderType
    _count?: NestedIntFilter
    _min?: NestedEnumRecorderTypeFilter
    _max?: NestedEnumRecorderTypeFilter
  }

  export type NestedEnumRecorderStatusWithAggregatesFilter = {
    equals?: RecorderStatus
    in?: Enumerable<RecorderStatus>
    notIn?: Enumerable<RecorderStatus>
    not?: NestedEnumRecorderStatusWithAggregatesFilter | RecorderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRecorderStatusFilter
    _max?: NestedEnumRecorderStatusFilter
  }

  export type NestedEnumRecordingTargetTypeFilter = {
    equals?: RecordingTargetType
    in?: Enumerable<RecordingTargetType>
    notIn?: Enumerable<RecordingTargetType>
    not?: NestedEnumRecordingTargetTypeFilter | RecordingTargetType
  }

  export type NestedEnumRecordingTargetTypeWithAggregatesFilter = {
    equals?: RecordingTargetType
    in?: Enumerable<RecordingTargetType>
    notIn?: Enumerable<RecordingTargetType>
    not?: NestedEnumRecordingTargetTypeWithAggregatesFilter | RecordingTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumRecordingTargetTypeFilter
    _max?: NestedEnumRecordingTargetTypeFilter
  }

  export type InterviewCreateWithoutSummaryInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutSummaryInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutSummaryInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutSummaryInput, InterviewUncheckedCreateWithoutSummaryInput>
  }

  export type InterviewUpsertWithoutSummaryInput = {
    update: XOR<InterviewUpdateWithoutSummaryInput, InterviewUncheckedUpdateWithoutSummaryInput>
    create: XOR<InterviewCreateWithoutSummaryInput, InterviewUncheckedCreateWithoutSummaryInput>
  }

  export type InterviewUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewCreateWithoutSourceInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutSourceInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutSourceInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutSourceInput, InterviewUncheckedCreateWithoutSourceInput>
  }

  export type InterviewUpsertWithoutSourceInput = {
    update: XOR<InterviewUpdateWithoutSourceInput, InterviewUncheckedUpdateWithoutSourceInput>
    create: XOR<InterviewCreateWithoutSourceInput, InterviewUncheckedCreateWithoutSourceInput>
  }

  export type InterviewUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCreateWithoutInterviewInput = {
    id?: string
    highlight?: HighlightCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetCreateNestedOneWithoutVideoInput
    recorder?: RecorderCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutInterviewInput = {
    id?: string
    highlight?: HighlightUncheckedCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetUncheckedCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetUncheckedCreateNestedOneWithoutVideoInput
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutInterviewInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutInterviewInput, VideoUncheckedCreateWithoutInterviewInput>
  }

  export type TranscriptCreateWithoutInterviewInput = {
    id?: string
    version?: number
    highlight?: HighlightCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutInterviewInput = {
    id?: string
    version?: number
    highlight?: HighlightUncheckedCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutInterviewInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
  }

  export type HighlightCreateWithoutInterviewInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    video?: VideoCreateNestedOneWithoutHighlightInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateWithoutInterviewInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    videoId?: string | null
    transcriptId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightCreateOrConnectWithoutInterviewInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutInterviewInput, HighlightUncheckedCreateWithoutInterviewInput>
  }

  export type HighlightCreateManyInterviewInputEnvelope = {
    data: Enumerable<HighlightCreateManyInterviewInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutInterviewsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateWithoutInterviewsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceCreateOrConnectWithoutInterviewsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInterviewsInput, WorkspaceUncheckedCreateWithoutInterviewsInput>
  }

  export type InterviewSourceCreateWithoutInterviewInput = {
    sourceId: string
    platform: InterviewSourcePlatforms
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSourceUncheckedCreateWithoutInterviewInput = {
    id?: number
    sourceId: string
    platform: InterviewSourcePlatforms
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSourceCreateOrConnectWithoutInterviewInput = {
    where: InterviewSourceWhereUniqueInput
    create: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewSummaryCreateWithoutInterviewInput = {
    id?: string
    text: string
    generatedText?: string
    touched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSummaryUncheckedCreateWithoutInterviewInput = {
    id?: string
    text: string
    generatedText?: string
    touched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSummaryCreateOrConnectWithoutInterviewInput = {
    where: InterviewSummaryWhereUniqueInput
    create: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
  }

  export type UserCreateWithoutInterviewsInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewsInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
  }

  export type SuggestedHighlightCreateWithoutInterviewInput = {
    id?: string
    highlightedRange: WordRangeCreateNestedOneWithoutSuggestedHighlightInput
    transcript: TranscriptCreateNestedOneWithoutSuggestedHighlightInput
    tags?: TagCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUncheckedCreateWithoutInterviewInput = {
    id?: string
    highlightedRangeId: string
    transcriptId: string
    tags?: TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightCreateOrConnectWithoutInterviewInput = {
    where: SuggestedHighlightWhereUniqueInput
    create: XOR<SuggestedHighlightCreateWithoutInterviewInput, SuggestedHighlightUncheckedCreateWithoutInterviewInput>
  }

  export type SuggestedHighlightCreateManyInterviewInputEnvelope = {
    data: Enumerable<SuggestedHighlightCreateManyInterviewInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutInterviewsInput = {
    id?: string
    name: string
    description?: string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInterviewsInput = {
    id?: string
    name: string
    description?: string
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInterviewsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInterviewsInput, ProjectUncheckedCreateWithoutInterviewsInput>
  }

  export type VideoUpsertWithoutInterviewInput = {
    update: XOR<VideoUpdateWithoutInterviewInput, VideoUncheckedUpdateWithoutInterviewInput>
    create: XOR<VideoCreateWithoutInterviewInput, VideoUncheckedCreateWithoutInterviewInput>
  }

  export type VideoUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlight?: HighlightUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUpdateOneWithoutVideoNestedInput
    recorder?: RecorderUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlight?: HighlightUncheckedUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUncheckedUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUpsertWithoutInterviewInput = {
    update: XOR<TranscriptUpdateWithoutInterviewInput, TranscriptUncheckedUpdateWithoutInterviewInput>
    create: XOR<TranscriptCreateWithoutInterviewInput, TranscriptUncheckedCreateWithoutInterviewInput>
  }

  export type TranscriptUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HighlightUpsertWithWhereUniqueWithoutInterviewInput = {
    where: HighlightWhereUniqueInput
    update: XOR<HighlightUpdateWithoutInterviewInput, HighlightUncheckedUpdateWithoutInterviewInput>
    create: XOR<HighlightCreateWithoutInterviewInput, HighlightUncheckedCreateWithoutInterviewInput>
  }

  export type HighlightUpdateWithWhereUniqueWithoutInterviewInput = {
    where: HighlightWhereUniqueInput
    data: XOR<HighlightUpdateWithoutInterviewInput, HighlightUncheckedUpdateWithoutInterviewInput>
  }

  export type HighlightUpdateManyWithWhereWithoutInterviewInput = {
    where: HighlightScalarWhereInput
    data: XOR<HighlightUpdateManyMutationInput, HighlightUncheckedUpdateManyWithoutHighlightsInput>
  }

  export type HighlightScalarWhereInput = {
    AND?: Enumerable<HighlightScalarWhereInput>
    OR?: Enumerable<HighlightScalarWhereInput>
    NOT?: Enumerable<HighlightScalarWhereInput>
    id?: StringFilter | string
    highlightedRangeId?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    interviewId?: StringFilter | string
    videoId?: StringNullableFilter | string | null
    transcriptId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    originSuggestionId?: StringNullableFilter | string | null
  }

  export type WorkspaceUpsertWithoutInterviewsInput = {
    update: XOR<WorkspaceUpdateWithoutInterviewsInput, WorkspaceUncheckedUpdateWithoutInterviewsInput>
    create: XOR<WorkspaceCreateWithoutInterviewsInput, WorkspaceUncheckedCreateWithoutInterviewsInput>
  }

  export type WorkspaceUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSourceUpsertWithoutInterviewInput = {
    update: XOR<InterviewSourceUpdateWithoutInterviewInput, InterviewSourceUncheckedUpdateWithoutInterviewInput>
    create: XOR<InterviewSourceCreateWithoutInterviewInput, InterviewSourceUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewSourceUpdateWithoutInterviewInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSourceUncheckedUpdateWithoutInterviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumInterviewSourcePlatformsFieldUpdateOperationsInput | InterviewSourcePlatforms
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSummaryUpsertWithoutInterviewInput = {
    update: XOR<InterviewSummaryUpdateWithoutInterviewInput, InterviewSummaryUncheckedUpdateWithoutInterviewInput>
    create: XOR<InterviewSummaryCreateWithoutInterviewInput, InterviewSummaryUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewSummaryUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSummaryUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    generatedText?: StringFieldUpdateOperationsInput | string
    touched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutInterviewsInput = {
    update: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
  }

  export type UserUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SuggestedHighlightUpsertWithWhereUniqueWithoutInterviewInput = {
    where: SuggestedHighlightWhereUniqueInput
    update: XOR<SuggestedHighlightUpdateWithoutInterviewInput, SuggestedHighlightUncheckedUpdateWithoutInterviewInput>
    create: XOR<SuggestedHighlightCreateWithoutInterviewInput, SuggestedHighlightUncheckedCreateWithoutInterviewInput>
  }

  export type SuggestedHighlightUpdateWithWhereUniqueWithoutInterviewInput = {
    where: SuggestedHighlightWhereUniqueInput
    data: XOR<SuggestedHighlightUpdateWithoutInterviewInput, SuggestedHighlightUncheckedUpdateWithoutInterviewInput>
  }

  export type SuggestedHighlightUpdateManyWithWhereWithoutInterviewInput = {
    where: SuggestedHighlightScalarWhereInput
    data: XOR<SuggestedHighlightUpdateManyMutationInput, SuggestedHighlightUncheckedUpdateManyWithoutSuggestedHighlightsInput>
  }

  export type SuggestedHighlightScalarWhereInput = {
    AND?: Enumerable<SuggestedHighlightScalarWhereInput>
    OR?: Enumerable<SuggestedHighlightScalarWhereInput>
    NOT?: Enumerable<SuggestedHighlightScalarWhereInput>
    id?: StringFilter | string
    highlightedRangeId?: StringFilter | string
    interviewId?: StringFilter | string
    transcriptId?: StringFilter | string
    status?: EnumSuggestedHighlightStatusFilter | SuggestedHighlightStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProjectUpsertWithoutInterviewsInput = {
    update: XOR<ProjectUpdateWithoutInterviewsInput, ProjectUncheckedUpdateWithoutInterviewsInput>
    create: XOR<ProjectCreateWithoutInterviewsInput, ProjectUncheckedCreateWithoutInterviewsInput>
  }

  export type ProjectUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type InterviewCreateWithoutRecordingInput = {
    id?: string
    name?: string
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutRecordingInput = {
    id?: string
    name?: string
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutRecordingInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
  }

  export type HighlightCreateWithoutVideoInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateWithoutVideoInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    transcriptId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightCreateOrConnectWithoutVideoInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
  }

  export type EditableAssetCreateWithoutVideoInput = {
    id?: string
    status: EditableAssetStatus
    playbackId?: string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditableAssetUncheckedCreateWithoutVideoInput = {
    id?: string
    status: EditableAssetStatus
    playbackId?: string | null
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditableAssetCreateOrConnectWithoutVideoInput = {
    where: EditableAssetWhereUniqueInput
    create: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
  }

  export type PlayableAssetCreateWithoutVideoInput = {
    id?: string
    platform: StoragePlatforms
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayableAssetUncheckedCreateWithoutVideoInput = {
    id?: string
    platform: StoragePlatforms
    isSigned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayableAssetCreateOrConnectWithoutVideoInput = {
    where: PlayableAssetWhereUniqueInput
    create: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
  }

  export type RecorderCreateWithoutVideoInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    target: RecordingTargetCreateNestedOneWithoutRecorderInput
    createdAt?: Date | string
    updatedAt?: Date | string
    status: RecorderStatus
  }

  export type RecorderUncheckedCreateWithoutVideoInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: RecorderStatus
  }

  export type RecorderCreateOrConnectWithoutVideoInput = {
    where: RecorderWhereUniqueInput
    create: XOR<RecorderCreateWithoutVideoInput, RecorderUncheckedCreateWithoutVideoInput>
  }

  export type InterviewUpsertWithoutRecordingInput = {
    update: XOR<InterviewUpdateWithoutRecordingInput, InterviewUncheckedUpdateWithoutRecordingInput>
    create: XOR<InterviewCreateWithoutRecordingInput, InterviewUncheckedCreateWithoutRecordingInput>
  }

  export type InterviewUpdateWithoutRecordingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutRecordingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HighlightUpsertWithoutVideoInput = {
    update: XOR<HighlightUpdateWithoutVideoInput, HighlightUncheckedUpdateWithoutVideoInput>
    create: XOR<HighlightCreateWithoutVideoInput, HighlightUncheckedCreateWithoutVideoInput>
  }

  export type HighlightUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EditableAssetUpsertWithoutVideoInput = {
    update: XOR<EditableAssetUpdateWithoutVideoInput, EditableAssetUncheckedUpdateWithoutVideoInput>
    create: XOR<EditableAssetCreateWithoutVideoInput, EditableAssetUncheckedCreateWithoutVideoInput>
  }

  export type EditableAssetUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditableAssetUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEditableAssetStatusFieldUpdateOperationsInput | EditableAssetStatus
    playbackId?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetUpsertWithoutVideoInput = {
    update: XOR<PlayableAssetUpdateWithoutVideoInput, PlayableAssetUncheckedUpdateWithoutVideoInput>
    create: XOR<PlayableAssetCreateWithoutVideoInput, PlayableAssetUncheckedCreateWithoutVideoInput>
  }

  export type PlayableAssetUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayableAssetUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumStoragePlatformsFieldUpdateOperationsInput | StoragePlatforms
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecorderUpsertWithoutVideoInput = {
    update: XOR<RecorderUpdateWithoutVideoInput, RecorderUncheckedUpdateWithoutVideoInput>
    create: XOR<RecorderCreateWithoutVideoInput, RecorderUncheckedCreateWithoutVideoInput>
  }

  export type RecorderUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    target?: RecordingTargetUpdateOneRequiredWithoutRecorderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecorderUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type VideoCreateWithoutEditableAssetInput = {
    id?: string
    interview?: InterviewCreateNestedOneWithoutRecordingInput
    highlight?: HighlightCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    playableAsset?: PlayableAssetCreateNestedOneWithoutVideoInput
    recorder?: RecorderCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutEditableAssetInput = {
    id?: string
    interview?: InterviewUncheckedCreateNestedOneWithoutRecordingInput
    highlight?: HighlightUncheckedCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    playableAsset?: PlayableAssetUncheckedCreateNestedOneWithoutVideoInput
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutEditableAssetInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutEditableAssetInput, VideoUncheckedCreateWithoutEditableAssetInput>
  }

  export type VideoUpsertWithoutEditableAssetInput = {
    update: XOR<VideoUpdateWithoutEditableAssetInput, VideoUncheckedUpdateWithoutEditableAssetInput>
    create: XOR<VideoCreateWithoutEditableAssetInput, VideoUncheckedCreateWithoutEditableAssetInput>
  }

  export type VideoUpdateWithoutEditableAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playableAsset?: PlayableAssetUpdateOneWithoutVideoNestedInput
    recorder?: RecorderUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutEditableAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUncheckedUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUncheckedUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playableAsset?: PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateWithoutPlayableAssetInput = {
    id?: string
    interview?: InterviewCreateNestedOneWithoutRecordingInput
    highlight?: HighlightCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetCreateNestedOneWithoutVideoInput
    recorder?: RecorderCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutPlayableAssetInput = {
    id?: string
    interview?: InterviewUncheckedCreateNestedOneWithoutRecordingInput
    highlight?: HighlightUncheckedCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetUncheckedCreateNestedOneWithoutVideoInput
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutPlayableAssetInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutPlayableAssetInput, VideoUncheckedCreateWithoutPlayableAssetInput>
  }

  export type VideoUpsertWithoutPlayableAssetInput = {
    update: XOR<VideoUpdateWithoutPlayableAssetInput, VideoUncheckedUpdateWithoutPlayableAssetInput>
    create: XOR<VideoCreateWithoutPlayableAssetInput, VideoUncheckedCreateWithoutPlayableAssetInput>
  }

  export type VideoUpdateWithoutPlayableAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUpdateOneWithoutVideoNestedInput
    recorder?: RecorderUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutPlayableAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUncheckedUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUncheckedUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUncheckedUpdateOneWithoutVideoNestedInput
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateWithoutTranscriptInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutTranscriptInput = {
    id?: string
    name?: string
    recordingId?: string | null
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutTranscriptInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutTranscriptInput, InterviewUncheckedCreateWithoutTranscriptInput>
  }

  export type HighlightCreateWithoutTranscriptInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    video?: VideoCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateWithoutTranscriptInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightCreateOrConnectWithoutTranscriptInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
  }

  export type SuggestedHighlightCreateWithoutTranscriptInput = {
    id?: string
    highlightedRange: WordRangeCreateNestedOneWithoutSuggestedHighlightInput
    interview: InterviewCreateNestedOneWithoutSuggestedHighlightsInput
    tags?: TagCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUncheckedCreateWithoutTranscriptInput = {
    id?: string
    highlightedRangeId: string
    interviewId: string
    tags?: TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightCreateOrConnectWithoutTranscriptInput = {
    where: SuggestedHighlightWhereUniqueInput
    create: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptWordCreateWithoutTranscriptInput = {
    group: TranscriptGroupCreateNestedOneWithoutWordsInput
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordUncheckedCreateWithoutTranscriptInput = {
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeUncheckedCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeUncheckedCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordCreateOrConnectWithoutTranscriptInput = {
    where: TranscriptWordWhereUniqueInput
    create: XOR<TranscriptWordCreateWithoutTranscriptInput, TranscriptWordUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptWordCreateManyTranscriptInputEnvelope = {
    data: Enumerable<TranscriptWordCreateManyTranscriptInput>
    skipDuplicates?: boolean
  }

  export type TranscriptGroupCreateWithoutTranscriptInput = {
    words?: TranscriptWordCreateNestedManyWithoutGroupInput
    text: string
    groupNumber: number
    speaker: ParticipantCreateNestedOneWithoutGroupsInput
  }

  export type TranscriptGroupUncheckedCreateWithoutTranscriptInput = {
    words?: TranscriptWordUncheckedCreateNestedManyWithoutGroupInput
    text: string
    groupNumber: number
    speakerId: string
  }

  export type TranscriptGroupCreateOrConnectWithoutTranscriptInput = {
    where: TranscriptGroupWhereUniqueInput
    create: XOR<TranscriptGroupCreateWithoutTranscriptInput, TranscriptGroupUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptGroupCreateManyTranscriptInputEnvelope = {
    data: Enumerable<TranscriptGroupCreateManyTranscriptInput>
    skipDuplicates?: boolean
  }

  export type InterviewUpsertWithoutTranscriptInput = {
    update: XOR<InterviewUpdateWithoutTranscriptInput, InterviewUncheckedUpdateWithoutTranscriptInput>
    create: XOR<InterviewCreateWithoutTranscriptInput, InterviewUncheckedCreateWithoutTranscriptInput>
  }

  export type InterviewUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HighlightUpsertWithoutTranscriptInput = {
    update: XOR<HighlightUpdateWithoutTranscriptInput, HighlightUncheckedUpdateWithoutTranscriptInput>
    create: XOR<HighlightCreateWithoutTranscriptInput, HighlightUncheckedCreateWithoutTranscriptInput>
  }

  export type HighlightUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    video?: VideoUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestedHighlightUpsertWithoutTranscriptInput = {
    update: XOR<SuggestedHighlightUpdateWithoutTranscriptInput, SuggestedHighlightUncheckedUpdateWithoutTranscriptInput>
    create: XOR<SuggestedHighlightCreateWithoutTranscriptInput, SuggestedHighlightUncheckedCreateWithoutTranscriptInput>
  }

  export type SuggestedHighlightUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    interview?: InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput
    tags?: TagUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type TranscriptWordUpsertWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptWordWhereUniqueInput
    update: XOR<TranscriptWordUpdateWithoutTranscriptInput, TranscriptWordUncheckedUpdateWithoutTranscriptInput>
    create: XOR<TranscriptWordCreateWithoutTranscriptInput, TranscriptWordUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptWordUpdateWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptWordWhereUniqueInput
    data: XOR<TranscriptWordUpdateWithoutTranscriptInput, TranscriptWordUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptWordUpdateManyWithWhereWithoutTranscriptInput = {
    where: TranscriptWordScalarWhereInput
    data: XOR<TranscriptWordUpdateManyMutationInput, TranscriptWordUncheckedUpdateManyWithoutWordsInput>
  }

  export type TranscriptWordScalarWhereInput = {
    AND?: Enumerable<TranscriptWordScalarWhereInput>
    OR?: Enumerable<TranscriptWordScalarWhereInput>
    NOT?: Enumerable<TranscriptWordScalarWhereInput>
    transcriptId?: StringFilter | string
    groupNumber?: IntFilter | number
    wordNumber?: IntFilter | number
    start?: FloatFilter | number
    end?: FloatFilter | number
    text?: StringFilter | string
  }

  export type TranscriptGroupUpsertWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptGroupWhereUniqueInput
    update: XOR<TranscriptGroupUpdateWithoutTranscriptInput, TranscriptGroupUncheckedUpdateWithoutTranscriptInput>
    create: XOR<TranscriptGroupCreateWithoutTranscriptInput, TranscriptGroupUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptGroupUpdateWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptGroupWhereUniqueInput
    data: XOR<TranscriptGroupUpdateWithoutTranscriptInput, TranscriptGroupUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptGroupUpdateManyWithWhereWithoutTranscriptInput = {
    where: TranscriptGroupScalarWhereInput
    data: XOR<TranscriptGroupUpdateManyMutationInput, TranscriptGroupUncheckedUpdateManyWithoutGroupsInput>
  }

  export type TranscriptGroupScalarWhereInput = {
    AND?: Enumerable<TranscriptGroupScalarWhereInput>
    OR?: Enumerable<TranscriptGroupScalarWhereInput>
    NOT?: Enumerable<TranscriptGroupScalarWhereInput>
    text?: StringFilter | string
    transcriptId?: StringFilter | string
    groupNumber?: IntFilter | number
    speakerId?: StringFilter | string
  }

  export type TranscriptCreateWithoutGroupsInput = {
    id?: string
    version?: number
    interview?: InterviewCreateNestedOneWithoutTranscriptInput
    highlight?: HighlightCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutGroupsInput = {
    id?: string
    version?: number
    interviewId?: string | null
    highlight?: HighlightUncheckedCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutGroupsInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutGroupsInput, TranscriptUncheckedCreateWithoutGroupsInput>
  }

  export type TranscriptWordCreateWithoutGroupInput = {
    transcript: TranscriptCreateNestedOneWithoutWordsInput
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordUncheckedCreateWithoutGroupInput = {
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeUncheckedCreateNestedManyWithoutStartWordInput
    endWordRanges?: WordRangeUncheckedCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordCreateOrConnectWithoutGroupInput = {
    where: TranscriptWordWhereUniqueInput
    create: XOR<TranscriptWordCreateWithoutGroupInput, TranscriptWordUncheckedCreateWithoutGroupInput>
  }

  export type TranscriptWordCreateManyGroupInputEnvelope = {
    data: Enumerable<TranscriptWordCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type ParticipantCreateWithoutGroupsInput = {
    id?: string
    name: string
  }

  export type ParticipantUncheckedCreateWithoutGroupsInput = {
    id?: string
    name: string
  }

  export type ParticipantCreateOrConnectWithoutGroupsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutGroupsInput, ParticipantUncheckedCreateWithoutGroupsInput>
  }

  export type TranscriptUpsertWithoutGroupsInput = {
    update: XOR<TranscriptUpdateWithoutGroupsInput, TranscriptUncheckedUpdateWithoutGroupsInput>
    create: XOR<TranscriptCreateWithoutGroupsInput, TranscriptUncheckedCreateWithoutGroupsInput>
  }

  export type TranscriptUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneWithoutTranscriptNestedInput
    highlight?: HighlightUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    highlight?: HighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptWordUpsertWithWhereUniqueWithoutGroupInput = {
    where: TranscriptWordWhereUniqueInput
    update: XOR<TranscriptWordUpdateWithoutGroupInput, TranscriptWordUncheckedUpdateWithoutGroupInput>
    create: XOR<TranscriptWordCreateWithoutGroupInput, TranscriptWordUncheckedCreateWithoutGroupInput>
  }

  export type TranscriptWordUpdateWithWhereUniqueWithoutGroupInput = {
    where: TranscriptWordWhereUniqueInput
    data: XOR<TranscriptWordUpdateWithoutGroupInput, TranscriptWordUncheckedUpdateWithoutGroupInput>
  }

  export type TranscriptWordUpdateManyWithWhereWithoutGroupInput = {
    where: TranscriptWordScalarWhereInput
    data: XOR<TranscriptWordUpdateManyMutationInput, TranscriptWordUncheckedUpdateManyWithoutWordsInput>
  }

  export type ParticipantUpsertWithoutGroupsInput = {
    update: XOR<ParticipantUpdateWithoutGroupsInput, ParticipantUncheckedUpdateWithoutGroupsInput>
    create: XOR<ParticipantCreateWithoutGroupsInput, ParticipantUncheckedCreateWithoutGroupsInput>
  }

  export type ParticipantUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptCreateWithoutWordsInput = {
    id?: string
    version?: number
    interview?: InterviewCreateNestedOneWithoutTranscriptInput
    highlight?: HighlightCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    groups?: TranscriptGroupCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutWordsInput = {
    id?: string
    version?: number
    interviewId?: string | null
    highlight?: HighlightUncheckedCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutWordsInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutWordsInput, TranscriptUncheckedCreateWithoutWordsInput>
  }

  export type TranscriptGroupCreateWithoutWordsInput = {
    transcript: TranscriptCreateNestedOneWithoutGroupsInput
    text: string
    groupNumber: number
    speaker: ParticipantCreateNestedOneWithoutGroupsInput
  }

  export type TranscriptGroupUncheckedCreateWithoutWordsInput = {
    text: string
    transcriptId: string
    groupNumber: number
    speakerId: string
  }

  export type TranscriptGroupCreateOrConnectWithoutWordsInput = {
    where: TranscriptGroupWhereUniqueInput
    create: XOR<TranscriptGroupCreateWithoutWordsInput, TranscriptGroupUncheckedCreateWithoutWordsInput>
  }

  export type WordRangeCreateWithoutStartWordInput = {
    id?: string
    endWord: TranscriptWordCreateNestedOneWithoutEndWordRangesInput
    highlight?: HighlightCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUncheckedCreateWithoutStartWordInput = {
    id?: string
    endWordNumber: number
    endGroupNumber: number
    highlight?: HighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeCreateOrConnectWithoutStartWordInput = {
    where: WordRangeWhereUniqueInput
    create: XOR<WordRangeCreateWithoutStartWordInput, WordRangeUncheckedCreateWithoutStartWordInput>
  }

  export type WordRangeCreateManyStartWordInputEnvelope = {
    data: Enumerable<WordRangeCreateManyStartWordInput>
    skipDuplicates?: boolean
  }

  export type WordRangeCreateWithoutEndWordInput = {
    id?: string
    startWord: TranscriptWordCreateNestedOneWithoutStartWordRangesInput
    highlight?: HighlightCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUncheckedCreateWithoutEndWordInput = {
    id?: string
    startWordNumber: number
    startGroupNumber: number
    highlight?: HighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeCreateOrConnectWithoutEndWordInput = {
    where: WordRangeWhereUniqueInput
    create: XOR<WordRangeCreateWithoutEndWordInput, WordRangeUncheckedCreateWithoutEndWordInput>
  }

  export type WordRangeCreateManyEndWordInputEnvelope = {
    data: Enumerable<WordRangeCreateManyEndWordInput>
    skipDuplicates?: boolean
  }

  export type TranscriptUpsertWithoutWordsInput = {
    update: XOR<TranscriptUpdateWithoutWordsInput, TranscriptUncheckedUpdateWithoutWordsInput>
    create: XOR<TranscriptCreateWithoutWordsInput, TranscriptUncheckedCreateWithoutWordsInput>
  }

  export type TranscriptUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneWithoutTranscriptNestedInput
    highlight?: HighlightUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    groups?: TranscriptGroupUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    highlight?: HighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    groups?: TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptGroupUpsertWithoutWordsInput = {
    update: XOR<TranscriptGroupUpdateWithoutWordsInput, TranscriptGroupUncheckedUpdateWithoutWordsInput>
    create: XOR<TranscriptGroupCreateWithoutWordsInput, TranscriptGroupUncheckedCreateWithoutWordsInput>
  }

  export type TranscriptGroupUpdateWithoutWordsInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutGroupsNestedInput
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speaker?: ParticipantUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type TranscriptGroupUncheckedUpdateWithoutWordsInput = {
    text?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type WordRangeUpsertWithWhereUniqueWithoutStartWordInput = {
    where: WordRangeWhereUniqueInput
    update: XOR<WordRangeUpdateWithoutStartWordInput, WordRangeUncheckedUpdateWithoutStartWordInput>
    create: XOR<WordRangeCreateWithoutStartWordInput, WordRangeUncheckedCreateWithoutStartWordInput>
  }

  export type WordRangeUpdateWithWhereUniqueWithoutStartWordInput = {
    where: WordRangeWhereUniqueInput
    data: XOR<WordRangeUpdateWithoutStartWordInput, WordRangeUncheckedUpdateWithoutStartWordInput>
  }

  export type WordRangeUpdateManyWithWhereWithoutStartWordInput = {
    where: WordRangeScalarWhereInput
    data: XOR<WordRangeUpdateManyMutationInput, WordRangeUncheckedUpdateManyWithoutStartWordRangesInput>
  }

  export type WordRangeScalarWhereInput = {
    AND?: Enumerable<WordRangeScalarWhereInput>
    OR?: Enumerable<WordRangeScalarWhereInput>
    NOT?: Enumerable<WordRangeScalarWhereInput>
    id?: StringFilter | string
    transcriptId?: StringFilter | string
    startWordNumber?: IntFilter | number
    startGroupNumber?: IntFilter | number
    endWordNumber?: IntFilter | number
    endGroupNumber?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WordRangeUpsertWithWhereUniqueWithoutEndWordInput = {
    where: WordRangeWhereUniqueInput
    update: XOR<WordRangeUpdateWithoutEndWordInput, WordRangeUncheckedUpdateWithoutEndWordInput>
    create: XOR<WordRangeCreateWithoutEndWordInput, WordRangeUncheckedCreateWithoutEndWordInput>
  }

  export type WordRangeUpdateWithWhereUniqueWithoutEndWordInput = {
    where: WordRangeWhereUniqueInput
    data: XOR<WordRangeUpdateWithoutEndWordInput, WordRangeUncheckedUpdateWithoutEndWordInput>
  }

  export type WordRangeUpdateManyWithWhereWithoutEndWordInput = {
    where: WordRangeScalarWhereInput
    data: XOR<WordRangeUpdateManyMutationInput, WordRangeUncheckedUpdateManyWithoutEndWordRangesInput>
  }

  export type TranscriptWordCreateWithoutStartWordRangesInput = {
    transcript: TranscriptCreateNestedOneWithoutWordsInput
    group: TranscriptGroupCreateNestedOneWithoutWordsInput
    wordNumber: number
    start: number
    end: number
    text: string
    endWordRanges?: WordRangeCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordUncheckedCreateWithoutStartWordRangesInput = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
    endWordRanges?: WordRangeUncheckedCreateNestedManyWithoutEndWordInput
  }

  export type TranscriptWordCreateOrConnectWithoutStartWordRangesInput = {
    where: TranscriptWordWhereUniqueInput
    create: XOR<TranscriptWordCreateWithoutStartWordRangesInput, TranscriptWordUncheckedCreateWithoutStartWordRangesInput>
  }

  export type TranscriptWordCreateWithoutEndWordRangesInput = {
    transcript: TranscriptCreateNestedOneWithoutWordsInput
    group: TranscriptGroupCreateNestedOneWithoutWordsInput
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeCreateNestedManyWithoutStartWordInput
  }

  export type TranscriptWordUncheckedCreateWithoutEndWordRangesInput = {
    transcriptId: string
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
    startWordRanges?: WordRangeUncheckedCreateNestedManyWithoutStartWordInput
  }

  export type TranscriptWordCreateOrConnectWithoutEndWordRangesInput = {
    where: TranscriptWordWhereUniqueInput
    create: XOR<TranscriptWordCreateWithoutEndWordRangesInput, TranscriptWordUncheckedCreateWithoutEndWordRangesInput>
  }

  export type HighlightCreateWithoutHighlightedRangeInput = {
    id?: string
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    video?: VideoCreateNestedOneWithoutHighlightInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateWithoutHighlightedRangeInput = {
    id?: string
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    transcriptId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightCreateOrConnectWithoutHighlightedRangeInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
  }

  export type SuggestedHighlightCreateWithoutHighlightedRangeInput = {
    id?: string
    interview: InterviewCreateNestedOneWithoutSuggestedHighlightsInput
    transcript: TranscriptCreateNestedOneWithoutSuggestedHighlightInput
    tags?: TagCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput = {
    id?: string
    interviewId: string
    transcriptId: string
    tags?: TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightCreateOrConnectWithoutHighlightedRangeInput = {
    where: SuggestedHighlightWhereUniqueInput
    create: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
  }

  export type TranscriptWordUpsertWithoutStartWordRangesInput = {
    update: XOR<TranscriptWordUpdateWithoutStartWordRangesInput, TranscriptWordUncheckedUpdateWithoutStartWordRangesInput>
    create: XOR<TranscriptWordCreateWithoutStartWordRangesInput, TranscriptWordUncheckedCreateWithoutStartWordRangesInput>
  }

  export type TranscriptWordUpdateWithoutStartWordRangesInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutWordsNestedInput
    group?: TranscriptGroupUpdateOneRequiredWithoutWordsNestedInput
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    endWordRanges?: WordRangeUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateWithoutStartWordRangesInput = {
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    endWordRanges?: WordRangeUncheckedUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUpsertWithoutEndWordRangesInput = {
    update: XOR<TranscriptWordUpdateWithoutEndWordRangesInput, TranscriptWordUncheckedUpdateWithoutEndWordRangesInput>
    create: XOR<TranscriptWordCreateWithoutEndWordRangesInput, TranscriptWordUncheckedCreateWithoutEndWordRangesInput>
  }

  export type TranscriptWordUpdateWithoutEndWordRangesInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutWordsNestedInput
    group?: TranscriptGroupUpdateOneRequiredWithoutWordsNestedInput
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUpdateManyWithoutStartWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateWithoutEndWordRangesInput = {
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUncheckedUpdateManyWithoutStartWordNestedInput
  }

  export type HighlightUpsertWithoutHighlightedRangeInput = {
    update: XOR<HighlightUpdateWithoutHighlightedRangeInput, HighlightUncheckedUpdateWithoutHighlightedRangeInput>
    create: XOR<HighlightCreateWithoutHighlightedRangeInput, HighlightUncheckedCreateWithoutHighlightedRangeInput>
  }

  export type HighlightUpdateWithoutHighlightedRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    video?: VideoUpdateOneWithoutHighlightNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateWithoutHighlightedRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestedHighlightUpsertWithoutHighlightedRangeInput = {
    update: XOR<SuggestedHighlightUpdateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedUpdateWithoutHighlightedRangeInput>
    create: XOR<SuggestedHighlightCreateWithoutHighlightedRangeInput, SuggestedHighlightUncheckedCreateWithoutHighlightedRangeInput>
  }

  export type SuggestedHighlightUpdateWithoutHighlightedRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    tags?: TagUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateWithoutHighlightedRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type WordRangeCreateWithoutHighlightInput = {
    id?: string
    startWord: TranscriptWordCreateNestedOneWithoutStartWordRangesInput
    endWord: TranscriptWordCreateNestedOneWithoutEndWordRangesInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUncheckedCreateWithoutHighlightInput = {
    id?: string
    transcriptId: string
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeCreateOrConnectWithoutHighlightInput = {
    where: WordRangeWhereUniqueInput
    create: XOR<WordRangeCreateWithoutHighlightInput, WordRangeUncheckedCreateWithoutHighlightInput>
  }

  export type InterviewCreateWithoutHighlightsInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutHighlightsInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutHighlightsInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutHighlightsInput, InterviewUncheckedCreateWithoutHighlightsInput>
  }

  export type VideoCreateWithoutHighlightInput = {
    id?: string
    interview?: InterviewCreateNestedOneWithoutRecordingInput
    startTime?: Date | string
    editableAsset?: EditableAssetCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetCreateNestedOneWithoutVideoInput
    recorder?: RecorderCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutHighlightInput = {
    id?: string
    interview?: InterviewUncheckedCreateNestedOneWithoutRecordingInput
    startTime?: Date | string
    editableAsset?: EditableAssetUncheckedCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetUncheckedCreateNestedOneWithoutVideoInput
    recorderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutHighlightInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutHighlightInput, VideoUncheckedCreateWithoutHighlightInput>
  }

  export type TranscriptCreateWithoutHighlightInput = {
    id?: string
    version?: number
    interview?: InterviewCreateNestedOneWithoutTranscriptInput
    suggestedHighlight?: SuggestedHighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutHighlightInput = {
    id?: string
    version?: number
    interviewId?: string | null
    suggestedHighlight?: SuggestedHighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutHighlightInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutHighlightInput, TranscriptUncheckedCreateWithoutHighlightInput>
  }

  export type TagCreateWithoutHighlightsInput = {
    id?: string
    name: string
    color?: TagColor
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUncheckedCreateWithoutHighlightsInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderUncheckedCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagCreateOrConnectWithoutHighlightsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutHighlightsInput, TagUncheckedCreateWithoutHighlightsInput>
  }

  export type SuggestedHighlightCreateWithoutHighlightInput = {
    id?: string
    highlightedRange: WordRangeCreateNestedOneWithoutSuggestedHighlightInput
    interview: InterviewCreateNestedOneWithoutSuggestedHighlightsInput
    transcript: TranscriptCreateNestedOneWithoutSuggestedHighlightInput
    tags?: TagCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuggestedHighlightUncheckedCreateWithoutHighlightInput = {
    id?: string
    highlightedRangeId: string
    interviewId: string
    transcriptId: string
    tags?: TagUncheckedCreateNestedManyWithoutSuggestedHighlightsInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuggestedHighlightCreateOrConnectWithoutHighlightInput = {
    where: SuggestedHighlightWhereUniqueInput
    create: XOR<SuggestedHighlightCreateWithoutHighlightInput, SuggestedHighlightUncheckedCreateWithoutHighlightInput>
  }

  export type WordRangeUpsertWithoutHighlightInput = {
    update: XOR<WordRangeUpdateWithoutHighlightInput, WordRangeUncheckedUpdateWithoutHighlightInput>
    create: XOR<WordRangeCreateWithoutHighlightInput, WordRangeUncheckedCreateWithoutHighlightInput>
  }

  export type WordRangeUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWord?: TranscriptWordUpdateOneRequiredWithoutStartWordRangesNestedInput
    endWord?: TranscriptWordUpdateOneRequiredWithoutEndWordRangesNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpsertWithoutHighlightsInput = {
    update: XOR<InterviewUpdateWithoutHighlightsInput, InterviewUncheckedUpdateWithoutHighlightsInput>
    create: XOR<InterviewCreateWithoutHighlightsInput, InterviewUncheckedCreateWithoutHighlightsInput>
  }

  export type InterviewUpdateWithoutHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoUpsertWithoutHighlightInput = {
    update: XOR<VideoUpdateWithoutHighlightInput, VideoUncheckedUpdateWithoutHighlightInput>
    create: XOR<VideoCreateWithoutHighlightInput, VideoUncheckedCreateWithoutHighlightInput>
  }

  export type VideoUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneWithoutRecordingNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUpdateOneWithoutVideoNestedInput
    recorder?: RecorderUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUncheckedUpdateOneWithoutRecordingNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUncheckedUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput
    recorderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUpsertWithoutHighlightInput = {
    update: XOR<TranscriptUpdateWithoutHighlightInput, TranscriptUncheckedUpdateWithoutHighlightInput>
    create: XOR<TranscriptCreateWithoutHighlightInput, TranscriptUncheckedCreateWithoutHighlightInput>
  }

  export type TranscriptUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneWithoutTranscriptNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutHighlightsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutHighlightsInput, TagUncheckedUpdateWithoutHighlightsInput>
    create: XOR<TagCreateWithoutHighlightsInput, TagUncheckedCreateWithoutHighlightsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutHighlightsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutHighlightsInput, TagUncheckedUpdateWithoutHighlightsInput>
  }

  export type TagUpdateManyWithWhereWithoutHighlightsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type TagScalarWhereInput = {
    AND?: Enumerable<TagScalarWhereInput>
    OR?: Enumerable<TagScalarWhereInput>
    NOT?: Enumerable<TagScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    color?: EnumTagColorFilter | TagColor
    workspaceId?: StringFilter | string
    autoExtract?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    isDefault?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    emoji?: StringFilter | string
  }

  export type SuggestedHighlightUpsertWithoutHighlightInput = {
    update: XOR<SuggestedHighlightUpdateWithoutHighlightInput, SuggestedHighlightUncheckedUpdateWithoutHighlightInput>
    create: XOR<SuggestedHighlightCreateWithoutHighlightInput, SuggestedHighlightUncheckedCreateWithoutHighlightInput>
  }

  export type SuggestedHighlightUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    interview?: InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    tags?: TagUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedHighlightUncheckedUpdateWithoutHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateWithoutCreatorInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutCreatorInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutCreatorInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutCreatorInput, InterviewUncheckedCreateWithoutCreatorInput>
  }

  export type InterviewCreateManyCreatorInputEnvelope = {
    data: Enumerable<InterviewCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceRoleCreateWithoutUserInput = {
    workspace: WorkspaceCreateNestedOneWithoutRolesInput
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUncheckedCreateWithoutUserInput = {
    workspaceId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleCreateOrConnectWithoutUserInput = {
    where: WorkspaceRoleWhereUniqueInput
    create: XOR<WorkspaceRoleCreateWithoutUserInput, WorkspaceRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceRoleCreateManyUserInputEnvelope = {
    data: Enumerable<WorkspaceRoleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ExternalAuthCreateWithoutUserInput = {
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthUncheckedCreateWithoutUserInput = {
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthCreateOrConnectWithoutUserInput = {
    where: ExternalAuthWhereUniqueInput
    create: XOR<ExternalAuthCreateWithoutUserInput, ExternalAuthUncheckedCreateWithoutUserInput>
  }

  export type ExternalAuthCreateManyUserInputEnvelope = {
    data: Enumerable<ExternalAuthCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type IdentityCreateWithoutUserInput = {
    token: string
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityUncheckedCreateWithoutUserInput = {
    token: string
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityCreateOrConnectWithoutUserInput = {
    where: IdentityWhereUniqueInput
    create: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput>
  }

  export type IdentityCreateManyUserInputEnvelope = {
    data: Enumerable<IdentityCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceInviteCreateWithoutUserInput = {
    token: string
    workspace: WorkspaceCreateNestedOneWithoutInviteTokensInput
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteUncheckedCreateWithoutUserInput = {
    token: string
    workspaceId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteCreateOrConnectWithoutUserInput = {
    where: WorkspaceInviteWhereUniqueInput
    create: XOR<WorkspaceInviteCreateWithoutUserInput, WorkspaceInviteUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceInviteCreateManyUserInputEnvelope = {
    data: Enumerable<WorkspaceInviteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationPreferencesCreateWithoutUserInput = {
    id?: string
    notificationEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    notificationEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferencesCreateOrConnectWithoutUserInput = {
    where: NotificationPreferencesWhereUniqueInput
    create: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserTagOrderCreateWithoutUserInput = {
    id?: string
    tag: TagCreateNestedOneWithoutUserOrdersInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderUncheckedCreateWithoutUserInput = {
    id?: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderCreateOrConnectWithoutUserInput = {
    where: UserTagOrderWhereUniqueInput
    create: XOR<UserTagOrderCreateWithoutUserInput, UserTagOrderUncheckedCreateWithoutUserInput>
  }

  export type UserTagOrderCreateManyUserInputEnvelope = {
    data: Enumerable<UserTagOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type InterviewUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutCreatorInput, InterviewUncheckedUpdateWithoutCreatorInput>
    create: XOR<InterviewCreateWithoutCreatorInput, InterviewUncheckedCreateWithoutCreatorInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutCreatorInput, InterviewUncheckedUpdateWithoutCreatorInput>
  }

  export type InterviewUpdateManyWithWhereWithoutCreatorInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutInterviewsInput>
  }

  export type InterviewScalarWhereInput = {
    AND?: Enumerable<InterviewScalarWhereInput>
    OR?: Enumerable<InterviewScalarWhereInput>
    NOT?: Enumerable<InterviewScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    recordingId?: StringNullableFilter | string | null
    workspaceId?: StringFilter | string
    creatorId?: StringFilter | string
    archived?: BoolFilter | boolean
    date?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    recordingError?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
  }

  export type WorkspaceRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceRoleWhereUniqueInput
    update: XOR<WorkspaceRoleUpdateWithoutUserInput, WorkspaceRoleUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceRoleCreateWithoutUserInput, WorkspaceRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceRoleWhereUniqueInput
    data: XOR<WorkspaceRoleUpdateWithoutUserInput, WorkspaceRoleUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceRoleUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceRoleScalarWhereInput
    data: XOR<WorkspaceRoleUpdateManyMutationInput, WorkspaceRoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type WorkspaceRoleScalarWhereInput = {
    AND?: Enumerable<WorkspaceRoleScalarWhereInput>
    OR?: Enumerable<WorkspaceRoleScalarWhereInput>
    NOT?: Enumerable<WorkspaceRoleScalarWhereInput>
    userId?: StringFilter | string
    workspaceId?: StringFilter | string
    type?: EnumRoleTypeFilter | RoleType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ExternalAuthUpsertWithWhereUniqueWithoutUserInput = {
    where: ExternalAuthWhereUniqueInput
    update: XOR<ExternalAuthUpdateWithoutUserInput, ExternalAuthUncheckedUpdateWithoutUserInput>
    create: XOR<ExternalAuthCreateWithoutUserInput, ExternalAuthUncheckedCreateWithoutUserInput>
  }

  export type ExternalAuthUpdateWithWhereUniqueWithoutUserInput = {
    where: ExternalAuthWhereUniqueInput
    data: XOR<ExternalAuthUpdateWithoutUserInput, ExternalAuthUncheckedUpdateWithoutUserInput>
  }

  export type ExternalAuthUpdateManyWithWhereWithoutUserInput = {
    where: ExternalAuthScalarWhereInput
    data: XOR<ExternalAuthUpdateManyMutationInput, ExternalAuthUncheckedUpdateManyWithoutSourceAuthsInput>
  }

  export type ExternalAuthScalarWhereInput = {
    AND?: Enumerable<ExternalAuthScalarWhereInput>
    OR?: Enumerable<ExternalAuthScalarWhereInput>
    NOT?: Enumerable<ExternalAuthScalarWhereInput>
    userId?: StringFilter | string
    type?: EnumExternalAuthTypesFilter | ExternalAuthTypes
    authToken?: StringFilter | string
    refreshToken?: StringFilter | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IdentityUpsertWithWhereUniqueWithoutUserInput = {
    where: IdentityWhereUniqueInput
    update: XOR<IdentityUpdateWithoutUserInput, IdentityUncheckedUpdateWithoutUserInput>
    create: XOR<IdentityCreateWithoutUserInput, IdentityUncheckedCreateWithoutUserInput>
  }

  export type IdentityUpdateWithWhereUniqueWithoutUserInput = {
    where: IdentityWhereUniqueInput
    data: XOR<IdentityUpdateWithoutUserInput, IdentityUncheckedUpdateWithoutUserInput>
  }

  export type IdentityUpdateManyWithWhereWithoutUserInput = {
    where: IdentityScalarWhereInput
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyWithoutIdentitiesInput>
  }

  export type IdentityScalarWhereInput = {
    AND?: Enumerable<IdentityScalarWhereInput>
    OR?: Enumerable<IdentityScalarWhereInput>
    NOT?: Enumerable<IdentityScalarWhereInput>
    token?: StringFilter | string
    userId?: StringFilter | string
    type?: EnumIdentityTypeFilter | IdentityType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WorkspaceInviteUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceInviteWhereUniqueInput
    update: XOR<WorkspaceInviteUpdateWithoutUserInput, WorkspaceInviteUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceInviteCreateWithoutUserInput, WorkspaceInviteUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceInviteUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceInviteWhereUniqueInput
    data: XOR<WorkspaceInviteUpdateWithoutUserInput, WorkspaceInviteUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceInviteUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceInviteScalarWhereInput
    data: XOR<WorkspaceInviteUpdateManyMutationInput, WorkspaceInviteUncheckedUpdateManyWithoutInviteTokensInput>
  }

  export type WorkspaceInviteScalarWhereInput = {
    AND?: Enumerable<WorkspaceInviteScalarWhereInput>
    OR?: Enumerable<WorkspaceInviteScalarWhereInput>
    NOT?: Enumerable<WorkspaceInviteScalarWhereInput>
    token?: StringFilter | string
    workspaceId?: StringFilter | string
    inviterId?: StringFilter | string
    isExpired?: BoolFilter | boolean
    inviteeEmail?: StringNullableFilter | string | null
    isAccepted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationPreferencesUpsertWithoutUserInput = {
    update: XOR<NotificationPreferencesUpdateWithoutUserInput, NotificationPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferencesCreateWithoutUserInput, NotificationPreferencesUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagOrderWhereUniqueInput
    update: XOR<UserTagOrderUpdateWithoutUserInput, UserTagOrderUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagOrderCreateWithoutUserInput, UserTagOrderUncheckedCreateWithoutUserInput>
  }

  export type UserTagOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagOrderWhereUniqueInput
    data: XOR<UserTagOrderUpdateWithoutUserInput, UserTagOrderUncheckedUpdateWithoutUserInput>
  }

  export type UserTagOrderUpdateManyWithWhereWithoutUserInput = {
    where: UserTagOrderScalarWhereInput
    data: XOR<UserTagOrderUpdateManyMutationInput, UserTagOrderUncheckedUpdateManyWithoutTagOrderInput>
  }

  export type UserTagOrderScalarWhereInput = {
    AND?: Enumerable<UserTagOrderScalarWhereInput>
    OR?: Enumerable<UserTagOrderScalarWhereInput>
    NOT?: Enumerable<UserTagOrderScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    tagId?: StringFilter | string
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutIdentitiesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdentitiesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdentitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
  }

  export type UserUpsertWithoutIdentitiesInput = {
    update: XOR<UserUpdateWithoutIdentitiesInput, UserUncheckedUpdateWithoutIdentitiesInput>
    create: XOR<UserCreateWithoutIdentitiesInput, UserUncheckedCreateWithoutIdentitiesInput>
  }

  export type UserUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSourceAuthsInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSourceAuthsInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSourceAuthsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSourceAuthsInput, UserUncheckedCreateWithoutSourceAuthsInput>
  }

  export type UserUpsertWithoutSourceAuthsInput = {
    update: XOR<UserUpdateWithoutSourceAuthsInput, UserUncheckedUpdateWithoutSourceAuthsInput>
    create: XOR<UserCreateWithoutSourceAuthsInput, UserUncheckedCreateWithoutSourceAuthsInput>
  }

  export type UserUpdateWithoutSourceAuthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSourceAuthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceRoleCreateWithoutWorkspaceInput = {
    user: UserCreateNestedOneWithoutRolesInput
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUncheckedCreateWithoutWorkspaceInput = {
    userId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceRoleWhereUniqueInput
    create: XOR<WorkspaceRoleCreateWithoutWorkspaceInput, WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceRoleCreateManyWorkspaceInputEnvelope = {
    data: Enumerable<WorkspaceRoleCreateManyWorkspaceInput>
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutWorkspaceInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutWorkspaceInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutWorkspaceInput, InterviewUncheckedCreateWithoutWorkspaceInput>
  }

  export type InterviewCreateManyWorkspaceInputEnvelope = {
    data: Enumerable<InterviewCreateManyWorkspaceInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceInviteCreateWithoutWorkspaceInput = {
    token: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    user: UserCreateNestedOneWithoutInviteTokensInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteUncheckedCreateWithoutWorkspaceInput = {
    token: string
    inviterId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInviteWhereUniqueInput
    create: XOR<WorkspaceInviteCreateWithoutWorkspaceInput, WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInviteCreateManyWorkspaceInputEnvelope = {
    data: Enumerable<WorkspaceInviteCreateManyWorkspaceInput>
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    color?: TagColor
    highlights?: HighlightCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    color?: TagColor
    highlights?: HighlightUncheckedCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderUncheckedCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagCreateOrConnectWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput>
  }

  export type TagCreateManyWorkspaceInputEnvelope = {
    data: Enumerable<TagCreateManyWorkspaceInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewCreateNestedManyWithoutProjectInput
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewUncheckedCreateNestedManyWithoutProjectInput
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectCreateManyWorkspaceInputEnvelope = {
    data: Enumerable<ProjectCreateManyWorkspaceInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceRoleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceRoleWhereUniqueInput
    update: XOR<WorkspaceRoleUpdateWithoutWorkspaceInput, WorkspaceRoleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceRoleCreateWithoutWorkspaceInput, WorkspaceRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceRoleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceRoleWhereUniqueInput
    data: XOR<WorkspaceRoleUpdateWithoutWorkspaceInput, WorkspaceRoleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceRoleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceRoleScalarWhereInput
    data: XOR<WorkspaceRoleUpdateManyMutationInput, WorkspaceRoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type InterviewUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutWorkspaceInput, InterviewUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<InterviewCreateWithoutWorkspaceInput, InterviewUncheckedCreateWithoutWorkspaceInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutWorkspaceInput, InterviewUncheckedUpdateWithoutWorkspaceInput>
  }

  export type InterviewUpdateManyWithWhereWithoutWorkspaceInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutInterviewsInput>
  }

  export type WorkspaceInviteUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInviteWhereUniqueInput
    update: XOR<WorkspaceInviteUpdateWithoutWorkspaceInput, WorkspaceInviteUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInviteCreateWithoutWorkspaceInput, WorkspaceInviteUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInviteUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInviteWhereUniqueInput
    data: XOR<WorkspaceInviteUpdateWithoutWorkspaceInput, WorkspaceInviteUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInviteUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInviteScalarWhereInput
    data: XOR<WorkspaceInviteUpdateManyMutationInput, WorkspaceInviteUncheckedUpdateManyWithoutInviteTokensInput>
  }

  export type TagUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutWorkspaceInput, TagUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput>
  }

  export type TagUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutWorkspaceInput, TagUncheckedUpdateWithoutWorkspaceInput>
  }

  export type TagUpdateManyWithWhereWithoutWorkspaceInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProjectUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: Enumerable<ProjectScalarWhereInput>
    OR?: Enumerable<ProjectScalarWhereInput>
    NOT?: Enumerable<ProjectScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    workspaceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WorkspaceCreateWithoutInviteTokensInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateWithoutInviteTokensInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceCreateOrConnectWithoutInviteTokensInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInviteTokensInput, WorkspaceUncheckedCreateWithoutInviteTokensInput>
  }

  export type UserCreateWithoutInviteTokensInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInviteTokensInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInviteTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInviteTokensInput, UserUncheckedCreateWithoutInviteTokensInput>
  }

  export type WorkspaceUpsertWithoutInviteTokensInput = {
    update: XOR<WorkspaceUpdateWithoutInviteTokensInput, WorkspaceUncheckedUpdateWithoutInviteTokensInput>
    create: XOR<WorkspaceCreateWithoutInviteTokensInput, WorkspaceUncheckedCreateWithoutInviteTokensInput>
  }

  export type WorkspaceUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutInviteTokensInput = {
    update: XOR<UserUpdateWithoutInviteTokensInput, UserUncheckedUpdateWithoutInviteTokensInput>
    create: XOR<UserCreateWithoutInviteTokensInput, UserUncheckedCreateWithoutInviteTokensInput>
  }

  export type UserUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type WorkspaceCreateWithoutRolesInput = {
    id?: string
    name: string
    interviews?: InterviewCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    interviews?: InterviewUncheckedCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceCreateOrConnectWithoutRolesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutRolesInput, WorkspaceUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutRolesInput = {
    update: XOR<WorkspaceUpdateWithoutRolesInput, WorkspaceUncheckedUpdateWithoutRolesInput>
    create: XOR<WorkspaceCreateWithoutRolesInput, WorkspaceUncheckedCreateWithoutRolesInput>
  }

  export type WorkspaceUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptGroupCreateWithoutSpeakerInput = {
    transcript: TranscriptCreateNestedOneWithoutGroupsInput
    words?: TranscriptWordCreateNestedManyWithoutGroupInput
    text: string
    groupNumber: number
  }

  export type TranscriptGroupUncheckedCreateWithoutSpeakerInput = {
    words?: TranscriptWordUncheckedCreateNestedManyWithoutGroupInput
    text: string
    transcriptId: string
    groupNumber: number
  }

  export type TranscriptGroupCreateOrConnectWithoutSpeakerInput = {
    where: TranscriptGroupWhereUniqueInput
    create: XOR<TranscriptGroupCreateWithoutSpeakerInput, TranscriptGroupUncheckedCreateWithoutSpeakerInput>
  }

  export type TranscriptGroupCreateManySpeakerInputEnvelope = {
    data: Enumerable<TranscriptGroupCreateManySpeakerInput>
    skipDuplicates?: boolean
  }

  export type TranscriptGroupUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: TranscriptGroupWhereUniqueInput
    update: XOR<TranscriptGroupUpdateWithoutSpeakerInput, TranscriptGroupUncheckedUpdateWithoutSpeakerInput>
    create: XOR<TranscriptGroupCreateWithoutSpeakerInput, TranscriptGroupUncheckedCreateWithoutSpeakerInput>
  }

  export type TranscriptGroupUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: TranscriptGroupWhereUniqueInput
    data: XOR<TranscriptGroupUpdateWithoutSpeakerInput, TranscriptGroupUncheckedUpdateWithoutSpeakerInput>
  }

  export type TranscriptGroupUpdateManyWithWhereWithoutSpeakerInput = {
    where: TranscriptGroupScalarWhereInput
    data: XOR<TranscriptGroupUpdateManyMutationInput, TranscriptGroupUncheckedUpdateManyWithoutGroupsInput>
  }

  export type WorkspaceCreateWithoutTagsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceCreateOrConnectWithoutTagsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
  }

  export type HighlightCreateWithoutTagsInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    video?: VideoCreateNestedOneWithoutHighlightInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestion?: SuggestedHighlightCreateNestedOneWithoutHighlightInput
  }

  export type HighlightUncheckedCreateWithoutTagsInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    transcriptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type HighlightCreateOrConnectWithoutTagsInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutTagsInput, HighlightUncheckedCreateWithoutTagsInput>
  }

  export type SuggestedHighlightCreateWithoutTagsInput = {
    id?: string
    highlightedRange: WordRangeCreateNestedOneWithoutSuggestedHighlightInput
    interview: InterviewCreateNestedOneWithoutSuggestedHighlightsInput
    transcript: TranscriptCreateNestedOneWithoutSuggestedHighlightInput
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightUncheckedCreateWithoutTagsInput = {
    id?: string
    highlightedRangeId: string
    interviewId: string
    transcriptId: string
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    highlight?: HighlightUncheckedCreateNestedOneWithoutOriginSuggestionInput
  }

  export type SuggestedHighlightCreateOrConnectWithoutTagsInput = {
    where: SuggestedHighlightWhereUniqueInput
    create: XOR<SuggestedHighlightCreateWithoutTagsInput, SuggestedHighlightUncheckedCreateWithoutTagsInput>
  }

  export type UserTagOrderCreateWithoutTagInput = {
    id?: string
    user: UserCreateNestedOneWithoutTagOrderInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderUncheckedCreateWithoutTagInput = {
    id?: string
    userId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderCreateOrConnectWithoutTagInput = {
    where: UserTagOrderWhereUniqueInput
    create: XOR<UserTagOrderCreateWithoutTagInput, UserTagOrderUncheckedCreateWithoutTagInput>
  }

  export type UserTagOrderCreateManyTagInputEnvelope = {
    data: Enumerable<UserTagOrderCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type ProjectTagsCreateWithoutTagInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutProjectTagsInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsUncheckedCreateWithoutTagInput = {
    id?: string
    projectId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsCreateOrConnectWithoutTagInput = {
    where: ProjectTagsWhereUniqueInput
    create: XOR<ProjectTagsCreateWithoutTagInput, ProjectTagsUncheckedCreateWithoutTagInput>
  }

  export type ProjectTagsCreateManyTagInputEnvelope = {
    data: Enumerable<ProjectTagsCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutTagsInput = {
    update: XOR<WorkspaceUpdateWithoutTagsInput, WorkspaceUncheckedUpdateWithoutTagsInput>
    create: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
  }

  export type WorkspaceUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HighlightUpsertWithWhereUniqueWithoutTagsInput = {
    where: HighlightWhereUniqueInput
    update: XOR<HighlightUpdateWithoutTagsInput, HighlightUncheckedUpdateWithoutTagsInput>
    create: XOR<HighlightCreateWithoutTagsInput, HighlightUncheckedCreateWithoutTagsInput>
  }

  export type HighlightUpdateWithWhereUniqueWithoutTagsInput = {
    where: HighlightWhereUniqueInput
    data: XOR<HighlightUpdateWithoutTagsInput, HighlightUncheckedUpdateWithoutTagsInput>
  }

  export type HighlightUpdateManyWithWhereWithoutTagsInput = {
    where: HighlightScalarWhereInput
    data: XOR<HighlightUpdateManyMutationInput, HighlightUncheckedUpdateManyWithoutHighlightsInput>
  }

  export type SuggestedHighlightUpsertWithWhereUniqueWithoutTagsInput = {
    where: SuggestedHighlightWhereUniqueInput
    update: XOR<SuggestedHighlightUpdateWithoutTagsInput, SuggestedHighlightUncheckedUpdateWithoutTagsInput>
    create: XOR<SuggestedHighlightCreateWithoutTagsInput, SuggestedHighlightUncheckedCreateWithoutTagsInput>
  }

  export type SuggestedHighlightUpdateWithWhereUniqueWithoutTagsInput = {
    where: SuggestedHighlightWhereUniqueInput
    data: XOR<SuggestedHighlightUpdateWithoutTagsInput, SuggestedHighlightUncheckedUpdateWithoutTagsInput>
  }

  export type SuggestedHighlightUpdateManyWithWhereWithoutTagsInput = {
    where: SuggestedHighlightScalarWhereInput
    data: XOR<SuggestedHighlightUpdateManyMutationInput, SuggestedHighlightUncheckedUpdateManyWithoutSuggestedHighlightsInput>
  }

  export type UserTagOrderUpsertWithWhereUniqueWithoutTagInput = {
    where: UserTagOrderWhereUniqueInput
    update: XOR<UserTagOrderUpdateWithoutTagInput, UserTagOrderUncheckedUpdateWithoutTagInput>
    create: XOR<UserTagOrderCreateWithoutTagInput, UserTagOrderUncheckedCreateWithoutTagInput>
  }

  export type UserTagOrderUpdateWithWhereUniqueWithoutTagInput = {
    where: UserTagOrderWhereUniqueInput
    data: XOR<UserTagOrderUpdateWithoutTagInput, UserTagOrderUncheckedUpdateWithoutTagInput>
  }

  export type UserTagOrderUpdateManyWithWhereWithoutTagInput = {
    where: UserTagOrderScalarWhereInput
    data: XOR<UserTagOrderUpdateManyMutationInput, UserTagOrderUncheckedUpdateManyWithoutUserOrdersInput>
  }

  export type ProjectTagsUpsertWithWhereUniqueWithoutTagInput = {
    where: ProjectTagsWhereUniqueInput
    update: XOR<ProjectTagsUpdateWithoutTagInput, ProjectTagsUncheckedUpdateWithoutTagInput>
    create: XOR<ProjectTagsCreateWithoutTagInput, ProjectTagsUncheckedCreateWithoutTagInput>
  }

  export type ProjectTagsUpdateWithWhereUniqueWithoutTagInput = {
    where: ProjectTagsWhereUniqueInput
    data: XOR<ProjectTagsUpdateWithoutTagInput, ProjectTagsUncheckedUpdateWithoutTagInput>
  }

  export type ProjectTagsUpdateManyWithWhereWithoutTagInput = {
    where: ProjectTagsScalarWhereInput
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyWithoutProjectTagsInput>
  }

  export type ProjectTagsScalarWhereInput = {
    AND?: Enumerable<ProjectTagsScalarWhereInput>
    OR?: Enumerable<ProjectTagsScalarWhereInput>
    NOT?: Enumerable<ProjectTagsScalarWhereInput>
    id?: StringFilter | string
    projectId?: StringFilter | string
    tagId?: StringFilter | string
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    tagOrder?: UserTagOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    tagOrder?: UserTagOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagOrder?: UserTagOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagOrder?: UserTagOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTagOrderInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthCreateNestedManyWithoutUserInput
    identities?: IdentityCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagOrderInput = {
    id?: string
    email: string
    emailHash?: string | null
    fullName: string
    confirmed?: boolean
    interviews?: InterviewUncheckedCreateNestedManyWithoutCreatorInput
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutUserInput
    sourceAuths?: ExternalAuthUncheckedCreateNestedManyWithoutUserInput
    identities?: IdentityUncheckedCreateNestedManyWithoutUserInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferencesUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagOrderInput, UserUncheckedCreateWithoutTagOrderInput>
  }

  export type TagCreateWithoutUserOrdersInput = {
    id?: string
    name: string
    color?: TagColor
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
    highlights?: HighlightCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutTagsInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUncheckedCreateWithoutUserOrdersInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    highlights?: HighlightUncheckedCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagCreateOrConnectWithoutUserOrdersInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutUserOrdersInput, TagUncheckedCreateWithoutUserOrdersInput>
  }

  export type UserUpsertWithoutTagOrderInput = {
    update: XOR<UserUpdateWithoutTagOrderInput, UserUncheckedUpdateWithoutTagOrderInput>
    create: XOR<UserCreateWithoutTagOrderInput, UserUncheckedCreateWithoutTagOrderInput>
  }

  export type UserUpdateWithoutTagOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUpdateManyWithoutUserNestedInput
    identities?: IdentityUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    interviews?: InterviewUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutUserNestedInput
    sourceAuths?: ExternalAuthUncheckedUpdateManyWithoutUserNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutUserNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TagUpsertWithoutUserOrdersInput = {
    update: XOR<TagUpdateWithoutUserOrdersInput, TagUncheckedUpdateWithoutUserOrdersInput>
    create: XOR<TagCreateWithoutUserOrdersInput, TagUncheckedCreateWithoutUserOrdersInput>
  }

  export type TagUpdateWithoutUserOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
    highlights?: HighlightUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutTagsNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutUserOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    highlights?: HighlightUncheckedUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type WordRangeCreateWithoutSuggestedHighlightInput = {
    id?: string
    startWord: TranscriptWordCreateNestedOneWithoutStartWordRangesInput
    endWord: TranscriptWordCreateNestedOneWithoutEndWordRangesInput
    highlight?: HighlightCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUncheckedCreateWithoutSuggestedHighlightInput = {
    id?: string
    transcriptId: string
    startWordNumber: number
    startGroupNumber: number
    endWordNumber: number
    endGroupNumber: number
    highlight?: HighlightUncheckedCreateNestedOneWithoutHighlightedRangeInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeCreateOrConnectWithoutSuggestedHighlightInput = {
    where: WordRangeWhereUniqueInput
    create: XOR<WordRangeCreateWithoutSuggestedHighlightInput, WordRangeUncheckedCreateWithoutSuggestedHighlightInput>
  }

  export type InterviewCreateWithoutSuggestedHighlightsInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    project?: ProjectCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutSuggestedHighlightsInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    projectId?: string | null
  }

  export type InterviewCreateOrConnectWithoutSuggestedHighlightsInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutSuggestedHighlightsInput, InterviewUncheckedCreateWithoutSuggestedHighlightsInput>
  }

  export type TranscriptCreateWithoutSuggestedHighlightInput = {
    id?: string
    version?: number
    interview?: InterviewCreateNestedOneWithoutTranscriptInput
    highlight?: HighlightCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutSuggestedHighlightInput = {
    id?: string
    version?: number
    interviewId?: string | null
    highlight?: HighlightUncheckedCreateNestedOneWithoutTranscriptInput
    isPending: boolean
    words?: TranscriptWordUncheckedCreateNestedManyWithoutTranscriptInput
    groups?: TranscriptGroupUncheckedCreateNestedManyWithoutTranscriptInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutSuggestedHighlightInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutSuggestedHighlightInput, TranscriptUncheckedCreateWithoutSuggestedHighlightInput>
  }

  export type TagCreateWithoutSuggestedHighlightsInput = {
    id?: string
    name: string
    color?: TagColor
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
    highlights?: HighlightCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagUncheckedCreateWithoutSuggestedHighlightsInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    highlights?: HighlightUncheckedCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderUncheckedCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagInput
    emoji?: string
  }

  export type TagCreateOrConnectWithoutSuggestedHighlightsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSuggestedHighlightsInput, TagUncheckedCreateWithoutSuggestedHighlightsInput>
  }

  export type HighlightCreateWithoutOriginSuggestionInput = {
    id?: string
    highlightedRange?: WordRangeCreateNestedOneWithoutHighlightInput
    timestamp?: Date | string | null
    interview: InterviewCreateNestedOneWithoutHighlightsInput
    video?: VideoCreateNestedOneWithoutHighlightInput
    transcript?: TranscriptCreateNestedOneWithoutHighlightInput
    tags?: TagCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HighlightUncheckedCreateWithoutOriginSuggestionInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    interviewId: string
    videoId?: string | null
    transcriptId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutHighlightsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HighlightCreateOrConnectWithoutOriginSuggestionInput = {
    where: HighlightWhereUniqueInput
    create: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
  }

  export type WordRangeUpsertWithoutSuggestedHighlightInput = {
    update: XOR<WordRangeUpdateWithoutSuggestedHighlightInput, WordRangeUncheckedUpdateWithoutSuggestedHighlightInput>
    create: XOR<WordRangeCreateWithoutSuggestedHighlightInput, WordRangeUncheckedCreateWithoutSuggestedHighlightInput>
  }

  export type WordRangeUpdateWithoutSuggestedHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWord?: TranscriptWordUpdateOneRequiredWithoutStartWordRangesNestedInput
    endWord?: TranscriptWordUpdateOneRequiredWithoutEndWordRangesNestedInput
    highlight?: HighlightUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateWithoutSuggestedHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpsertWithoutSuggestedHighlightsInput = {
    update: XOR<InterviewUpdateWithoutSuggestedHighlightsInput, InterviewUncheckedUpdateWithoutSuggestedHighlightsInput>
    create: XOR<InterviewCreateWithoutSuggestedHighlightsInput, InterviewUncheckedCreateWithoutSuggestedHighlightsInput>
  }

  export type InterviewUpdateWithoutSuggestedHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutSuggestedHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUpsertWithoutSuggestedHighlightInput = {
    update: XOR<TranscriptUpdateWithoutSuggestedHighlightInput, TranscriptUncheckedUpdateWithoutSuggestedHighlightInput>
    create: XOR<TranscriptCreateWithoutSuggestedHighlightInput, TranscriptUncheckedCreateWithoutSuggestedHighlightInput>
  }

  export type TranscriptUpdateWithoutSuggestedHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneWithoutTranscriptNestedInput
    highlight?: HighlightUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutSuggestedHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    interviewId?: NullableStringFieldUpdateOperationsInput | string | null
    highlight?: HighlightUncheckedUpdateOneWithoutTranscriptNestedInput
    isPending?: BoolFieldUpdateOperationsInput | boolean
    words?: TranscriptWordUncheckedUpdateManyWithoutTranscriptNestedInput
    groups?: TranscriptGroupUncheckedUpdateManyWithoutTranscriptNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutSuggestedHighlightsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutSuggestedHighlightsInput, TagUncheckedUpdateWithoutSuggestedHighlightsInput>
    create: XOR<TagCreateWithoutSuggestedHighlightsInput, TagUncheckedCreateWithoutSuggestedHighlightsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutSuggestedHighlightsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutSuggestedHighlightsInput, TagUncheckedUpdateWithoutSuggestedHighlightsInput>
  }

  export type TagUpdateManyWithWhereWithoutSuggestedHighlightsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type HighlightUpsertWithoutOriginSuggestionInput = {
    update: XOR<HighlightUpdateWithoutOriginSuggestionInput, HighlightUncheckedUpdateWithoutOriginSuggestionInput>
    create: XOR<HighlightCreateWithoutOriginSuggestionInput, HighlightUncheckedCreateWithoutOriginSuggestionInput>
  }

  export type HighlightUpdateWithoutOriginSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    video?: VideoUpdateOneWithoutHighlightNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HighlightUncheckedUpdateWithoutOriginSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateWithoutProjectInput = {
    id?: string
    name?: string
    recording?: VideoCreateNestedOneWithoutInterviewInput
    transcript?: TranscriptCreateNestedOneWithoutInterviewInput
    highlights?: HighlightCreateNestedManyWithoutInterviewInput
    workspace: WorkspaceCreateNestedOneWithoutInterviewsInput
    source?: InterviewSourceCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryCreateNestedOneWithoutInterviewInput
    creator: UserCreateNestedOneWithoutInterviewsInput
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutProjectInput = {
    id?: string
    name?: string
    recordingId?: string | null
    transcript?: TranscriptUncheckedCreateNestedOneWithoutInterviewInput
    highlights?: HighlightUncheckedCreateNestedManyWithoutInterviewInput
    workspaceId: string
    source?: InterviewSourceUncheckedCreateNestedOneWithoutInterviewInput
    summary?: InterviewSummaryUncheckedCreateNestedOneWithoutInterviewInput
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type InterviewCreateOrConnectWithoutProjectInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutProjectInput, InterviewUncheckedCreateWithoutProjectInput>
  }

  export type InterviewCreateManyProjectInputEnvelope = {
    data: Enumerable<InterviewCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutProjectsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    roles?: WorkspaceRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutWorkspaceInput
    inviteTokens?: WorkspaceInviteUncheckedCreateNestedManyWithoutWorkspaceInput
    publicInterviewLinks?: boolean
    ownedDomain?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceCreateOrConnectWithoutProjectsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTagsCreateWithoutProjectInput = {
    id?: string
    tag: TagCreateNestedOneWithoutProjectTagsInput
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsUncheckedCreateWithoutProjectInput = {
    id?: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsCreateOrConnectWithoutProjectInput = {
    where: ProjectTagsWhereUniqueInput
    create: XOR<ProjectTagsCreateWithoutProjectInput, ProjectTagsUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTagsCreateManyProjectInputEnvelope = {
    data: Enumerable<ProjectTagsCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type InterviewUpsertWithWhereUniqueWithoutProjectInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutProjectInput, InterviewUncheckedUpdateWithoutProjectInput>
    create: XOR<InterviewCreateWithoutProjectInput, InterviewUncheckedCreateWithoutProjectInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutProjectInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutProjectInput, InterviewUncheckedUpdateWithoutProjectInput>
  }

  export type InterviewUpdateManyWithWhereWithoutProjectInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutInterviewsInput>
  }

  export type WorkspaceUpsertWithoutProjectsInput = {
    update: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
  }

  export type WorkspaceUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roles?: WorkspaceRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutWorkspaceNestedInput
    inviteTokens?: WorkspaceInviteUncheckedUpdateManyWithoutWorkspaceNestedInput
    publicInterviewLinks?: BoolFieldUpdateOperationsInput | boolean
    ownedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTagsWhereUniqueInput
    update: XOR<ProjectTagsUpdateWithoutProjectInput, ProjectTagsUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTagsCreateWithoutProjectInput, ProjectTagsUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTagsUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTagsWhereUniqueInput
    data: XOR<ProjectTagsUpdateWithoutProjectInput, ProjectTagsUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTagsUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTagsScalarWhereInput
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyWithoutProjectTagsInput>
  }

  export type ProjectCreateWithoutProjectTagsInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewCreateNestedManyWithoutProjectInput
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutProjectTagsInput = {
    id?: string
    name: string
    description?: string
    interviews?: InterviewUncheckedCreateNestedManyWithoutProjectInput
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutProjectTagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
  }

  export type TagCreateWithoutProjectTagsInput = {
    id?: string
    name: string
    color?: TagColor
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
    highlights?: HighlightCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emoji?: string
  }

  export type TagUncheckedCreateWithoutProjectTagsInput = {
    id?: string
    name: string
    color?: TagColor
    workspaceId: string
    highlights?: HighlightUncheckedCreateNestedManyWithoutTagsInput
    suggestedHighlights?: SuggestedHighlightUncheckedCreateNestedManyWithoutTagsInput
    userOrders?: UserTagOrderUncheckedCreateNestedManyWithoutTagInput
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emoji?: string
  }

  export type TagCreateOrConnectWithoutProjectTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
  }

  export type ProjectUpsertWithoutProjectTagsInput = {
    update: XOR<ProjectUpdateWithoutProjectTagsInput, ProjectUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
  }

  export type ProjectUpdateWithoutProjectTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUpdateManyWithoutProjectNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutProjectTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUncheckedUpdateManyWithoutProjectNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutProjectTagsInput = {
    update: XOR<TagUpdateWithoutProjectTagsInput, TagUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
  }

  export type TagUpdateWithoutProjectTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
    highlights?: HighlightUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutProjectTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    highlights?: HighlightUncheckedUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUncheckedUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type RecordingTargetCreateWithoutRecorderInput = {
    id?: string
    type: RecordingTargetType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordingTargetUncheckedCreateWithoutRecorderInput = {
    id?: string
    type: RecordingTargetType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordingTargetCreateOrConnectWithoutRecorderInput = {
    where: RecordingTargetWhereUniqueInput
    create: XOR<RecordingTargetCreateWithoutRecorderInput, RecordingTargetUncheckedCreateWithoutRecorderInput>
  }

  export type VideoCreateWithoutRecorderInput = {
    id?: string
    interview?: InterviewCreateNestedOneWithoutRecordingInput
    highlight?: HighlightCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutRecorderInput = {
    id?: string
    interview?: InterviewUncheckedCreateNestedOneWithoutRecordingInput
    highlight?: HighlightUncheckedCreateNestedOneWithoutVideoInput
    startTime?: Date | string
    editableAsset?: EditableAssetUncheckedCreateNestedOneWithoutVideoInput
    playableAsset?: PlayableAssetUncheckedCreateNestedOneWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutRecorderInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutRecorderInput, VideoUncheckedCreateWithoutRecorderInput>
  }

  export type VideoCreateManyRecorderInputEnvelope = {
    data: Enumerable<VideoCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type RecordingTargetUpsertWithoutRecorderInput = {
    update: XOR<RecordingTargetUpdateWithoutRecorderInput, RecordingTargetUncheckedUpdateWithoutRecorderInput>
    create: XOR<RecordingTargetCreateWithoutRecorderInput, RecordingTargetUncheckedCreateWithoutRecorderInput>
  }

  export type RecordingTargetUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordingTargetUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRecordingTargetTypeFieldUpdateOperationsInput | RecordingTargetType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutRecorderInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutRecorderInput, VideoUncheckedUpdateWithoutRecorderInput>
    create: XOR<VideoCreateWithoutRecorderInput, VideoUncheckedCreateWithoutRecorderInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutRecorderInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutRecorderInput, VideoUncheckedUpdateWithoutRecorderInput>
  }

  export type VideoUpdateManyWithWhereWithoutRecorderInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoScalarWhereInput = {
    AND?: Enumerable<VideoScalarWhereInput>
    OR?: Enumerable<VideoScalarWhereInput>
    NOT?: Enumerable<VideoScalarWhereInput>
    id?: StringFilter | string
    startTime?: DateTimeFilter | Date | string
    recorderId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RecorderCreateWithoutTargetInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    createdAt?: Date | string
    updatedAt?: Date | string
    Video?: VideoCreateNestedManyWithoutRecorderInput
    status: RecorderStatus
  }

  export type RecorderUncheckedCreateWithoutTargetInput = {
    id?: string
    externalId?: string | null
    error?: string | null
    type: RecorderType
    createdAt?: Date | string
    updatedAt?: Date | string
    Video?: VideoUncheckedCreateNestedManyWithoutRecorderInput
    status: RecorderStatus
  }

  export type RecorderCreateOrConnectWithoutTargetInput = {
    where: RecorderWhereUniqueInput
    create: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
  }

  export type RecorderUpsertWithoutTargetInput = {
    update: XOR<RecorderUpdateWithoutTargetInput, RecorderUncheckedUpdateWithoutTargetInput>
    create: XOR<RecorderCreateWithoutTargetInput, RecorderUncheckedCreateWithoutTargetInput>
  }

  export type RecorderUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: VideoUpdateManyWithoutRecorderNestedInput
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type RecorderUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRecorderTypeFieldUpdateOperationsInput | RecorderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: VideoUncheckedUpdateManyWithoutRecorderNestedInput
    status?: EnumRecorderStatusFieldUpdateOperationsInput | RecorderStatus
  }

  export type HighlightCreateManyInterviewInput = {
    id?: string
    highlightedRangeId?: string | null
    timestamp?: Date | string | null
    videoId?: string | null
    transcriptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originSuggestionId?: string | null
  }

  export type SuggestedHighlightCreateManyInterviewInput = {
    id?: string
    highlightedRangeId: string
    transcriptId: string
    status: SuggestedHighlightStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HighlightUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    video?: VideoUpdateOneWithoutHighlightNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    tags?: TagUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutHighlightsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HighlightUncheckedUpdateManyWithoutHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestedHighlightUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    tags?: TagUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutSuggestedHighlightsNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateManyWithoutSuggestedHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptWordCreateManyTranscriptInput = {
    groupNumber: number
    wordNumber: number
    start: number
    end: number
    text: string
  }

  export type TranscriptGroupCreateManyTranscriptInput = {
    text: string
    groupNumber: number
    speakerId: string
  }

  export type TranscriptWordUpdateWithoutTranscriptInput = {
    group?: TranscriptGroupUpdateOneRequiredWithoutWordsNestedInput
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateWithoutTranscriptInput = {
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUncheckedUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUncheckedUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateManyWithoutWordsInput = {
    groupNumber?: IntFieldUpdateOperationsInput | number
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptGroupUpdateWithoutTranscriptInput = {
    words?: TranscriptWordUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speaker?: ParticipantUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type TranscriptGroupUncheckedUpdateWithoutTranscriptInput = {
    words?: TranscriptWordUncheckedUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptGroupUncheckedUpdateManyWithoutGroupsInput = {
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptWordCreateManyGroupInput = {
    wordNumber: number
    start: number
    end: number
    text: string
  }

  export type TranscriptWordUpdateWithoutGroupInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutWordsNestedInput
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUpdateManyWithoutEndWordNestedInput
  }

  export type TranscriptWordUncheckedUpdateWithoutGroupInput = {
    wordNumber?: IntFieldUpdateOperationsInput | number
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    startWordRanges?: WordRangeUncheckedUpdateManyWithoutStartWordNestedInput
    endWordRanges?: WordRangeUncheckedUpdateManyWithoutEndWordNestedInput
  }

  export type WordRangeCreateManyStartWordInput = {
    id?: string
    endWordNumber: number
    endGroupNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeCreateManyEndWordInput = {
    id?: string
    startWordNumber: number
    startGroupNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WordRangeUpdateWithoutStartWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    endWord?: TranscriptWordUpdateOneRequiredWithoutEndWordRangesNestedInput
    highlight?: HighlightUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateWithoutStartWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateManyWithoutStartWordRangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    endWordNumber?: IntFieldUpdateOperationsInput | number
    endGroupNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUpdateWithoutEndWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWord?: TranscriptWordUpdateOneRequiredWithoutStartWordRangesNestedInput
    highlight?: HighlightUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateWithoutEndWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    highlight?: HighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    suggestedHighlight?: SuggestedHighlightUncheckedUpdateOneWithoutHighlightedRangeNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WordRangeUncheckedUpdateManyWithoutEndWordRangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startWordNumber?: IntFieldUpdateOperationsInput | number
    startGroupNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUncheckedUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewCreateManyCreatorInput = {
    id?: string
    name?: string
    recordingId?: string | null
    workspaceId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    projectId?: string | null
  }

  export type WorkspaceRoleCreateManyUserInput = {
    workspaceId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuthCreateManyUserInput = {
    type: ExternalAuthTypes
    authToken: string
    refreshToken: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityCreateManyUserInput = {
    token: string
    type: IdentityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInviteCreateManyUserInput = {
    token: string
    workspaceId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagOrderCreateManyUserInput = {
    id?: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewUncheckedUpdateManyWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceRoleUpdateWithoutUserInput = {
    workspace?: WorkspaceUpdateOneRequiredWithoutRolesNestedInput
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleUncheckedUpdateWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleUncheckedUpdateManyWithoutRolesInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthUpdateWithoutUserInput = {
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthUncheckedUpdateWithoutUserInput = {
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuthUncheckedUpdateManyWithoutSourceAuthsInput = {
    type?: EnumExternalAuthTypesFieldUpdateOperationsInput | ExternalAuthTypes
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateManyWithoutIdentitiesInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumIdentityTypeFieldUpdateOperationsInput | IdentityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInviteTokensNestedInput
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUncheckedUpdateManyWithoutInviteTokensInput = {
    token?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutUserOrdersNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateManyWithoutTagOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleCreateManyWorkspaceInput = {
    userId: string
    type: RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateManyWorkspaceInput = {
    id?: string
    name?: string
    recordingId?: string | null
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
    projectId?: string | null
  }

  export type WorkspaceInviteCreateManyWorkspaceInput = {
    token: string
    inviterId: string
    isExpired?: boolean
    inviteeEmail?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyWorkspaceInput = {
    id?: string
    name: string
    color?: TagColor
    autoExtract?: boolean
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emoji?: string
  }

  export type ProjectCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceRoleUpdateWithoutWorkspaceInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceRoleUncheckedUpdateWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoleTypeFieldUpdateOperationsInput | RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
    project?: ProjectUpdateOneWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInviteUpdateWithoutWorkspaceInput = {
    token?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutInviteTokensNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInviteUncheckedUpdateWithoutWorkspaceInput = {
    token?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    inviteeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    highlights?: HighlightUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    highlights?: HighlightUncheckedUpdateManyWithoutTagsNestedInput
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUncheckedUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUpdateManyWithoutProjectNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    interviews?: InterviewUncheckedUpdateManyWithoutProjectNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptGroupCreateManySpeakerInput = {
    text: string
    transcriptId: string
    groupNumber: number
  }

  export type TranscriptGroupUpdateWithoutSpeakerInput = {
    transcript?: TranscriptUpdateOneRequiredWithoutGroupsNestedInput
    words?: TranscriptWordUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
  }

  export type TranscriptGroupUncheckedUpdateWithoutSpeakerInput = {
    words?: TranscriptWordUncheckedUpdateManyWithoutGroupNestedInput
    text?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    groupNumber?: IntFieldUpdateOperationsInput | number
  }

  export type UserTagOrderCreateManyTagInput = {
    id?: string
    userId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagsCreateManyTagInput = {
    id?: string
    projectId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HighlightUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneWithoutHighlightNestedInput
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: InterviewUpdateOneRequiredWithoutHighlightsNestedInput
    video?: VideoUpdateOneWithoutHighlightNestedInput
    transcript?: TranscriptUpdateOneWithoutHighlightNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestion?: SuggestedHighlightUpdateOneWithoutHighlightNestedInput
  }

  export type HighlightUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviewId?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestedHighlightUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRange?: WordRangeUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    interview?: InterviewUpdateOneRequiredWithoutSuggestedHighlightsNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutSuggestedHighlightNestedInput
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type SuggestedHighlightUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightedRangeId?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcriptId?: StringFieldUpdateOperationsInput | string
    status?: EnumSuggestedHighlightStatusFieldUpdateOperationsInput | SuggestedHighlightStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highlight?: HighlightUncheckedUpdateOneWithoutOriginSuggestionNestedInput
  }

  export type UserTagOrderUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTagOrderNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagOrderUncheckedUpdateManyWithoutUserOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectTagsNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUncheckedUpdateManyWithoutProjectTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutSuggestedHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
    highlights?: HighlightUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutSuggestedHighlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumTagColorFieldUpdateOperationsInput | TagColor
    workspaceId?: StringFieldUpdateOperationsInput | string
    highlights?: HighlightUncheckedUpdateManyWithoutTagsNestedInput
    userOrders?: UserTagOrderUncheckedUpdateManyWithoutTagNestedInput
    autoExtract?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagNestedInput
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type InterviewCreateManyProjectInput = {
    id?: string
    name?: string
    recordingId?: string | null
    workspaceId: string
    creatorId: string
    archived?: boolean
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordingError?: string | null
  }

  export type ProjectTagsCreateManyProjectInput = {
    id?: string
    tagId: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recording?: VideoUpdateOneWithoutInterviewNestedInput
    transcript?: TranscriptUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUpdateManyWithoutInterviewNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutInterviewsNestedInput
    source?: InterviewSourceUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUpdateOneWithoutInterviewNestedInput
    creator?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUpdateManyWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recordingId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUncheckedUpdateOneWithoutInterviewNestedInput
    highlights?: HighlightUncheckedUpdateManyWithoutInterviewNestedInput
    workspaceId?: StringFieldUpdateOperationsInput | string
    source?: InterviewSourceUncheckedUpdateOneWithoutInterviewNestedInput
    summary?: InterviewSummaryUncheckedUpdateOneWithoutInterviewNestedInput
    creatorId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingError?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedHighlights?: SuggestedHighlightUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type ProjectTagsUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutProjectTagsNestedInput
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagsUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyRecorderInput = {
    id?: string
    startTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    interview?: InterviewUncheckedUpdateOneWithoutRecordingNestedInput
    highlight?: HighlightUncheckedUpdateOneWithoutVideoNestedInput
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    editableAsset?: EditableAssetUncheckedUpdateOneWithoutVideoNestedInput
    playableAsset?: PlayableAssetUncheckedUpdateOneWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}